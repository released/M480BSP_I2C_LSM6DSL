; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\spi.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\spi.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\spi.crf ..\..\..\Library\StdDriver\src\spi.c]
                          THUMB

                          AREA ||i.SPII2S_Close||, CODE, READONLY, ALIGN=1

                  SPII2S_Close PROC
;;;1238     */
;;;1239   void SPII2S_Close(SPI_T *i2s)
000000  6e01              LDR      r1,[r0,#0x60]
;;;1240   {
;;;1241       i2s->I2SCTL &= ~SPI_I2SCTL_I2SEN_Msk;
000002  f0210101          BIC      r1,r1,#1
000006  6601              STR      r1,[r0,#0x60]
;;;1242   }
000008  4770              BX       lr
;;;1243   
                          ENDP


                          AREA ||i.SPII2S_DisableInt||, CODE, READONLY, ALIGN=1

                  SPII2S_DisableInt PROC
;;;1318     */
;;;1319   void SPII2S_DisableInt(SPI_T *i2s, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;1320   {
000002  d003              BEQ      |L2.12|
;;;1321       /* Disable TX threshold interrupt flag */
;;;1322       if((u32Mask & SPII2S_FIFO_TXTH_INT_MASK) == SPII2S_FIFO_TXTH_INT_MASK)
;;;1323       {
;;;1324           i2s->FIFOCTL &= ~SPI_FIFOCTL_TXTHIEN_Msk;
000004  6902              LDR      r2,[r0,#0x10]
000006  f0220208          BIC      r2,r2,#8
00000a  6102              STR      r2,[r0,#0x10]
                  |L2.12|
;;;1325       }
;;;1326   
;;;1327       /* Disable RX threshold interrupt flag */
;;;1328       if((u32Mask & SPII2S_FIFO_RXTH_INT_MASK) == SPII2S_FIFO_RXTH_INT_MASK)
00000c  078a              LSLS     r2,r1,#30
00000e  d503              BPL      |L2.24|
;;;1329       {
;;;1330           i2s->FIFOCTL &= ~SPI_FIFOCTL_RXTHIEN_Msk;
000010  6902              LDR      r2,[r0,#0x10]
000012  f0220204          BIC      r2,r2,#4
000016  6102              STR      r2,[r0,#0x10]
                  |L2.24|
;;;1331       }
;;;1332   
;;;1333       /* Disable RX overrun interrupt flag */
;;;1334       if((u32Mask & SPII2S_FIFO_RXOV_INT_MASK) == SPII2S_FIFO_RXOV_INT_MASK)
000018  074a              LSLS     r2,r1,#29
00001a  d503              BPL      |L2.36|
;;;1335       {
;;;1336           i2s->FIFOCTL &= ~SPI_FIFOCTL_RXOVIEN_Msk;
00001c  6902              LDR      r2,[r0,#0x10]
00001e  f0220220          BIC      r2,r2,#0x20
000022  6102              STR      r2,[r0,#0x10]
                  |L2.36|
;;;1337       }
;;;1338   
;;;1339       /* Disable RX time-out interrupt flag */
;;;1340       if((u32Mask & SPII2S_FIFO_RXTO_INT_MASK) == SPII2S_FIFO_RXTO_INT_MASK)
000024  070a              LSLS     r2,r1,#28
000026  d503              BPL      |L2.48|
;;;1341       {
;;;1342           i2s->FIFOCTL &= ~SPI_FIFOCTL_RXTOIEN_Msk;
000028  6902              LDR      r2,[r0,#0x10]
00002a  f0220210          BIC      r2,r2,#0x10
00002e  6102              STR      r2,[r0,#0x10]
                  |L2.48|
;;;1343       }
;;;1344   
;;;1345       /* Disable TX underflow interrupt flag */
;;;1346       if((u32Mask & SPII2S_TXUF_INT_MASK) == SPII2S_TXUF_INT_MASK)
000030  06ca              LSLS     r2,r1,#27
000032  d503              BPL      |L2.60|
;;;1347       {
;;;1348           i2s->FIFOCTL &= ~SPI_FIFOCTL_TXUFIEN_Msk;
000034  6902              LDR      r2,[r0,#0x10]
000036  f0220280          BIC      r2,r2,#0x80
00003a  6102              STR      r2,[r0,#0x10]
                  |L2.60|
;;;1349       }
;;;1350   
;;;1351       /* Disable right channel zero cross interrupt flag */
;;;1352       if((u32Mask & SPII2S_RIGHT_ZC_INT_MASK) == SPII2S_RIGHT_ZC_INT_MASK)
00003c  068a              LSLS     r2,r1,#26
00003e  d503              BPL      |L2.72|
;;;1353       {
;;;1354           i2s->I2SCTL &= ~SPI_I2SCTL_RZCIEN_Msk;
000040  6e02              LDR      r2,[r0,#0x60]
000042  f0227280          BIC      r2,r2,#0x1000000
000046  6602              STR      r2,[r0,#0x60]
                  |L2.72|
;;;1355       }
;;;1356   
;;;1357       /* Disable left channel zero cross interrupt flag */
;;;1358       if((u32Mask & SPII2S_LEFT_ZC_INT_MASK) == SPII2S_LEFT_ZC_INT_MASK)
000048  0649              LSLS     r1,r1,#25
00004a  d503              BPL      |L2.84|
;;;1359       {
;;;1360           i2s->I2SCTL &= ~SPI_I2SCTL_LZCIEN_Msk;
00004c  6e01              LDR      r1,[r0,#0x60]
00004e  f0217100          BIC      r1,r1,#0x2000000
000052  6601              STR      r1,[r0,#0x60]
                  |L2.84|
;;;1361       }
;;;1362   }
000054  4770              BX       lr
;;;1363   
                          ENDP


                          AREA ||i.SPII2S_DisableMCLK||, CODE, READONLY, ALIGN=1

                  SPII2S_DisableMCLK PROC
;;;1415     */
;;;1416   void SPII2S_DisableMCLK(SPI_T *i2s)
000000  6e01              LDR      r1,[r0,#0x60]
;;;1417   {
;;;1418       i2s->I2SCTL &= ~SPI_I2SCTL_MCLKEN_Msk;
000002  f4214100          BIC      r1,r1,#0x8000
000006  6601              STR      r1,[r0,#0x60]
;;;1419   }
000008  4770              BX       lr
;;;1420   
                          ENDP


                          AREA ||i.SPII2S_EnableInt||, CODE, READONLY, ALIGN=1

                  SPII2S_EnableInt PROC
;;;1258     */
;;;1259   void SPII2S_EnableInt(SPI_T *i2s, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;1260   {
000002  d003              BEQ      |L4.12|
;;;1261       /* Enable TX threshold interrupt flag */
;;;1262       if((u32Mask & SPII2S_FIFO_TXTH_INT_MASK) == SPII2S_FIFO_TXTH_INT_MASK)
;;;1263       {
;;;1264           i2s->FIFOCTL |= SPI_FIFOCTL_TXTHIEN_Msk;
000004  6902              LDR      r2,[r0,#0x10]
000006  f0420208          ORR      r2,r2,#8
00000a  6102              STR      r2,[r0,#0x10]
                  |L4.12|
;;;1265       }
;;;1266   
;;;1267       /* Enable RX threshold interrupt flag */
;;;1268       if((u32Mask & SPII2S_FIFO_RXTH_INT_MASK) == SPII2S_FIFO_RXTH_INT_MASK)
00000c  078a              LSLS     r2,r1,#30
00000e  d503              BPL      |L4.24|
;;;1269       {
;;;1270           i2s->FIFOCTL |= SPI_FIFOCTL_RXTHIEN_Msk;
000010  6902              LDR      r2,[r0,#0x10]
000012  f0420204          ORR      r2,r2,#4
000016  6102              STR      r2,[r0,#0x10]
                  |L4.24|
;;;1271       }
;;;1272   
;;;1273       /* Enable RX overrun interrupt flag */
;;;1274       if((u32Mask & SPII2S_FIFO_RXOV_INT_MASK) == SPII2S_FIFO_RXOV_INT_MASK)
000018  074a              LSLS     r2,r1,#29
00001a  d503              BPL      |L4.36|
;;;1275       {
;;;1276           i2s->FIFOCTL |= SPI_FIFOCTL_RXOVIEN_Msk;
00001c  6902              LDR      r2,[r0,#0x10]
00001e  f0420220          ORR      r2,r2,#0x20
000022  6102              STR      r2,[r0,#0x10]
                  |L4.36|
;;;1277       }
;;;1278   
;;;1279       /* Enable RX time-out interrupt flag */
;;;1280       if((u32Mask & SPII2S_FIFO_RXTO_INT_MASK) == SPII2S_FIFO_RXTO_INT_MASK)
000024  070a              LSLS     r2,r1,#28
000026  d503              BPL      |L4.48|
;;;1281       {
;;;1282           i2s->FIFOCTL |= SPI_FIFOCTL_RXTOIEN_Msk;
000028  6902              LDR      r2,[r0,#0x10]
00002a  f0420210          ORR      r2,r2,#0x10
00002e  6102              STR      r2,[r0,#0x10]
                  |L4.48|
;;;1283       }
;;;1284   
;;;1285       /* Enable TX underflow interrupt flag */
;;;1286       if((u32Mask & SPII2S_TXUF_INT_MASK) == SPII2S_TXUF_INT_MASK)
000030  06ca              LSLS     r2,r1,#27
000032  d503              BPL      |L4.60|
;;;1287       {
;;;1288           i2s->FIFOCTL |= SPI_FIFOCTL_TXUFIEN_Msk;
000034  6902              LDR      r2,[r0,#0x10]
000036  f0420280          ORR      r2,r2,#0x80
00003a  6102              STR      r2,[r0,#0x10]
                  |L4.60|
;;;1289       }
;;;1290   
;;;1291       /* Enable right channel zero cross interrupt flag */
;;;1292       if((u32Mask & SPII2S_RIGHT_ZC_INT_MASK) == SPII2S_RIGHT_ZC_INT_MASK)
00003c  068a              LSLS     r2,r1,#26
00003e  d503              BPL      |L4.72|
;;;1293       {
;;;1294           i2s->I2SCTL |= SPI_I2SCTL_RZCIEN_Msk;
000040  6e02              LDR      r2,[r0,#0x60]
000042  f0427280          ORR      r2,r2,#0x1000000
000046  6602              STR      r2,[r0,#0x60]
                  |L4.72|
;;;1295       }
;;;1296   
;;;1297       /* Enable left channel zero cross interrupt flag */
;;;1298       if((u32Mask & SPII2S_LEFT_ZC_INT_MASK) == SPII2S_LEFT_ZC_INT_MASK)
000048  0649              LSLS     r1,r1,#25
00004a  d503              BPL      |L4.84|
;;;1299       {
;;;1300           i2s->I2SCTL |= SPI_I2SCTL_LZCIEN_Msk;
00004c  6e01              LDR      r1,[r0,#0x60]
00004e  f0417100          ORR      r1,r1,#0x2000000
000052  6601              STR      r1,[r0,#0x60]
                  |L4.84|
;;;1301       }
;;;1302   }
000054  4770              BX       lr
;;;1303   
                          ENDP


                          AREA ||i.SPII2S_EnableMCLK||, CODE, READONLY, ALIGN=1

                  SPII2S_EnableMCLK PROC
;;;1371     */
;;;1372   uint32_t SPII2S_EnableMCLK(SPI_T *i2s, uint32_t u32BusClock)
000000  b570              PUSH     {r4-r6,lr}
;;;1373   {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;1374       uint32_t u32Divider;
;;;1375       uint32_t u32SrcClk, u32RetValue;
;;;1376   
;;;1377       u32SrcClk = SPII2S_GetSourceClockFreq(i2s);
000006  f7fffffe          BL       SPII2S_GetSourceClockFreq
;;;1378       if(u32BusClock == u32SrcClk)
00000a  4285              CMP      r5,r0
00000c  d101              BNE      |L5.18|
;;;1379       {
;;;1380           u32Divider = 0U;
00000e  2100              MOVS     r1,#0
000010  e005              B        |L5.30|
                  |L5.18|
;;;1381       }
;;;1382       else
;;;1383       {
;;;1384           u32Divider = (u32SrcClk / u32BusClock) >> 1U;
000012  fbb0f1f5          UDIV     r1,r0,r5
000016  0849              LSRS     r1,r1,#1
;;;1385           /* MCLKDIV is a 6-bit width configuration. The maximum value is 0x3F. */
;;;1386           if(u32Divider > 0x3FU)
000018  293f              CMP      r1,#0x3f
00001a  d900              BLS      |L5.30|
;;;1387           {
;;;1388               u32Divider = 0x3FU;
00001c  213f              MOVS     r1,#0x3f
                  |L5.30|
;;;1389           }
;;;1390       }
;;;1391   
;;;1392       /* Write u32Divider to MCLKDIV (SPI_I2SCLK[5:0]) */
;;;1393       i2s->I2SCLK = (i2s->I2SCLK & ~SPI_I2SCLK_MCLKDIV_Msk) | (u32Divider << SPI_I2SCLK_MCLKDIV_Pos);
00001e  6e62              LDR      r2,[r4,#0x64]
000020  f022027f          BIC      r2,r2,#0x7f
000024  430a              ORRS     r2,r2,r1
000026  6662              STR      r2,[r4,#0x64]
;;;1394   
;;;1395       /* Enable MCLK output */
;;;1396       i2s->I2SCTL |= SPI_I2SCTL_MCLKEN_Msk;
000028  6e22              LDR      r2,[r4,#0x60]
00002a  f4424200          ORR      r2,r2,#0x8000
00002e  6622              STR      r2,[r4,#0x60]
;;;1397   
;;;1398       if(u32Divider == 0U)
000030  2900              CMP      r1,#0
000032  d002              BEQ      |L5.58|
;;;1399       {
;;;1400           u32RetValue = u32SrcClk; /* If MCLKDIV=0, master clock rate is equal to the source clock rate. */
;;;1401       }
;;;1402       else
;;;1403       {
;;;1404           u32RetValue = ((u32SrcClk >> 1U) / u32Divider); /* If MCLKDIV>0, master clock rate = source clock rate / (MCLKDIV * 2) */
000034  0840              LSRS     r0,r0,#1
000036  fbb0f0f1          UDIV     r0,r0,r1
                  |L5.58|
;;;1405       }
;;;1406   
;;;1407       return u32RetValue;
;;;1408   }
00003a  bd70              POP      {r4-r6,pc}
;;;1409   
                          ENDP


                          AREA ||i.SPII2S_GetSourceClockFreq||, CODE, READONLY, ALIGN=2

                  SPII2S_GetSourceClockFreq PROC
;;;1017     */
;;;1018   static uint32_t SPII2S_GetSourceClockFreq(SPI_T *i2s)
000000  4b29              LDR      r3,|L6.168|
;;;1019   {
;;;1020       uint32_t u32Freq;
;;;1021   
;;;1022       if(i2s == SPI0)
;;;1023       {
;;;1024           if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_HXT)
;;;1025           {
;;;1026               u32Freq = __HXT; /* Clock source is HXT */
000002  492a              LDR      r1,|L6.172|
000004  049a              LSLS     r2,r3,#18             ;1024
000006  4298              CMP      r0,r3                 ;1022
000008  d111              BNE      |L6.46|
00000a  f8d20218          LDR      r0,[r2,#0x218]        ;1024
00000e  f0100f30          TST      r0,#0x30              ;1024
000012  d00a              BEQ      |L6.42|
;;;1027           }
;;;1028           else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_PLL)
000014  f8d20218          LDR      r0,[r2,#0x218]
000018  f3c01001          UBFX     r0,r0,#4,#2
00001c  2801              CMP      r0,#1
00001e  d040              BEQ      |L6.162|
;;;1029           {
;;;1030               u32Freq = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;1031           }
;;;1032           else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_PCLK1)
000020  f8d20218          LDR      r0,[r2,#0x218]
000024  f3c01001          UBFX     r0,r0,#4,#2
000028  e026              B        |L6.120|
                  |L6.42|
00002a  4608              MOV      r0,r1                 ;1026
;;;1033           {
;;;1034               /* Clock source is PCLK1 */
;;;1035               u32Freq = CLK_GetPCLK1Freq();
;;;1036           }
;;;1037           else
;;;1038           {
;;;1039               u32Freq = __HIRC; /* Clock source is HIRC */
;;;1040           }
;;;1041       }
;;;1042       else if(i2s == SPI1)
;;;1043       {
;;;1044           if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI1SEL_Msk) == CLK_CLKSEL2_SPI1SEL_HXT)
;;;1045           {
;;;1046               u32Freq = __HXT; /* Clock source is HXT */
;;;1047           }
;;;1048           else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI1SEL_Msk) == CLK_CLKSEL2_SPI1SEL_PLL)
;;;1049           {
;;;1050               u32Freq = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;1051           }
;;;1052           else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI1SEL_Msk) == CLK_CLKSEL2_SPI1SEL_PCLK0)
;;;1053           {
;;;1054               /* Clock source is PCLK0 */
;;;1055               u32Freq = CLK_GetPCLK0Freq();
;;;1056           }
;;;1057           else
;;;1058           {
;;;1059               u32Freq = __HIRC; /* Clock source is HIRC */
;;;1060           }
;;;1061       }
;;;1062       else if(i2s == SPI2)
;;;1063       {
;;;1064           if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI2SEL_Msk) == CLK_CLKSEL2_SPI2SEL_HXT)
;;;1065           {
;;;1066               u32Freq = __HXT; /* Clock source is HXT */
;;;1067           }
;;;1068           else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI2SEL_Msk) == CLK_CLKSEL2_SPI2SEL_PLL)
;;;1069           {
;;;1070               u32Freq = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;1071           }
;;;1072           else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI2SEL_Msk) == CLK_CLKSEL2_SPI2SEL_PCLK1)
;;;1073           {
;;;1074               /* Clock source is PCLK1 */
;;;1075               u32Freq = CLK_GetPCLK1Freq();
;;;1076           }
;;;1077           else
;;;1078           {
;;;1079               u32Freq = __HIRC; /* Clock source is HIRC */
;;;1080           }
;;;1081       }
;;;1082       else
;;;1083       {
;;;1084           if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI3SEL_Msk) == CLK_CLKSEL2_SPI3SEL_HXT)
;;;1085           {
;;;1086               u32Freq = __HXT; /* Clock source is HXT */
;;;1087           }
;;;1088           else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI3SEL_Msk) == CLK_CLKSEL2_SPI3SEL_PLL)
;;;1089           {
;;;1090               u32Freq = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;1091           }
;;;1092           else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI3SEL_Msk) == CLK_CLKSEL2_SPI3SEL_PCLK0)
;;;1093           {
;;;1094               /* Clock source is PCLK0 */
;;;1095               u32Freq = CLK_GetPCLK0Freq();
;;;1096           }
;;;1097           else
;;;1098           {
;;;1099               u32Freq = __HIRC; /* Clock source is HIRC */
;;;1100           }
;;;1101       }
;;;1102   
;;;1103       return u32Freq;
;;;1104   }
00002c  4770              BX       lr
                  |L6.46|
00002e  4b20              LDR      r3,|L6.176|
000030  4298              CMP      r0,r3                 ;1042
000032  d10f              BNE      |L6.84|
000034  f8d20218          LDR      r0,[r2,#0x218]        ;1044
000038  f0100fc0          TST      r0,#0xc0              ;1044
00003c  d0f5              BEQ      |L6.42|
00003e  f8d20218          LDR      r0,[r2,#0x218]        ;1048
000042  f3c01081          UBFX     r0,r0,#6,#2           ;1048
000046  2801              CMP      r0,#1                 ;1048
000048  d02b              BEQ      |L6.162|
00004a  f8d20218          LDR      r0,[r2,#0x218]        ;1052
00004e  f3c01081          UBFX     r0,r0,#6,#2           ;1052
000052  e022              B        |L6.154|
                  |L6.84|
000054  4b17              LDR      r3,|L6.180|
000056  4298              CMP      r0,r3                 ;1062
000058  f8d20218          LDR      r0,[r2,#0x218]        ;1084
00005c  d110              BNE      |L6.128|
00005e  f4106f40          TST      r0,#0xc00             ;1064
000062  d0e2              BEQ      |L6.42|
000064  f8d20218          LDR      r0,[r2,#0x218]        ;1068
000068  f3c02081          UBFX     r0,r0,#10,#2          ;1068
00006c  2801              CMP      r0,#1                 ;1068
00006e  d018              BEQ      |L6.162|
000070  f8d20218          LDR      r0,[r2,#0x218]        ;1072
000074  f3c02081          UBFX     r0,r0,#10,#2          ;1072
                  |L6.120|
000078  2802              CMP      r0,#2                 ;1072
00007a  d1d6              BNE      |L6.42|
00007c  f7ffbffe          B.W      CLK_GetPCLK1Freq
                  |L6.128|
000080  f4105f40          TST      r0,#0x3000            ;1084
000084  d0d1              BEQ      |L6.42|
000086  f8d20218          LDR      r0,[r2,#0x218]        ;1088
00008a  f3c03001          UBFX     r0,r0,#12,#2          ;1088
00008e  2801              CMP      r0,#1                 ;1088
000090  d007              BEQ      |L6.162|
000092  f8d20218          LDR      r0,[r2,#0x218]        ;1092
000096  f3c03001          UBFX     r0,r0,#12,#2          ;1092
                  |L6.154|
00009a  2802              CMP      r0,#2                 ;1092
00009c  d1c5              BNE      |L6.42|
00009e  f7ffbffe          B.W      CLK_GetPCLK0Freq
                  |L6.162|
0000a2  f7ffbffe          B.W      CLK_GetPLLClockFreq
;;;1105   
                          ENDP

0000a6  0000              DCW      0x0000
                  |L6.168|
                          DCD      0x40061000
                  |L6.172|
                          DCD      0x00b71b00
                  |L6.176|
                          DCD      0x40062000
                  |L6.180|
                          DCD      0x40063000

                          AREA ||i.SPII2S_Open||, CODE, READONLY, ALIGN=2

                  SPII2S_Open PROC
;;;1131     */
;;;1132   uint32_t SPII2S_Open(SPI_T *i2s, uint32_t u32MasterSlave, uint32_t u32SampleRate, uint32_t u32WordWidth, uint32_t u32Channels, uint32_t u32DataFormat)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1133   {
000004  4617              MOV      r7,r2
;;;1134       uint32_t u32Divider;
;;;1135       uint32_t u32BitRate, u32SrcClk, u32RetValue;
;;;1136   
;;;1137       /* Reset SPI/I2S */
;;;1138       if(i2s == SPI0)
000006  4a49              LDR      r2,|L7.300|
000008  461d              MOV      r5,r3                 ;1133
00000a  4604              MOV      r4,r0                 ;1133
00000c  e9dd8908          LDRD     r8,r9,[sp,#0x20]      ;1133
;;;1139       {
;;;1140           SYS->IPRST1 |= SYS_IPRST1_SPI0RST_Msk;
;;;1141           SYS->IPRST1 &= ~SYS_IPRST1_SPI0RST_Msk;
;;;1142       }
;;;1143       else if(i2s == SPI1)
000010  4b47              LDR      r3,|L7.304|
;;;1144       {
;;;1145           SYS->IPRST1 |= SYS_IPRST1_SPI1RST_Msk;
;;;1146           SYS->IPRST1 &= ~SYS_IPRST1_SPI1RST_Msk;
;;;1147       }
;;;1148       else if(i2s == SPI2)
000012  f8dfc120          LDR      r12,|L7.308|
000016  0490              LSLS     r0,r2,#18             ;1140
000018  4294              CMP      r4,r2                 ;1138
00001a  d107              BNE      |L7.44|
00001c  68c6              LDR      r6,[r0,#0xc]          ;1140
00001e  f4465600          ORR      r6,r6,#0x2000         ;1140
000022  60c6              STR      r6,[r0,#0xc]          ;1140
000024  68c6              LDR      r6,[r0,#0xc]          ;1141
000026  f4265600          BIC      r6,r6,#0x2000         ;1141
00002a  e012              B        |L7.82|
                  |L7.44|
00002c  429c              CMP      r4,r3                 ;1143
00002e  d107              BNE      |L7.64|
000030  68c6              LDR      r6,[r0,#0xc]          ;1145
000032  f4464680          ORR      r6,r6,#0x4000         ;1145
000036  60c6              STR      r6,[r0,#0xc]          ;1145
000038  68c6              LDR      r6,[r0,#0xc]          ;1146
00003a  f4264680          BIC      r6,r6,#0x4000         ;1146
00003e  e008              B        |L7.82|
                  |L7.64|
000040  4564              CMP      r4,r12
000042  d108              BNE      |L7.86|
;;;1149       {
;;;1150           SYS->IPRST1 |= SYS_IPRST1_SPI2RST_Msk;
000044  68c6              LDR      r6,[r0,#0xc]
000046  f4464600          ORR      r6,r6,#0x8000
00004a  60c6              STR      r6,[r0,#0xc]
;;;1151           SYS->IPRST1 &= ~SYS_IPRST1_SPI2RST_Msk;
00004c  68c6              LDR      r6,[r0,#0xc]
00004e  f4264600          BIC      r6,r6,#0x8000
                  |L7.82|
000052  60c6              STR      r6,[r0,#0xc]
000054  e007              B        |L7.102|
                  |L7.86|
;;;1152       }
;;;1153       else
;;;1154       {
;;;1155           SYS->IPRST2 |= SYS_IPRST2_SPI3RST_Msk;
000056  6906              LDR      r6,[r0,#0x10]
000058  f0460640          ORR      r6,r6,#0x40
00005c  6106              STR      r6,[r0,#0x10]
;;;1156           SYS->IPRST2 &= ~SYS_IPRST2_SPI3RST_Msk;
00005e  6906              LDR      r6,[r0,#0x10]
000060  f0260640          BIC      r6,r6,#0x40
000064  6106              STR      r6,[r0,#0x10]
                  |L7.102|
;;;1157       }
;;;1158   
;;;1159       /* Configure I2S controller */
;;;1160       i2s->I2SCTL = u32MasterSlave | u32WordWidth | u32Channels | u32DataFormat;
000066  ea410605          ORR      r6,r1,r5
00006a  ea460608          ORR      r6,r6,r8
00006e  ea460609          ORR      r6,r6,r9
000072  6626              STR      r6,[r4,#0x60]
;;;1161       /* Set TX FIFO threshold to 2 and RX FIFO threshold to 1 */
;;;1162       i2s->FIFOCTL = SPII2S_FIFO_TX_LEVEL_WORD_2 | SPII2S_FIFO_RX_LEVEL_WORD_2;
000074  f04f5604          MOV      r6,#0x21000000
000078  6126              STR      r6,[r4,#0x10]
;;;1163   
;;;1164       if(u32MasterSlave == SPI_MASTER)
;;;1165       {
;;;1166           /* Get the source clock rate */
;;;1167           u32SrcClk = SPII2S_GetSourceClockFreq(i2s);
;;;1168   
;;;1169           /* Calculate the bit clock rate */
;;;1170           u32BitRate = u32SampleRate * ((u32WordWidth >> SPI_I2SCTL_WDWIDTH_Pos) + 1U) * 16U;
;;;1171           u32Divider = ((u32SrcClk / u32BitRate) >> 1U) - 1U;
;;;1172           //u32Divider = ((((u32SrcClk * 10UL / u32BitRate) >> 1U) + 5UL) / 10UL) - 1U;
;;;1173           /* Set BCLKDIV setting */
;;;1174           i2s->I2SCLK = (i2s->I2SCLK & ~SPI_I2SCLK_BCLKDIV_Msk) | (u32Divider << SPI_I2SCLK_BCLKDIV_Pos);
00007a  4e2f              LDR      r6,|L7.312|
00007c  b159              CBZ      r1,|L7.150|
;;;1175   
;;;1176           /* Calculate bit clock rate */
;;;1177           u32BitRate = u32SrcClk / ((u32Divider + 1U) * 2U);
;;;1178           /* Calculate real sample rate */
;;;1179           u32SampleRate = u32BitRate / (((u32WordWidth >> SPI_I2SCTL_WDWIDTH_Pos) + 1U) * 16U);
;;;1180   
;;;1181           /* Enable TX function, RX function and I2S mode. */
;;;1182           i2s->I2SCTL |= (SPI_I2SCTL_RXEN_Msk | SPI_I2SCTL_TXEN_Msk | SPI_I2SCTL_I2SEN_Msk);
;;;1183   
;;;1184           /* Return the real sample rate */
;;;1185           u32RetValue = u32SampleRate;
;;;1186       }
;;;1187       else
;;;1188       {
;;;1189           /* Set BCLKDIV = 0 */
;;;1190           i2s->I2SCLK &= ~SPI_I2SCLK_BCLKDIV_Msk;
00007e  6e61              LDR      r1,[r4,#0x64]
000080  4031              ANDS     r1,r1,r6
000082  6661              STR      r1,[r4,#0x64]
;;;1191   
;;;1192           if(i2s == SPI0)
000084  4294              CMP      r4,r2
000086  d128              BNE      |L7.218|
;;;1193           {
;;;1194               /* Set the peripheral clock rate to equal APB clock rate */
;;;1195               CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI0SEL_Msk)) | CLK_CLKSEL2_SPI0SEL_PCLK1;
000088  f8d01218          LDR      r1,[r0,#0x218]
00008c  f0210130          BIC      r1,r1,#0x30
000090  f0410120          ORR      r1,r1,#0x20
;;;1196               /* Enable TX function, RX function and I2S mode. */
;;;1197               i2s->I2SCTL |= (SPI_I2SCTL_RXEN_Msk | SPI_I2SCTL_TXEN_Msk | SPI_I2SCTL_I2SEN_Msk);
;;;1198               /* Return slave peripheral clock rate */
;;;1199               u32RetValue = CLK_GetPCLK1Freq();
000094  e032              B        |L7.252|
                  |L7.150|
000096  4620              MOV      r0,r4                 ;1167
000098  f7fffffe          BL       SPII2S_GetSourceClockFreq
00009c  2101              MOVS     r1,#1                 ;1170
00009e  eb011115          ADD      r1,r1,r5,LSR #4       ;1170
0000a2  4379              MULS     r1,r7,r1              ;1170
0000a4  0109              LSLS     r1,r1,#4              ;1170
0000a6  fbb0f1f1          UDIV     r1,r0,r1              ;1171
0000aa  f04f32ff          MOV      r2,#0xffffffff        ;1171
0000ae  eb020151          ADD      r1,r2,r1,LSR #1       ;1171
0000b2  6e62              LDR      r2,[r4,#0x64]         ;1174
0000b4  4032              ANDS     r2,r2,r6              ;1174
0000b6  ea422201          ORR      r2,r2,r1,LSL #8       ;1174
0000ba  6662              STR      r2,[r4,#0x64]         ;1174
0000bc  0049              LSLS     r1,r1,#1              ;1177
0000be  1c89              ADDS     r1,r1,#2              ;1177
0000c0  fbb0f0f1          UDIV     r0,r0,r1              ;1177
0000c4  0929              LSRS     r1,r5,#4              ;1179
0000c6  0109              LSLS     r1,r1,#4              ;1179
0000c8  3110              ADDS     r1,r1,#0x10           ;1179
0000ca  fbb0f0f1          UDIV     r0,r0,r1              ;1179
0000ce  6e21              LDR      r1,[r4,#0x60]         ;1182
0000d0  f0410107          ORR      r1,r1,#7              ;1182
0000d4  6621              STR      r1,[r4,#0x60]         ;1182
;;;1200           }
;;;1201           else if(i2s == SPI1)
;;;1202           {
;;;1203               /* Set the peripheral clock rate to equal APB clock rate */
;;;1204               CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI1SEL_Msk)) | CLK_CLKSEL2_SPI1SEL_PCLK0;
;;;1205               /* Enable TX function, RX function and I2S mode. */
;;;1206               i2s->I2SCTL |= (SPI_I2SCTL_RXEN_Msk | SPI_I2SCTL_TXEN_Msk | SPI_I2SCTL_I2SEN_Msk);
;;;1207               /* Return slave peripheral clock rate */
;;;1208               u32RetValue = CLK_GetPCLK0Freq();
;;;1209           }
;;;1210           else if(i2s == SPI2)
;;;1211           {
;;;1212               /* Set the peripheral clock rate to equal APB clock rate */
;;;1213               CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI2SEL_Msk)) | CLK_CLKSEL2_SPI2SEL_PCLK1;
;;;1214               /* Enable TX function, RX function and I2S mode. */
;;;1215               i2s->I2SCTL |= (SPI_I2SCTL_RXEN_Msk | SPI_I2SCTL_TXEN_Msk | SPI_I2SCTL_I2SEN_Msk);
;;;1216               /* Return slave peripheral clock rate */
;;;1217               u32RetValue = CLK_GetPCLK1Freq();
;;;1218           }
;;;1219           else
;;;1220           {
;;;1221               /* Set the peripheral clock rate to equal APB clock rate */
;;;1222               CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI3SEL_Msk)) | CLK_CLKSEL2_SPI3SEL_PCLK0;
;;;1223               /* Enable TX function, RX function and I2S mode. */
;;;1224               i2s->I2SCTL |= (SPI_I2SCTL_RXEN_Msk | SPI_I2SCTL_TXEN_Msk | SPI_I2SCTL_I2SEN_Msk);
;;;1225               /* Return slave peripheral clock rate */
;;;1226               u32RetValue = CLK_GetPCLK0Freq();
;;;1227           }
;;;1228       }
;;;1229   
;;;1230       return u32RetValue;
;;;1231   }
0000d6  e8bd87f0          POP      {r4-r10,pc}
                  |L7.218|
0000da  429c              CMP      r4,r3                 ;1201
0000dc  d106              BNE      |L7.236|
0000de  f8d01218          LDR      r1,[r0,#0x218]        ;1204
0000e2  f02101c0          BIC      r1,r1,#0xc0           ;1204
0000e6  f0410180          ORR      r1,r1,#0x80           ;1204
0000ea  e015              B        |L7.280|
                  |L7.236|
0000ec  f8d01218          LDR      r1,[r0,#0x218]        ;1222
0000f0  4564              CMP      r4,r12                ;1210
0000f2  d10d              BNE      |L7.272|
0000f4  f4216140          BIC      r1,r1,#0xc00          ;1213
0000f8  f4416100          ORR      r1,r1,#0x800          ;1213
                  |L7.252|
0000fc  f8c01218          STR      r1,[r0,#0x218]        ;1213
000100  6e20              LDR      r0,[r4,#0x60]         ;1215
000102  f0400007          ORR      r0,r0,#7              ;1215
000106  6620              STR      r0,[r4,#0x60]         ;1215
000108  e8bd47f0          POP      {r4-r10,lr}           ;1217
00010c  f7ffbffe          B.W      CLK_GetPCLK1Freq
                  |L7.272|
000110  f4215140          BIC      r1,r1,#0x3000         ;1222
000114  f4415100          ORR      r1,r1,#0x2000         ;1222
                  |L7.280|
000118  f8c01218          STR      r1,[r0,#0x218]        ;1222
00011c  6e20              LDR      r0,[r4,#0x60]         ;1224
00011e  f0400007          ORR      r0,r0,#7              ;1224
000122  6620              STR      r0,[r4,#0x60]         ;1224
000124  e8bd47f0          POP      {r4-r10,lr}           ;1226
000128  f7ffbffe          B.W      CLK_GetPCLK0Freq
;;;1232   
                          ENDP

                  |L7.300|
                          DCD      0x40061000
                  |L7.304|
                          DCD      0x40062000
                  |L7.308|
                          DCD      0x40063000
                  |L7.312|
                          DCD      0xfffc00ff

                          AREA ||i.SPII2S_SetFIFO||, CODE, READONLY, ALIGN=1

                  SPII2S_SetFIFO PROC
;;;1428     */
;;;1429   void SPII2S_SetFIFO(SPI_T *i2s, uint32_t u32TxThreshold, uint32_t u32RxThreshold)
000000  6903              LDR      r3,[r0,#0x10]
;;;1430   {
;;;1431       i2s->FIFOCTL = (i2s->FIFOCTL & ~(SPI_FIFOCTL_TXTH_Msk | SPI_FIFOCTL_RXTH_Msk)) |
000002  f02343ee          BIC      r3,r3,#0x77000000
000006  ea437101          ORR      r1,r3,r1,LSL #28
00000a  ea416102          ORR      r1,r1,r2,LSL #24
00000e  6101              STR      r1,[r0,#0x10]
;;;1432                      (u32TxThreshold << SPI_FIFOCTL_TXTH_Pos) |
;;;1433                      (u32RxThreshold << SPI_FIFOCTL_RXTH_Pos);
;;;1434   }
000010  4770              BX       lr
;;;1435   
                          ENDP


                          AREA ||i.SPI_ClearIntFlag||, CODE, READONLY, ALIGN=1

                  SPI_ClearIntFlag PROC
;;;886      */
;;;887    void SPI_ClearIntFlag(SPI_T *spi, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;888    {
000002  d001              BEQ      |L9.8|
;;;889        if(u32Mask & SPI_UNIT_INT_MASK)
;;;890        {
;;;891            spi->STATUS = SPI_STATUS_UNITIF_Msk; /* Clear unit transfer interrupt flag */
000004  2202              MOVS     r2,#2
000006  6142              STR      r2,[r0,#0x14]
                  |L9.8|
;;;892        }
;;;893    
;;;894        if(u32Mask & SPI_SSACT_INT_MASK)
000008  078a              LSLS     r2,r1,#30
00000a  d501              BPL      |L9.16|
;;;895        {
;;;896            spi->STATUS = SPI_STATUS_SSACTIF_Msk; /* Clear slave selection signal active interrupt flag */
00000c  2204              MOVS     r2,#4
00000e  6142              STR      r2,[r0,#0x14]
                  |L9.16|
;;;897        }
;;;898    
;;;899        if(u32Mask & SPI_SSINACT_INT_MASK)
000010  074a              LSLS     r2,r1,#29
000012  d501              BPL      |L9.24|
;;;900        {
;;;901            spi->STATUS = SPI_STATUS_SSINAIF_Msk; /* Clear slave selection signal inactive interrupt flag */
000014  2208              MOVS     r2,#8
000016  6142              STR      r2,[r0,#0x14]
                  |L9.24|
;;;902        }
;;;903    
;;;904        if(u32Mask & SPI_SLVUR_INT_MASK)
000018  070a              LSLS     r2,r1,#28
00001a  d501              BPL      |L9.32|
;;;905        {
;;;906            spi->STATUS = SPI_STATUS_SLVURIF_Msk; /* Clear slave TX under run interrupt flag */
00001c  2280              MOVS     r2,#0x80
00001e  6142              STR      r2,[r0,#0x14]
                  |L9.32|
;;;907        }
;;;908    
;;;909        if(u32Mask & SPI_SLVBE_INT_MASK)
000020  06ca              LSLS     r2,r1,#27
000022  d501              BPL      |L9.40|
;;;910        {
;;;911            spi->STATUS = SPI_STATUS_SLVBEIF_Msk; /* Clear slave bit count error interrupt flag */
000024  2240              MOVS     r2,#0x40
000026  6142              STR      r2,[r0,#0x14]
                  |L9.40|
;;;912        }
;;;913    
;;;914        if(u32Mask & SPI_TXUF_INT_MASK)
000028  064a              LSLS     r2,r1,#25
00002a  d502              BPL      |L9.50|
;;;915        {
;;;916            spi->STATUS = SPI_STATUS_TXUFIF_Msk; /* Clear slave TX underflow interrupt flag */
00002c  f44f2200          MOV      r2,#0x80000
000030  6142              STR      r2,[r0,#0x14]
                  |L9.50|
;;;917        }
;;;918    
;;;919        if(u32Mask & SPI_FIFO_RXOV_INT_MASK)
000032  058a              LSLS     r2,r1,#22
000034  d502              BPL      |L9.60|
;;;920        {
;;;921            spi->STATUS = SPI_STATUS_RXOVIF_Msk; /* Clear RX overrun interrupt flag */
000036  f44f6200          MOV      r2,#0x800
00003a  6142              STR      r2,[r0,#0x14]
                  |L9.60|
;;;922        }
;;;923    
;;;924        if(u32Mask & SPI_FIFO_RXTO_INT_MASK)
00003c  0549              LSLS     r1,r1,#21
00003e  d502              BPL      |L9.70|
;;;925        {
;;;926            spi->STATUS = SPI_STATUS_RXTOIF_Msk; /* Clear RX time-out interrupt flag */
000040  f44f5180          MOV      r1,#0x1000
000044  6141              STR      r1,[r0,#0x14]
                  |L9.70|
;;;927        }
;;;928    }
000046  4770              BX       lr
;;;929    
                          ENDP


                          AREA ||i.SPI_ClearRxFIFO||, CODE, READONLY, ALIGN=1

                  SPI_ClearRxFIFO PROC
;;;291      */
;;;292    void SPI_ClearRxFIFO(SPI_T *spi)
000000  6901              LDR      r1,[r0,#0x10]
;;;293    {
;;;294        spi->FIFOCTL |= SPI_FIFOCTL_RXFBCLR_Msk;
000002  f4417180          ORR      r1,r1,#0x100
000006  6101              STR      r1,[r0,#0x10]
;;;295    }
000008  4770              BX       lr
;;;296    
                          ENDP


                          AREA ||i.SPI_ClearTxFIFO||, CODE, READONLY, ALIGN=1

                  SPI_ClearTxFIFO PROC
;;;303      */
;;;304    void SPI_ClearTxFIFO(SPI_T *spi)
000000  6901              LDR      r1,[r0,#0x10]
;;;305    {
;;;306        spi->FIFOCTL |= SPI_FIFOCTL_TXFBCLR_Msk;
000002  f4417100          ORR      r1,r1,#0x200
000006  6101              STR      r1,[r0,#0x10]
;;;307    }
000008  4770              BX       lr
;;;308    
                          ENDP


                          AREA ||i.SPI_Close||, CODE, READONLY, ALIGN=2

                  SPI_Close PROC
;;;257      */
;;;258    void SPI_Close(SPI_T *spi)
000000  4a15              LDR      r2,|L12.88|
;;;259    {
;;;260        if(spi == SPI0)
;;;261        {
;;;262            /* Reset SPI */
;;;263            SYS->IPRST1 |= SYS_IPRST1_SPI0RST_Msk;
000002  0491              LSLS     r1,r2,#18
000004  4290              CMP      r0,r2                 ;260
000006  d107              BNE      |L12.24|
000008  68c8              LDR      r0,[r1,#0xc]
00000a  f4405000          ORR      r0,r0,#0x2000
00000e  60c8              STR      r0,[r1,#0xc]
;;;264            SYS->IPRST1 &= ~SYS_IPRST1_SPI0RST_Msk;
000010  68c8              LDR      r0,[r1,#0xc]
000012  f4205000          BIC      r0,r0,#0x2000
000016  e009              B        |L12.44|
                  |L12.24|
;;;265        }
;;;266        else if(spi == SPI1)
000018  4a10              LDR      r2,|L12.92|
00001a  4290              CMP      r0,r2
00001c  d108              BNE      |L12.48|
;;;267        {
;;;268            /* Reset SPI */
;;;269            SYS->IPRST1 |= SYS_IPRST1_SPI1RST_Msk;
00001e  68c8              LDR      r0,[r1,#0xc]
000020  f4404080          ORR      r0,r0,#0x4000
000024  60c8              STR      r0,[r1,#0xc]
;;;270            SYS->IPRST1 &= ~SYS_IPRST1_SPI1RST_Msk;
000026  68c8              LDR      r0,[r1,#0xc]
000028  f4204080          BIC      r0,r0,#0x4000
                  |L12.44|
00002c  60c8              STR      r0,[r1,#0xc]          ;264
;;;271        }
;;;272        else if(spi == SPI2)
;;;273        {
;;;274            /* Reset SPI */
;;;275            SYS->IPRST1 |= SYS_IPRST1_SPI2RST_Msk;
;;;276            SYS->IPRST1 &= ~SYS_IPRST1_SPI2RST_Msk;
;;;277        }
;;;278        else
;;;279        {
;;;280            /* Reset SPI */
;;;281            SYS->IPRST2 |= SYS_IPRST2_SPI3RST_Msk;
;;;282            SYS->IPRST2 &= ~SYS_IPRST2_SPI3RST_Msk;
;;;283        }
;;;284    }
00002e  4770              BX       lr
                  |L12.48|
000030  4a0b              LDR      r2,|L12.96|
000032  4290              CMP      r0,r2                 ;272
000034  d107              BNE      |L12.70|
000036  68c8              LDR      r0,[r1,#0xc]          ;275
000038  f4404000          ORR      r0,r0,#0x8000         ;275
00003c  60c8              STR      r0,[r1,#0xc]          ;275
00003e  68c8              LDR      r0,[r1,#0xc]          ;276
000040  f4204000          BIC      r0,r0,#0x8000         ;276
000044  e7f2              B        |L12.44|
                  |L12.70|
000046  6908              LDR      r0,[r1,#0x10]         ;281
000048  f0400040          ORR      r0,r0,#0x40           ;281
00004c  6108              STR      r0,[r1,#0x10]         ;281
00004e  6908              LDR      r0,[r1,#0x10]         ;282
000050  f0200040          BIC      r0,r0,#0x40           ;282
000054  6108              STR      r0,[r1,#0x10]         ;282
000056  4770              BX       lr
;;;285    
                          ENDP

                  |L12.88|
                          DCD      0x40061000
                  |L12.92|
                          DCD      0x40062000
                  |L12.96|
                          DCD      0x40063000

                          AREA ||i.SPI_DisableAutoSS||, CODE, READONLY, ALIGN=1

                  SPI_DisableAutoSS PROC
;;;314      */
;;;315    void SPI_DisableAutoSS(SPI_T *spi)
000000  6881              LDR      r1,[r0,#8]
;;;316    {
;;;317        spi->SSCTL &= ~(SPI_SSCTL_AUTOSS_Msk | SPI_SSCTL_SS_Msk);
000002  f0210109          BIC      r1,r1,#9
000006  6081              STR      r1,[r0,#8]
;;;318    }
000008  4770              BX       lr
;;;319    
                          ENDP


                          AREA ||i.SPI_DisableInt||, CODE, READONLY, ALIGN=1

                  SPI_DisableInt PROC
;;;708      */
;;;709    void SPI_DisableInt(SPI_T *spi, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;710    {
000002  d003              BEQ      |L14.12|
;;;711        /* Disable unit transfer interrupt flag */
;;;712        if((u32Mask & SPI_UNIT_INT_MASK) == SPI_UNIT_INT_MASK)
;;;713        {
;;;714            spi->CTL &= ~SPI_CTL_UNITIEN_Msk;
000004  6802              LDR      r2,[r0,#0]
000006  f4223200          BIC      r2,r2,#0x20000
00000a  6002              STR      r2,[r0,#0]
                  |L14.12|
;;;715        }
;;;716    
;;;717        /* Disable slave selection signal active interrupt flag */
;;;718        if((u32Mask & SPI_SSACT_INT_MASK) == SPI_SSACT_INT_MASK)
00000c  078a              LSLS     r2,r1,#30
00000e  d503              BPL      |L14.24|
;;;719        {
;;;720            spi->SSCTL &= ~SPI_SSCTL_SSACTIEN_Msk;
000010  6882              LDR      r2,[r0,#8]
000012  f4225280          BIC      r2,r2,#0x1000
000016  6082              STR      r2,[r0,#8]
                  |L14.24|
;;;721        }
;;;722    
;;;723        /* Disable slave selection signal inactive interrupt flag */
;;;724        if((u32Mask & SPI_SSINACT_INT_MASK) == SPI_SSINACT_INT_MASK)
000018  074a              LSLS     r2,r1,#29
00001a  d503              BPL      |L14.36|
;;;725        {
;;;726            spi->SSCTL &= ~SPI_SSCTL_SSINAIEN_Msk;
00001c  6882              LDR      r2,[r0,#8]
00001e  f4225200          BIC      r2,r2,#0x2000
000022  6082              STR      r2,[r0,#8]
                  |L14.36|
;;;727        }
;;;728    
;;;729        /* Disable slave TX under run interrupt flag */
;;;730        if((u32Mask & SPI_SLVUR_INT_MASK) == SPI_SLVUR_INT_MASK)
000024  070a              LSLS     r2,r1,#28
000026  d503              BPL      |L14.48|
;;;731        {
;;;732            spi->SSCTL &= ~SPI_SSCTL_SLVURIEN_Msk;
000028  6882              LDR      r2,[r0,#8]
00002a  f4227200          BIC      r2,r2,#0x200
00002e  6082              STR      r2,[r0,#8]
                  |L14.48|
;;;733        }
;;;734    
;;;735        /* Disable slave bit count error interrupt flag */
;;;736        if((u32Mask & SPI_SLVBE_INT_MASK) == SPI_SLVBE_INT_MASK)
000030  06ca              LSLS     r2,r1,#27
000032  d503              BPL      |L14.60|
;;;737        {
;;;738            spi->SSCTL &= ~SPI_SSCTL_SLVBEIEN_Msk;
000034  6882              LDR      r2,[r0,#8]
000036  f4227280          BIC      r2,r2,#0x100
00003a  6082              STR      r2,[r0,#8]
                  |L14.60|
;;;739        }
;;;740    
;;;741        /* Disable slave TX underflow interrupt flag */
;;;742        if((u32Mask & SPI_TXUF_INT_MASK) == SPI_TXUF_INT_MASK)
00003c  064a              LSLS     r2,r1,#25
00003e  d503              BPL      |L14.72|
;;;743        {
;;;744            spi->FIFOCTL &= ~SPI_FIFOCTL_TXUFIEN_Msk;
000040  6902              LDR      r2,[r0,#0x10]
000042  f0220280          BIC      r2,r2,#0x80
000046  6102              STR      r2,[r0,#0x10]
                  |L14.72|
;;;745        }
;;;746    
;;;747        /* Disable TX threshold interrupt flag */
;;;748        if((u32Mask & SPI_FIFO_TXTH_INT_MASK) == SPI_FIFO_TXTH_INT_MASK)
000048  060a              LSLS     r2,r1,#24
00004a  d503              BPL      |L14.84|
;;;749        {
;;;750            spi->FIFOCTL &= ~SPI_FIFOCTL_TXTHIEN_Msk;
00004c  6902              LDR      r2,[r0,#0x10]
00004e  f0220208          BIC      r2,r2,#8
000052  6102              STR      r2,[r0,#0x10]
                  |L14.84|
;;;751        }
;;;752    
;;;753        /* Disable RX threshold interrupt flag */
;;;754        if((u32Mask & SPI_FIFO_RXTH_INT_MASK) == SPI_FIFO_RXTH_INT_MASK)
000054  05ca              LSLS     r2,r1,#23
000056  d503              BPL      |L14.96|
;;;755        {
;;;756            spi->FIFOCTL &= ~SPI_FIFOCTL_RXTHIEN_Msk;
000058  6902              LDR      r2,[r0,#0x10]
00005a  f0220204          BIC      r2,r2,#4
00005e  6102              STR      r2,[r0,#0x10]
                  |L14.96|
;;;757        }
;;;758    
;;;759        /* Disable RX overrun interrupt flag */
;;;760        if((u32Mask & SPI_FIFO_RXOV_INT_MASK) == SPI_FIFO_RXOV_INT_MASK)
000060  058a              LSLS     r2,r1,#22
000062  d503              BPL      |L14.108|
;;;761        {
;;;762            spi->FIFOCTL &= ~SPI_FIFOCTL_RXOVIEN_Msk;
000064  6902              LDR      r2,[r0,#0x10]
000066  f0220220          BIC      r2,r2,#0x20
00006a  6102              STR      r2,[r0,#0x10]
                  |L14.108|
;;;763        }
;;;764    
;;;765        /* Disable RX time-out interrupt flag */
;;;766        if((u32Mask & SPI_FIFO_RXTO_INT_MASK) == SPI_FIFO_RXTO_INT_MASK)
00006c  0549              LSLS     r1,r1,#21
00006e  d503              BPL      |L14.120|
;;;767        {
;;;768            spi->FIFOCTL &= ~SPI_FIFOCTL_RXTOIEN_Msk;
000070  6901              LDR      r1,[r0,#0x10]
000072  f0210110          BIC      r1,r1,#0x10
000076  6101              STR      r1,[r0,#0x10]
                  |L14.120|
;;;769        }
;;;770    }
000078  4770              BX       lr
;;;771    
                          ENDP


                          AREA ||i.SPI_EnableAutoSS||, CODE, READONLY, ALIGN=1

                  SPI_EnableAutoSS PROC
;;;328      */
;;;329    void SPI_EnableAutoSS(SPI_T *spi, uint32_t u32SSPinMask, uint32_t u32ActiveLevel)
000000  6883              LDR      r3,[r0,#8]
;;;330    {
;;;331        spi->SSCTL = (spi->SSCTL & (~(SPI_SSCTL_AUTOSS_Msk | SPI_SSCTL_SSACTPOL_Msk | SPI_SSCTL_SS_Msk))) | (u32SSPinMask | u32ActiveLevel | SPI_SSCTL_AUTOSS_Msk);
000002  4311              ORRS     r1,r1,r2
000004  f023030d          BIC      r3,r3,#0xd
000008  430b              ORRS     r3,r3,r1
00000a  f0430108          ORR      r1,r3,#8
00000e  6081              STR      r1,[r0,#8]
;;;332    }
000010  4770              BX       lr
;;;333    
                          ENDP


                          AREA ||i.SPI_EnableInt||, CODE, READONLY, ALIGN=1

                  SPI_EnableInt PROC
;;;625      */
;;;626    void SPI_EnableInt(SPI_T *spi, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;627    {
000002  d003              BEQ      |L16.12|
;;;628        /* Enable unit transfer interrupt flag */
;;;629        if((u32Mask & SPI_UNIT_INT_MASK) == SPI_UNIT_INT_MASK)
;;;630        {
;;;631            spi->CTL |= SPI_CTL_UNITIEN_Msk;
000004  6802              LDR      r2,[r0,#0]
000006  f4423200          ORR      r2,r2,#0x20000
00000a  6002              STR      r2,[r0,#0]
                  |L16.12|
;;;632        }
;;;633    
;;;634        /* Enable slave selection signal active interrupt flag */
;;;635        if((u32Mask & SPI_SSACT_INT_MASK) == SPI_SSACT_INT_MASK)
00000c  078a              LSLS     r2,r1,#30
00000e  d503              BPL      |L16.24|
;;;636        {
;;;637            spi->SSCTL |= SPI_SSCTL_SSACTIEN_Msk;
000010  6882              LDR      r2,[r0,#8]
000012  f4425280          ORR      r2,r2,#0x1000
000016  6082              STR      r2,[r0,#8]
                  |L16.24|
;;;638        }
;;;639    
;;;640        /* Enable slave selection signal inactive interrupt flag */
;;;641        if((u32Mask & SPI_SSINACT_INT_MASK) == SPI_SSINACT_INT_MASK)
000018  074a              LSLS     r2,r1,#29
00001a  d503              BPL      |L16.36|
;;;642        {
;;;643            spi->SSCTL |= SPI_SSCTL_SSINAIEN_Msk;
00001c  6882              LDR      r2,[r0,#8]
00001e  f4425200          ORR      r2,r2,#0x2000
000022  6082              STR      r2,[r0,#8]
                  |L16.36|
;;;644        }
;;;645    
;;;646        /* Enable slave TX under run interrupt flag */
;;;647        if((u32Mask & SPI_SLVUR_INT_MASK) == SPI_SLVUR_INT_MASK)
000024  070a              LSLS     r2,r1,#28
000026  d503              BPL      |L16.48|
;;;648        {
;;;649            spi->SSCTL |= SPI_SSCTL_SLVURIEN_Msk;
000028  6882              LDR      r2,[r0,#8]
00002a  f4427200          ORR      r2,r2,#0x200
00002e  6082              STR      r2,[r0,#8]
                  |L16.48|
;;;650        }
;;;651    
;;;652        /* Enable slave bit count error interrupt flag */
;;;653        if((u32Mask & SPI_SLVBE_INT_MASK) == SPI_SLVBE_INT_MASK)
000030  06ca              LSLS     r2,r1,#27
000032  d503              BPL      |L16.60|
;;;654        {
;;;655            spi->SSCTL |= SPI_SSCTL_SLVBEIEN_Msk;
000034  6882              LDR      r2,[r0,#8]
000036  f4427280          ORR      r2,r2,#0x100
00003a  6082              STR      r2,[r0,#8]
                  |L16.60|
;;;656        }
;;;657    
;;;658        /* Enable slave TX underflow interrupt flag */
;;;659        if((u32Mask & SPI_TXUF_INT_MASK) == SPI_TXUF_INT_MASK)
00003c  064a              LSLS     r2,r1,#25
00003e  d503              BPL      |L16.72|
;;;660        {
;;;661            spi->FIFOCTL |= SPI_FIFOCTL_TXUFIEN_Msk;
000040  6902              LDR      r2,[r0,#0x10]
000042  f0420280          ORR      r2,r2,#0x80
000046  6102              STR      r2,[r0,#0x10]
                  |L16.72|
;;;662        }
;;;663    
;;;664        /* Enable TX threshold interrupt flag */
;;;665        if((u32Mask & SPI_FIFO_TXTH_INT_MASK) == SPI_FIFO_TXTH_INT_MASK)
000048  060a              LSLS     r2,r1,#24
00004a  d503              BPL      |L16.84|
;;;666        {
;;;667            spi->FIFOCTL |= SPI_FIFOCTL_TXTHIEN_Msk;
00004c  6902              LDR      r2,[r0,#0x10]
00004e  f0420208          ORR      r2,r2,#8
000052  6102              STR      r2,[r0,#0x10]
                  |L16.84|
;;;668        }
;;;669    
;;;670        /* Enable RX threshold interrupt flag */
;;;671        if((u32Mask & SPI_FIFO_RXTH_INT_MASK) == SPI_FIFO_RXTH_INT_MASK)
000054  05ca              LSLS     r2,r1,#23
000056  d503              BPL      |L16.96|
;;;672        {
;;;673            spi->FIFOCTL |= SPI_FIFOCTL_RXTHIEN_Msk;
000058  6902              LDR      r2,[r0,#0x10]
00005a  f0420204          ORR      r2,r2,#4
00005e  6102              STR      r2,[r0,#0x10]
                  |L16.96|
;;;674        }
;;;675    
;;;676        /* Enable RX overrun interrupt flag */
;;;677        if((u32Mask & SPI_FIFO_RXOV_INT_MASK) == SPI_FIFO_RXOV_INT_MASK)
000060  058a              LSLS     r2,r1,#22
000062  d503              BPL      |L16.108|
;;;678        {
;;;679            spi->FIFOCTL |= SPI_FIFOCTL_RXOVIEN_Msk;
000064  6902              LDR      r2,[r0,#0x10]
000066  f0420220          ORR      r2,r2,#0x20
00006a  6102              STR      r2,[r0,#0x10]
                  |L16.108|
;;;680        }
;;;681    
;;;682        /* Enable RX time-out interrupt flag */
;;;683        if((u32Mask & SPI_FIFO_RXTO_INT_MASK) == SPI_FIFO_RXTO_INT_MASK)
00006c  0549              LSLS     r1,r1,#21
00006e  d503              BPL      |L16.120|
;;;684        {
;;;685            spi->FIFOCTL |= SPI_FIFOCTL_RXTOIEN_Msk;
000070  6901              LDR      r1,[r0,#0x10]
000072  f0410110          ORR      r1,r1,#0x10
000076  6101              STR      r1,[r0,#0x10]
                  |L16.120|
;;;686        }
;;;687    }
000078  4770              BX       lr
;;;688    
                          ENDP


                          AREA ||i.SPI_GetBusClock||, CODE, READONLY, ALIGN=2

                  SPI_GetBusClock PROC
;;;511      */
;;;512    uint32_t SPI_GetBusClock(SPI_T *spi)
000000  b510              PUSH     {r4,lr}
;;;513    {
;;;514        uint32_t u32Div;
;;;515        uint32_t u32ClkSrc;
;;;516    
;;;517        /* Get DIVIDER setting */
;;;518        u32Div = (spi->CLKDIV & SPI_CLKDIV_DIVIDER_Msk) >> SPI_CLKDIV_DIVIDER_Pos;
000002  6841              LDR      r1,[r0,#4]
;;;519    
;;;520        /* Check clock source of SPI */
;;;521        if(spi == SPI0)
000004  4b2d              LDR      r3,|L17.188|
000006  f3c10408          UBFX     r4,r1,#0,#9           ;518
;;;522        {
;;;523            if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_HXT)
;;;524            {
;;;525                u32ClkSrc = __HXT; /* Clock source is HXT */
00000a  492d              LDR      r1,|L17.192|
00000c  049a              LSLS     r2,r3,#18             ;523
00000e  4298              CMP      r0,r3                 ;521
000010  d10f              BNE      |L17.50|
000012  f8d20218          LDR      r0,[r2,#0x218]        ;523
000016  f0100f30          TST      r0,#0x30              ;523
00001a  d043              BEQ      |L17.164|
;;;526            }
;;;527            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_PLL)
00001c  f8d20218          LDR      r0,[r2,#0x218]
000020  f3c01001          UBFX     r0,r0,#4,#2
000024  2801              CMP      r0,#1
000026  d042              BEQ      |L17.174|
;;;528            {
;;;529                u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;530            }
;;;531            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_PCLK1)
000028  f8d20218          LDR      r0,[r2,#0x218]
00002c  f3c01001          UBFX     r0,r0,#4,#2
000030  e024              B        |L17.124|
                  |L17.50|
;;;532            {
;;;533                /* Clock source is PCLK1 */
;;;534                u32ClkSrc = CLK_GetPCLK1Freq();
;;;535            }
;;;536            else
;;;537            {
;;;538                u32ClkSrc = __HIRC; /* Clock source is HIRC */
;;;539            }
;;;540        }
;;;541        else if(spi == SPI1)
000032  4b24              LDR      r3,|L17.196|
000034  4298              CMP      r0,r3
000036  d10f              BNE      |L17.88|
;;;542        {
;;;543            if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI1SEL_Msk) == CLK_CLKSEL2_SPI1SEL_HXT)
000038  f8d20218          LDR      r0,[r2,#0x218]
00003c  f0100fc0          TST      r0,#0xc0
000040  d030              BEQ      |L17.164|
;;;544            {
;;;545                u32ClkSrc = __HXT; /* Clock source is HXT */
;;;546            }
;;;547            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI1SEL_Msk) == CLK_CLKSEL2_SPI1SEL_PLL)
000042  f8d20218          LDR      r0,[r2,#0x218]
000046  f3c01081          UBFX     r0,r0,#6,#2
00004a  2801              CMP      r0,#1
00004c  d02f              BEQ      |L17.174|
;;;548            {
;;;549                u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;550            }
;;;551            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI1SEL_Msk) == CLK_CLKSEL2_SPI1SEL_PCLK0)
00004e  f8d20218          LDR      r0,[r2,#0x218]
000052  f3c01081          UBFX     r0,r0,#6,#2
000056  e023              B        |L17.160|
                  |L17.88|
;;;552            {
;;;553                /* Clock source is PCLK0 */
;;;554                u32ClkSrc = CLK_GetPCLK0Freq();
;;;555            }
;;;556            else
;;;557            {
;;;558                u32ClkSrc = __HIRC; /* Clock source is HIRC */
;;;559            }
;;;560        }
;;;561        else if(spi == SPI2)
000058  4b1b              LDR      r3,|L17.200|
00005a  4298              CMP      r0,r3
;;;562        {
;;;563            if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI2SEL_Msk) == CLK_CLKSEL2_SPI2SEL_HXT)
;;;564            {
;;;565                u32ClkSrc = __HXT; /* Clock source is HXT */
;;;566            }
;;;567            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI2SEL_Msk) == CLK_CLKSEL2_SPI2SEL_PLL)
;;;568            {
;;;569                u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;570            }
;;;571            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI2SEL_Msk) == CLK_CLKSEL2_SPI2SEL_PCLK1)
;;;572            {
;;;573                /* Clock source is PCLK1 */
;;;574                u32ClkSrc = CLK_GetPCLK1Freq();
;;;575            }
;;;576            else
;;;577            {
;;;578                u32ClkSrc = __HIRC; /* Clock source is HIRC */
;;;579            }
;;;580        }
;;;581        else
;;;582        {
;;;583            if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI3SEL_Msk) == CLK_CLKSEL2_SPI3SEL_HXT)
00005c  f8d20218          LDR      r0,[r2,#0x218]
000060  d111              BNE      |L17.134|
000062  f4106f40          TST      r0,#0xc00             ;563
000066  d01d              BEQ      |L17.164|
000068  f8d20218          LDR      r0,[r2,#0x218]        ;567
00006c  f3c02081          UBFX     r0,r0,#10,#2          ;567
000070  2801              CMP      r0,#1                 ;567
000072  d01c              BEQ      |L17.174|
000074  f8d20218          LDR      r0,[r2,#0x218]        ;571
000078  f3c02081          UBFX     r0,r0,#10,#2          ;571
                  |L17.124|
00007c  2802              CMP      r0,#2                 ;531
00007e  d111              BNE      |L17.164|
000080  f7fffffe          BL       CLK_GetPCLK1Freq
000084  e00f              B        |L17.166|
                  |L17.134|
000086  f4105f40          TST      r0,#0x3000
00008a  d00b              BEQ      |L17.164|
;;;584            {
;;;585                u32ClkSrc = __HXT; /* Clock source is HXT */
;;;586            }
;;;587            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI3SEL_Msk) == CLK_CLKSEL2_SPI3SEL_PLL)
00008c  f8d20218          LDR      r0,[r2,#0x218]
000090  f3c03001          UBFX     r0,r0,#12,#2
000094  2801              CMP      r0,#1
000096  d00a              BEQ      |L17.174|
;;;588            {
;;;589                u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;590            }
;;;591            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI3SEL_Msk) == CLK_CLKSEL2_SPI3SEL_PCLK0)
000098  f8d20218          LDR      r0,[r2,#0x218]
00009c  f3c03001          UBFX     r0,r0,#12,#2
                  |L17.160|
0000a0  2802              CMP      r0,#2                 ;551
0000a2  d007              BEQ      |L17.180|
                  |L17.164|
;;;592            {
;;;593                /* Clock source is PCLK0 */
;;;594                u32ClkSrc = CLK_GetPCLK0Freq();
;;;595            }
;;;596            else
;;;597            {
;;;598                u32ClkSrc = __HIRC; /* Clock source is HIRC */
0000a4  4608              MOV      r0,r1
                  |L17.166|
0000a6  1c64              ADDS     r4,r4,#1
;;;599            }
;;;600        }
;;;601    
;;;602        /* Return SPI bus clock rate */
;;;603        return (u32ClkSrc / (u32Div + 1U));
0000a8  fbb0f0f4          UDIV     r0,r0,r4
;;;604    }
0000ac  bd10              POP      {r4,pc}
                  |L17.174|
0000ae  f7fffffe          BL       CLK_GetPLLClockFreq
0000b2  e7f8              B        |L17.166|
                  |L17.180|
0000b4  f7fffffe          BL       CLK_GetPCLK0Freq
0000b8  e7f5              B        |L17.166|
;;;605    
                          ENDP

0000ba  0000              DCW      0x0000
                  |L17.188|
                          DCD      0x40061000
                  |L17.192|
                          DCD      0x00b71b00
                  |L17.196|
                          DCD      0x40062000
                  |L17.200|
                          DCD      0x40063000

                          AREA ||i.SPI_GetIntFlag||, CODE, READONLY, ALIGN=1

                  SPI_GetIntFlag PROC
;;;791      */
;;;792    uint32_t SPI_GetIntFlag(SPI_T *spi, uint32_t u32Mask)
000000  b510              PUSH     {r4,lr}
;;;793    {
000002  4602              MOV      r2,r0
;;;794        uint32_t u32IntFlag = 0U, u32TmpVal;
000004  2000              MOVS     r0,#0
;;;795    
;;;796        u32TmpVal = spi->STATUS & SPI_STATUS_UNITIF_Msk;
000006  6953              LDR      r3,[r2,#0x14]
;;;797        /* Check unit transfer interrupt flag */
;;;798        if((u32Mask & SPI_UNIT_INT_MASK) && (u32TmpVal))
000008  07cc              LSLS     r4,r1,#31
00000a  f0030302          AND      r3,r3,#2              ;796
00000e  d001              BEQ      |L18.20|
000010  b103              CBZ      r3,|L18.20|
;;;799        {
;;;800            u32IntFlag |= SPI_UNIT_INT_MASK;
000012  2001              MOVS     r0,#1
                  |L18.20|
;;;801        }
;;;802    
;;;803        u32TmpVal = spi->STATUS & SPI_STATUS_SSACTIF_Msk;
000014  6953              LDR      r3,[r2,#0x14]
;;;804        /* Check slave selection signal active interrupt flag */
;;;805        if((u32Mask & SPI_SSACT_INT_MASK) && (u32TmpVal))
000016  078c              LSLS     r4,r1,#30
000018  f0030304          AND      r3,r3,#4              ;803
00001c  d502              BPL      |L18.36|
00001e  b10b              CBZ      r3,|L18.36|
;;;806        {
;;;807            u32IntFlag |= SPI_SSACT_INT_MASK;
000020  f0400002          ORR      r0,r0,#2
                  |L18.36|
;;;808        }
;;;809    
;;;810        u32TmpVal = spi->STATUS & SPI_STATUS_SSINAIF_Msk;
000024  6953              LDR      r3,[r2,#0x14]
;;;811        /* Check slave selection signal inactive interrupt flag */
;;;812        if((u32Mask & SPI_SSINACT_INT_MASK) && (u32TmpVal))
000026  074c              LSLS     r4,r1,#29
000028  f0030308          AND      r3,r3,#8              ;810
00002c  d502              BPL      |L18.52|
00002e  b10b              CBZ      r3,|L18.52|
;;;813        {
;;;814            u32IntFlag |= SPI_SSINACT_INT_MASK;
000030  f0400004          ORR      r0,r0,#4
                  |L18.52|
;;;815        }
;;;816    
;;;817        u32TmpVal = spi->STATUS & SPI_STATUS_SLVURIF_Msk;
000034  6953              LDR      r3,[r2,#0x14]
;;;818        /* Check slave TX under run interrupt flag */
;;;819        if((u32Mask & SPI_SLVUR_INT_MASK) && (u32TmpVal))
000036  070c              LSLS     r4,r1,#28
000038  f0030380          AND      r3,r3,#0x80           ;817
00003c  d502              BPL      |L18.68|
00003e  b10b              CBZ      r3,|L18.68|
;;;820        {
;;;821            u32IntFlag |= SPI_SLVUR_INT_MASK;
000040  f0400008          ORR      r0,r0,#8
                  |L18.68|
;;;822        }
;;;823    
;;;824        u32TmpVal = spi->STATUS & SPI_STATUS_SLVBEIF_Msk;
000044  6953              LDR      r3,[r2,#0x14]
;;;825        /* Check slave bit count error interrupt flag */
;;;826        if((u32Mask & SPI_SLVBE_INT_MASK) && (u32TmpVal))
000046  06cc              LSLS     r4,r1,#27
000048  f0030340          AND      r3,r3,#0x40           ;824
00004c  d502              BPL      |L18.84|
00004e  b10b              CBZ      r3,|L18.84|
;;;827        {
;;;828            u32IntFlag |= SPI_SLVBE_INT_MASK;
000050  f0400010          ORR      r0,r0,#0x10
                  |L18.84|
;;;829        }
;;;830    
;;;831        u32TmpVal = spi->STATUS & SPI_STATUS_TXUFIF_Msk;
000054  6953              LDR      r3,[r2,#0x14]
;;;832        /* Check slave TX underflow interrupt flag */
;;;833        if((u32Mask & SPI_TXUF_INT_MASK) && (u32TmpVal))
000056  064c              LSLS     r4,r1,#25
000058  f4032300          AND      r3,r3,#0x80000        ;831
00005c  d502              BPL      |L18.100|
00005e  b10b              CBZ      r3,|L18.100|
;;;834        {
;;;835            u32IntFlag |= SPI_TXUF_INT_MASK;
000060  f0400040          ORR      r0,r0,#0x40
                  |L18.100|
;;;836        }
;;;837    
;;;838        u32TmpVal = spi->STATUS & SPI_STATUS_TXTHIF_Msk;
000064  6953              LDR      r3,[r2,#0x14]
;;;839        /* Check TX threshold interrupt flag */
;;;840        if((u32Mask & SPI_FIFO_TXTH_INT_MASK) && (u32TmpVal))
000066  060c              LSLS     r4,r1,#24
000068  f4032380          AND      r3,r3,#0x40000        ;838
00006c  d502              BPL      |L18.116|
00006e  b10b              CBZ      r3,|L18.116|
;;;841        {
;;;842            u32IntFlag |= SPI_FIFO_TXTH_INT_MASK;
000070  f0400080          ORR      r0,r0,#0x80
                  |L18.116|
;;;843        }
;;;844    
;;;845        u32TmpVal = spi->STATUS & SPI_STATUS_RXTHIF_Msk;
000074  6953              LDR      r3,[r2,#0x14]
;;;846        /* Check RX threshold interrupt flag */
;;;847        if((u32Mask & SPI_FIFO_RXTH_INT_MASK) && (u32TmpVal))
000076  05cc              LSLS     r4,r1,#23
000078  f4036380          AND      r3,r3,#0x400          ;845
00007c  d502              BPL      |L18.132|
00007e  b10b              CBZ      r3,|L18.132|
;;;848        {
;;;849            u32IntFlag |= SPI_FIFO_RXTH_INT_MASK;
000080  f4407080          ORR      r0,r0,#0x100
                  |L18.132|
;;;850        }
;;;851    
;;;852        u32TmpVal = spi->STATUS & SPI_STATUS_RXOVIF_Msk;
000084  6953              LDR      r3,[r2,#0x14]
;;;853        /* Check RX overrun interrupt flag */
;;;854        if((u32Mask & SPI_FIFO_RXOV_INT_MASK) && (u32TmpVal))
000086  058c              LSLS     r4,r1,#22
000088  f4036300          AND      r3,r3,#0x800          ;852
00008c  d502              BPL      |L18.148|
00008e  b10b              CBZ      r3,|L18.148|
;;;855        {
;;;856            u32IntFlag |= SPI_FIFO_RXOV_INT_MASK;
000090  f4407000          ORR      r0,r0,#0x200
                  |L18.148|
;;;857        }
;;;858    
;;;859        u32TmpVal = spi->STATUS & SPI_STATUS_RXTOIF_Msk;
000094  6952              LDR      r2,[r2,#0x14]
;;;860        /* Check RX time-out interrupt flag */
;;;861        if((u32Mask & SPI_FIFO_RXTO_INT_MASK) && (u32TmpVal))
000096  0549              LSLS     r1,r1,#21
000098  f4025280          AND      r2,r2,#0x1000         ;859
00009c  d503              BPL      |L18.166|
00009e  2a00              CMP      r2,#0
0000a0  d001              BEQ      |L18.166|
;;;862        {
;;;863            u32IntFlag |= SPI_FIFO_RXTO_INT_MASK;
0000a2  f4406080          ORR      r0,r0,#0x400
                  |L18.166|
;;;864        }
;;;865    
;;;866        return u32IntFlag;
;;;867    }
0000a6  bd10              POP      {r4,pc}
;;;868    
                          ENDP


                          AREA ||i.SPI_GetStatus||, CODE, READONLY, ALIGN=1

                  SPI_GetStatus PROC
;;;947      */
;;;948    uint32_t SPI_GetStatus(SPI_T *spi, uint32_t u32Mask)
000000  b510              PUSH     {r4,lr}
;;;949    {
000002  4602              MOV      r2,r0
;;;950        uint32_t u32Flag = 0U, u32TmpValue;
000004  2000              MOVS     r0,#0
;;;951    
;;;952        u32TmpValue = spi->STATUS & SPI_STATUS_BUSY_Msk;
000006  6953              LDR      r3,[r2,#0x14]
;;;953        /* Check busy status */
;;;954        if((u32Mask & SPI_BUSY_MASK) && (u32TmpValue))
000008  07cc              LSLS     r4,r1,#31
00000a  f0030301          AND      r3,r3,#1              ;952
00000e  d001              BEQ      |L19.20|
000010  b103              CBZ      r3,|L19.20|
;;;955        {
;;;956            u32Flag |= SPI_BUSY_MASK;
000012  2001              MOVS     r0,#1
                  |L19.20|
;;;957        }
;;;958    
;;;959        u32TmpValue = spi->STATUS & SPI_STATUS_RXEMPTY_Msk;
000014  6953              LDR      r3,[r2,#0x14]
;;;960        /* Check RX empty flag */
;;;961        if((u32Mask & SPI_RX_EMPTY_MASK) && (u32TmpValue))
000016  078c              LSLS     r4,r1,#30
000018  f4037380          AND      r3,r3,#0x100          ;959
00001c  d502              BPL      |L19.36|
00001e  b10b              CBZ      r3,|L19.36|
;;;962        {
;;;963            u32Flag |= SPI_RX_EMPTY_MASK;
000020  f0400002          ORR      r0,r0,#2
                  |L19.36|
;;;964        }
;;;965    
;;;966        u32TmpValue = spi->STATUS & SPI_STATUS_RXFULL_Msk;
000024  6953              LDR      r3,[r2,#0x14]
;;;967        /* Check RX full flag */
;;;968        if((u32Mask & SPI_RX_FULL_MASK) && (u32TmpValue))
000026  074c              LSLS     r4,r1,#29
000028  f4037300          AND      r3,r3,#0x200          ;966
00002c  d502              BPL      |L19.52|
00002e  b10b              CBZ      r3,|L19.52|
;;;969        {
;;;970            u32Flag |= SPI_RX_FULL_MASK;
000030  f0400004          ORR      r0,r0,#4
                  |L19.52|
;;;971        }
;;;972    
;;;973        u32TmpValue = spi->STATUS & SPI_STATUS_TXEMPTY_Msk;
000034  6953              LDR      r3,[r2,#0x14]
;;;974        /* Check TX empty flag */
;;;975        if((u32Mask & SPI_TX_EMPTY_MASK) && (u32TmpValue))
000036  070c              LSLS     r4,r1,#28
000038  f4033380          AND      r3,r3,#0x10000        ;973
00003c  d502              BPL      |L19.68|
00003e  b10b              CBZ      r3,|L19.68|
;;;976        {
;;;977            u32Flag |= SPI_TX_EMPTY_MASK;
000040  f0400008          ORR      r0,r0,#8
                  |L19.68|
;;;978        }
;;;979    
;;;980        u32TmpValue = spi->STATUS & SPI_STATUS_TXFULL_Msk;
000044  6953              LDR      r3,[r2,#0x14]
;;;981        /* Check TX full flag */
;;;982        if((u32Mask & SPI_TX_FULL_MASK) && (u32TmpValue))
000046  06cc              LSLS     r4,r1,#27
000048  f4033300          AND      r3,r3,#0x20000        ;980
00004c  d502              BPL      |L19.84|
00004e  b10b              CBZ      r3,|L19.84|
;;;983        {
;;;984            u32Flag |= SPI_TX_FULL_MASK;
000050  f0400010          ORR      r0,r0,#0x10
                  |L19.84|
;;;985        }
;;;986    
;;;987        u32TmpValue = spi->STATUS & SPI_STATUS_TXRXRST_Msk;
000054  6953              LDR      r3,[r2,#0x14]
;;;988        /* Check TX/RX reset flag */
;;;989        if((u32Mask & SPI_TXRX_RESET_MASK) && (u32TmpValue))
000056  068c              LSLS     r4,r1,#26
000058  f4030300          AND      r3,r3,#0x800000       ;987
00005c  d502              BPL      |L19.100|
00005e  b10b              CBZ      r3,|L19.100|
;;;990        {
;;;991            u32Flag |= SPI_TXRX_RESET_MASK;
000060  f0400020          ORR      r0,r0,#0x20
                  |L19.100|
;;;992        }
;;;993    
;;;994        u32TmpValue = spi->STATUS & SPI_STATUS_SPIENSTS_Msk;
000064  6953              LDR      r3,[r2,#0x14]
;;;995        /* Check SPIEN flag */
;;;996        if((u32Mask & SPI_SPIEN_STS_MASK) && (u32TmpValue))
000066  064c              LSLS     r4,r1,#25
000068  f4034300          AND      r3,r3,#0x8000         ;994
00006c  d502              BPL      |L19.116|
00006e  b10b              CBZ      r3,|L19.116|
;;;997        {
;;;998            u32Flag |= SPI_SPIEN_STS_MASK;
000070  f0400040          ORR      r0,r0,#0x40
                  |L19.116|
;;;999        }
;;;1000   
;;;1001       u32TmpValue = spi->STATUS & SPI_STATUS_SSLINE_Msk;
000074  6952              LDR      r2,[r2,#0x14]
;;;1002       /* Check SPIx_SS line status */
;;;1003       if((u32Mask & SPI_SSLINE_STS_MASK) && (u32TmpValue))
000076  0609              LSLS     r1,r1,#24
000078  f0020210          AND      r2,r2,#0x10           ;1001
00007c  d503              BPL      |L19.134|
00007e  2a00              CMP      r2,#0
000080  d001              BEQ      |L19.134|
;;;1004       {
;;;1005           u32Flag |= SPI_SSLINE_STS_MASK;
000082  f0400080          ORR      r0,r0,#0x80
                  |L19.134|
;;;1006       }
;;;1007   
;;;1008       return u32Flag;
;;;1009   }
000086  bd10              POP      {r4,pc}
;;;1010   
                          ENDP


                          AREA ||i.SPI_Open||, CODE, READONLY, ALIGN=2

                  SPI_Open PROC
;;;42       */
;;;43     uint32_t SPI_Open(SPI_T *spi,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;44                       uint32_t u32MasterSlave,
;;;45                       uint32_t u32SPIMode,
;;;46                       uint32_t u32DataWidth,
;;;47                       uint32_t u32BusClock)
;;;48     {
000004  4604              MOV      r4,r0
;;;49         uint32_t u32ClkSrc = 0U, u32Div, u32HCLKFreq, u32RetValue=0U;
;;;50     
;;;51         /* Disable I2S mode */
;;;52         spi->I2SCTL &= ~SPI_I2SCTL_I2SEN_Msk;
000006  9d08              LDR      r5,[sp,#0x20]
000008  6e00              LDR      r0,[r0,#0x60]
00000a  461f              MOV      r7,r3                 ;48
00000c  4692              MOV      r10,r2                ;48
00000e  4689              MOV      r9,r1                 ;48
000010  f0200001          BIC      r0,r0,#1
000014  6620              STR      r0,[r4,#0x60]
;;;53     
;;;54         if(u32DataWidth == 32U)
000016  2b20              CMP      r3,#0x20
000018  d100              BNE      |L20.28|
;;;55         {
;;;56             u32DataWidth = 0U;
00001a  2700              MOVS     r7,#0
                  |L20.28|
;;;57         }
;;;58     
;;;59         /* Get system clock frequency */
;;;60         u32HCLKFreq = CLK_GetHCLKFreq();
00001c  f7fffffe          BL       CLK_GetHCLKFreq
;;;61     
;;;62         if(u32MasterSlave == SPI_MASTER)
;;;63         {
;;;64             /* Default setting: slave selection signal is active low; disable automatic slave selection function. */
;;;65             spi->SSCTL = SPI_SS_ACTIVE_LOW;
;;;66     
;;;67             /* Default setting: MSB first, disable unit transfer interrupt, SP_CYCLE = 0. */
;;;68             spi->CTL = u32MasterSlave | (u32DataWidth << SPI_CTL_DWIDTH_Pos) | (u32SPIMode) | SPI_CTL_SPIEN_Msk;
;;;69     
;;;70             if(u32BusClock >= u32HCLKFreq)
;;;71             {
;;;72                 /* Select PCLK as the clock source of SPI */
;;;73                 if(spi == SPI0)
;;;74                 {
;;;75                     CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI0SEL_Msk)) | CLK_CLKSEL2_SPI0SEL_PCLK1;
;;;76                 }
;;;77                 else if(spi == SPI1)
000020  4a71              LDR      r2,|L20.488|
000022  f8dfc1c0          LDR      r12,|L20.484|
;;;78                 {
;;;79                     CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI1SEL_Msk)) | CLK_CLKSEL2_SPI1SEL_PCLK0;
;;;80                 }
;;;81                 else if(spi == SPI2)
000026  4b71              LDR      r3,|L20.492|
000028  0451              LSLS     r1,r2,#17             ;75
00002a  4606              MOV      r6,r0                 ;60
00002c  f04f0800          MOV      r8,#0                 ;60
000030  f1b90f00          CMP      r9,#0                 ;62
000034  d013              BEQ      |L20.94|
;;;82                 {
;;;83                     CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI2SEL_Msk)) | CLK_CLKSEL2_SPI2SEL_PCLK1;
;;;84                 }
;;;85                 else
;;;86                 {
;;;87                     CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI3SEL_Msk)) | CLK_CLKSEL2_SPI3SEL_PCLK0;
;;;88                 }
;;;89             }
;;;90     
;;;91             /* Check clock source of SPI */
;;;92             if(spi == SPI0)
;;;93             {
;;;94                 if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_HXT)
;;;95                 {
;;;96                     u32ClkSrc = __HXT; /* Clock source is HXT */
;;;97                 }
;;;98                 else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_PLL)
;;;99                 {
;;;100                    u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;101                }
;;;102                else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_PCLK1)
;;;103                {
;;;104                    /* Clock source is PCLK1 */
;;;105                    u32ClkSrc = CLK_GetPCLK1Freq();
;;;106                }
;;;107                else
;;;108                {
;;;109                    u32ClkSrc = __HIRC; /* Clock source is HIRC */
;;;110                }
;;;111            }
;;;112            else if(spi == SPI1)
;;;113            {
;;;114                if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI1SEL_Msk) == CLK_CLKSEL2_SPI1SEL_HXT)
;;;115                {
;;;116                    u32ClkSrc = __HXT; /* Clock source is HXT */
;;;117                }
;;;118                else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI1SEL_Msk) == CLK_CLKSEL2_SPI1SEL_PLL)
;;;119                {
;;;120                    u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;121                }
;;;122                else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI1SEL_Msk) == CLK_CLKSEL2_SPI1SEL_PCLK0)
;;;123                {
;;;124                    /* Clock source is PCLK0 */
;;;125                    u32ClkSrc = CLK_GetPCLK0Freq();
;;;126                }
;;;127                else
;;;128                {
;;;129                    u32ClkSrc = __HIRC; /* Clock source is HIRC */
;;;130                }
;;;131            }
;;;132            else if(spi == SPI2)
;;;133            {
;;;134                if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI2SEL_Msk) == CLK_CLKSEL2_SPI2SEL_HXT)
;;;135                {
;;;136                    u32ClkSrc = __HXT; /* Clock source is HXT */
;;;137                }
;;;138                else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI2SEL_Msk) == CLK_CLKSEL2_SPI2SEL_PLL)
;;;139                {
;;;140                    u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;141                }
;;;142                else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI2SEL_Msk) == CLK_CLKSEL2_SPI2SEL_PCLK1)
;;;143                {
;;;144                    u32ClkSrc = CLK_GetPCLK1Freq();
;;;145                }
;;;146                else
;;;147                {
;;;148                    u32ClkSrc = __HIRC; /* Clock source is HIRC */
;;;149                }
;;;150            }
;;;151            else
;;;152            {
;;;153                if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI3SEL_Msk) == CLK_CLKSEL2_SPI3SEL_HXT)
;;;154                {
;;;155                    u32ClkSrc = __HXT; /* Clock source is HXT */
;;;156                }
;;;157                else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI3SEL_Msk) == CLK_CLKSEL2_SPI3SEL_PLL)
;;;158                {
;;;159                    u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;160                }
;;;161                else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI3SEL_Msk) == CLK_CLKSEL2_SPI3SEL_PCLK0)
;;;162                {
;;;163                    /* Clock source is PCLK0 */
;;;164                    u32ClkSrc = CLK_GetPCLK0Freq();
;;;165                }
;;;166                else
;;;167                {
;;;168                    u32ClkSrc = __HIRC; /* Clock source is HIRC */
;;;169                }
;;;170            }
;;;171    
;;;172            if(u32BusClock >= u32HCLKFreq)
;;;173            {
;;;174                /* Set DIVIDER = 0 */
;;;175                spi->CLKDIV = 0U;
;;;176                /* Return master peripheral clock rate */
;;;177                u32RetValue = u32ClkSrc;
;;;178            }
;;;179            else if(u32BusClock >= u32ClkSrc)
;;;180            {
;;;181                /* Set DIVIDER = 0 */
;;;182                spi->CLKDIV = 0U;
;;;183                /* Return master peripheral clock rate */
;;;184                u32RetValue = u32ClkSrc;
;;;185            }
;;;186            else if(u32BusClock == 0U)
;;;187            {
;;;188                /* Set DIVIDER to the maximum value 0xFF. f_spi = f_spi_clk_src / (DIVIDER + 1) */
;;;189                spi->CLKDIV |= SPI_CLKDIV_DIVIDER_Msk;
;;;190                /* Return master peripheral clock rate */
;;;191                u32RetValue = (u32ClkSrc / (0xFFU + 1U));
;;;192            }
;;;193            else
;;;194            {
;;;195                u32Div = (((u32ClkSrc * 10U) / u32BusClock + 5U) / 10U) - 1U; /* Round to the nearest integer */
;;;196                if(u32Div > 0xFFU)
;;;197                {
;;;198                    u32Div = 0xFFU;
;;;199                    spi->CLKDIV |= SPI_CLKDIV_DIVIDER_Msk;
;;;200                    /* Return master peripheral clock rate */
;;;201                    u32RetValue = (u32ClkSrc / (0xFFU + 1U));
;;;202                }
;;;203                else
;;;204                {
;;;205                    spi->CLKDIV = (spi->CLKDIV & (~SPI_CLKDIV_DIVIDER_Msk)) | (u32Div << SPI_CLKDIV_DIVIDER_Pos);
;;;206                    /* Return master peripheral clock rate */
;;;207                    u32RetValue = (u32ClkSrc / (u32Div + 1U));
;;;208                }
;;;209            }
;;;210        }
;;;211        else     /* For slave mode, force the SPI peripheral clock rate to equal APB clock rate. */
;;;212        {
;;;213            /* Default setting: slave selection signal is low level active. */
;;;214            spi->SSCTL = SPI_SS_ACTIVE_LOW;
000036  f8c48008          STR      r8,[r4,#8]
;;;215    
;;;216            /* Default setting: MSB first, disable unit transfer interrupt, SP_CYCLE = 0. */
;;;217            spi->CTL = u32MasterSlave | (u32DataWidth << SPI_CTL_DWIDTH_Pos) | (u32SPIMode) | SPI_CTL_SPIEN_Msk;
00003a  ea492007          ORR      r0,r9,r7,LSL #8
00003e  ea40000a          ORR      r0,r0,r10
000042  f0400001          ORR      r0,r0,#1
000046  6020              STR      r0,[r4,#0]
;;;218    
;;;219            /* Set DIVIDER = 0 */
;;;220            spi->CLKDIV = 0U;
000048  f8c48004          STR      r8,[r4,#4]
;;;221    
;;;222            /* Select PCLK as the clock source of SPI */
;;;223            if(spi == SPI0)
00004c  4564              CMP      r4,r12
00004e  d17d              BNE      |L20.332|
;;;224            {
;;;225                CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI0SEL_Msk)) | CLK_CLKSEL2_SPI0SEL_PCLK1;
000050  f8d10218          LDR      r0,[r1,#0x218]
000054  f0200030          BIC      r0,r0,#0x30
000058  f0400020          ORR      r0,r0,#0x20
;;;226                /* Return slave peripheral clock rate */
;;;227                u32RetValue = CLK_GetPCLK1Freq();
00005c  e0b2              B        |L20.452|
                  |L20.94|
00005e  f8c48008          STR      r8,[r4,#8]            ;65
000062  ea482007          ORR      r0,r8,r7,LSL #8       ;68
000066  ea40000a          ORR      r0,r0,r10             ;68
00006a  f0400001          ORR      r0,r0,#1              ;68
00006e  6020              STR      r0,[r4,#0]            ;68
000070  42b5              CMP      r5,r6                 ;70
000072  d320              BCC      |L20.182|
000074  4564              CMP      r4,r12                ;73
000076  d106              BNE      |L20.134|
000078  f8d10218          LDR      r0,[r1,#0x218]        ;75
00007c  f0200030          BIC      r0,r0,#0x30           ;75
000080  f0400020          ORR      r0,r0,#0x20           ;75
000084  e015              B        |L20.178|
                  |L20.134|
000086  4294              CMP      r4,r2                 ;77
000088  d106              BNE      |L20.152|
00008a  f8d10218          LDR      r0,[r1,#0x218]        ;79
00008e  f02000c0          BIC      r0,r0,#0xc0           ;79
000092  f0400080          ORR      r0,r0,#0x80           ;79
000096  e00c              B        |L20.178|
                  |L20.152|
000098  f8d10218          LDR      r0,[r1,#0x218]        ;87
00009c  429c              CMP      r4,r3                 ;81
00009e  d104              BNE      |L20.170|
0000a0  f4206040          BIC      r0,r0,#0xc00          ;83
0000a4  f4406000          ORR      r0,r0,#0x800          ;83
0000a8  e003              B        |L20.178|
                  |L20.170|
0000aa  f4205040          BIC      r0,r0,#0x3000         ;87
0000ae  f4405000          ORR      r0,r0,#0x2000         ;87
                  |L20.178|
0000b2  f8c10218          STR      r0,[r1,#0x218]        ;83
                  |L20.182|
0000b6  484e              LDR      r0,|L20.496|
0000b8  4564              CMP      r4,r12                ;92
0000ba  d10f              BNE      |L20.220|
0000bc  f8d12218          LDR      r2,[r1,#0x218]        ;94
0000c0  f0120f30          TST      r2,#0x30              ;94
0000c4  d048              BEQ      |L20.344|
0000c6  f8d12218          LDR      r2,[r1,#0x218]        ;98
0000ca  f3c21201          UBFX     r2,r2,#4,#2           ;98
0000ce  2a01              CMP      r2,#1                 ;98
0000d0  d03d              BEQ      |L20.334|
0000d2  f8d11218          LDR      r1,[r1,#0x218]        ;102
0000d6  f3c11101          UBFX     r1,r1,#4,#2           ;102
0000da  e022              B        |L20.290|
                  |L20.220|
0000dc  4294              CMP      r4,r2                 ;112
0000de  d10f              BNE      |L20.256|
0000e0  f8d12218          LDR      r2,[r1,#0x218]        ;114
0000e4  f0120fc0          TST      r2,#0xc0              ;114
0000e8  d036              BEQ      |L20.344|
0000ea  f8d12218          LDR      r2,[r1,#0x218]        ;118
0000ee  f3c21281          UBFX     r2,r2,#6,#2           ;118
0000f2  2a01              CMP      r2,#1                 ;118
0000f4  d02b              BEQ      |L20.334|
0000f6  f8d11218          LDR      r1,[r1,#0x218]        ;122
0000fa  f3c11181          UBFX     r1,r1,#6,#2           ;122
0000fe  e022              B        |L20.326|
                  |L20.256|
000100  f8d12218          LDR      r2,[r1,#0x218]        ;153
000104  429c              CMP      r4,r3                 ;132
000106  d111              BNE      |L20.300|
000108  f4126f40          TST      r2,#0xc00             ;134
00010c  d024              BEQ      |L20.344|
00010e  f8d12218          LDR      r2,[r1,#0x218]        ;138
000112  f3c22281          UBFX     r2,r2,#10,#2          ;138
000116  2a01              CMP      r2,#1                 ;138
000118  d019              BEQ      |L20.334|
00011a  f8d11218          LDR      r1,[r1,#0x218]        ;142
00011e  f3c12181          UBFX     r1,r1,#10,#2          ;142
                  |L20.290|
000122  2902              CMP      r1,#2                 ;142
000124  d118              BNE      |L20.344|
000126  f7fffffe          BL       CLK_GetPCLK1Freq
00012a  e015              B        |L20.344|
                  |L20.300|
00012c  f4125f40          TST      r2,#0x3000            ;153
000130  d012              BEQ      |L20.344|
000132  f8d12218          LDR      r2,[r1,#0x218]        ;157
000136  f3c23201          UBFX     r2,r2,#12,#2          ;157
00013a  2a01              CMP      r2,#1                 ;157
00013c  d007              BEQ      |L20.334|
00013e  f8d11218          LDR      r1,[r1,#0x218]        ;161
000142  f3c13101          UBFX     r1,r1,#12,#2          ;161
                  |L20.326|
000146  2902              CMP      r1,#2                 ;161
000148  d004              BEQ      |L20.340|
00014a  e005              B        |L20.344|
                  |L20.332|
00014c  e029              B        |L20.418|
                  |L20.334|
00014e  f7fffffe          BL       CLK_GetPLLClockFreq
000152  e001              B        |L20.344|
                  |L20.340|
000154  f7fffffe          BL       CLK_GetPCLK0Freq
                  |L20.344|
000158  42b5              CMP      r5,r6                 ;172
00015a  d201              BCS      |L20.352|
00015c  4285              CMP      r5,r0                 ;179
00015e  d303              BCC      |L20.360|
                  |L20.352|
000160  f8c48004          STR      r8,[r4,#4]            ;175
                  |L20.356|
;;;228            }
;;;229            else if(spi == SPI1)
;;;230            {
;;;231                CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI1SEL_Msk)) | CLK_CLKSEL2_SPI1SEL_PCLK0;
;;;232                /* Return slave peripheral clock rate */
;;;233                u32RetValue = CLK_GetPCLK0Freq();
;;;234            }
;;;235            else if(spi == SPI2)
;;;236            {
;;;237                CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI2SEL_Msk)) | CLK_CLKSEL2_SPI2SEL_PCLK1;
;;;238                /* Return slave peripheral clock rate */
;;;239                u32RetValue = CLK_GetPCLK1Freq();
;;;240            }
;;;241            else
;;;242            {
;;;243                CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI3SEL_Msk)) | CLK_CLKSEL2_SPI3SEL_PCLK0;
;;;244                /* Return slave peripheral clock rate */
;;;245                u32RetValue = CLK_GetPCLK0Freq();
;;;246            }
;;;247        }
;;;248    
;;;249        return u32RetValue;
;;;250    }
000164  e8bd87f0          POP      {r4-r10,pc}
                  |L20.360|
000168  f24012ff          MOV      r2,#0x1ff             ;189
00016c  b15d              CBZ      r5,|L20.390|
00016e  eb000180          ADD      r1,r0,r0,LSL #2       ;195
000172  0049              LSLS     r1,r1,#1              ;195
000174  fbb1f1f5          UDIV     r1,r1,r5              ;195
000178  230a              MOVS     r3,#0xa               ;195
00017a  1d49              ADDS     r1,r1,#5              ;195
00017c  fbb1f1f3          UDIV     r1,r1,r3              ;195
000180  1e49              SUBS     r1,r1,#1              ;195
000182  29ff              CMP      r1,#0xff              ;196
000184  d904              BLS      |L20.400|
                  |L20.390|
000186  6861              LDR      r1,[r4,#4]            ;189
000188  4311              ORRS     r1,r1,r2              ;189
00018a  6061              STR      r1,[r4,#4]            ;189
00018c  0a00              LSRS     r0,r0,#8              ;191
00018e  e7e9              B        |L20.356|
                  |L20.400|
000190  6862              LDR      r2,[r4,#4]            ;205
000192  f36f0208          BFC      r2,#0,#9              ;205
000196  430a              ORRS     r2,r2,r1              ;205
000198  6062              STR      r2,[r4,#4]            ;205
00019a  1c49              ADDS     r1,r1,#1              ;205
00019c  fbb0f0f1          UDIV     r0,r0,r1              ;207
0001a0  e7e0              B        |L20.356|
                  |L20.418|
0001a2  4294              CMP      r4,r2                 ;229
0001a4  d106              BNE      |L20.436|
0001a6  f8d10218          LDR      r0,[r1,#0x218]        ;231
0001aa  f02000c0          BIC      r0,r0,#0xc0           ;231
0001ae  f0400080          ORR      r0,r0,#0x80           ;231
0001b2  e011              B        |L20.472|
                  |L20.436|
0001b4  f8d10218          LDR      r0,[r1,#0x218]        ;243
0001b8  429c              CMP      r4,r3                 ;235
0001ba  d109              BNE      |L20.464|
0001bc  f4206040          BIC      r0,r0,#0xc00          ;237
0001c0  f4406000          ORR      r0,r0,#0x800          ;237
                  |L20.452|
0001c4  f8c10218          STR      r0,[r1,#0x218]        ;237
0001c8  e8bd47f0          POP      {r4-r10,lr}           ;239
0001cc  f7ffbffe          B.W      CLK_GetPCLK1Freq
                  |L20.464|
0001d0  f4205040          BIC      r0,r0,#0x3000         ;243
0001d4  f4405000          ORR      r0,r0,#0x2000         ;243
                  |L20.472|
0001d8  f8c10218          STR      r0,[r1,#0x218]        ;243
0001dc  e8bd47f0          POP      {r4-r10,lr}           ;245
0001e0  f7ffbffe          B.W      CLK_GetPCLK0Freq
;;;251    
                          ENDP

                  |L20.484|
                          DCD      0x40061000
                  |L20.488|
                          DCD      0x40062000
                  |L20.492|
                          DCD      0x40063000
                  |L20.496|
                          DCD      0x00b71b00

                          AREA ||i.SPI_SetBusClock||, CODE, READONLY, ALIGN=2

                  SPI_SetBusClock PROC
;;;345      */
;;;346    uint32_t SPI_SetBusClock(SPI_T *spi, uint32_t u32BusClock)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;347    {
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
;;;348        uint32_t u32ClkSrc, u32HCLKFreq;
;;;349        uint32_t u32Div, u32RetValue;
;;;350    
;;;351        /* Get system clock frequency */
;;;352        u32HCLKFreq = CLK_GetHCLKFreq();
000008  f7fffffe          BL       CLK_GetHCLKFreq
;;;353    
;;;354        if(u32BusClock >= u32HCLKFreq)
;;;355        {
;;;356            /* Select PCLK as the clock source of SPI */
;;;357            if(spi == SPI0)
;;;358                CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI0SEL_Msk)) | CLK_CLKSEL2_SPI0SEL_PCLK1;
;;;359            else if(spi == SPI1)
00000c  4a4f              LDR      r2,|L21.332|
00000e  4606              MOV      r6,r0                 ;352
000010  4f4d              LDR      r7,|L21.328|
;;;360                CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI1SEL_Msk)) | CLK_CLKSEL2_SPI1SEL_PCLK0;
;;;361            else if(spi == SPI2)
000012  4b4f              LDR      r3,|L21.336|
000014  0451              LSLS     r1,r2,#17             ;358
000016  42b5              CMP      r5,r6                 ;354
000018  d320              BCC      |L21.92|
00001a  42bc              CMP      r4,r7                 ;357
00001c  d106              BNE      |L21.44|
00001e  f8d10218          LDR      r0,[r1,#0x218]        ;358
000022  f0200030          BIC      r0,r0,#0x30           ;358
000026  f0400020          ORR      r0,r0,#0x20           ;358
00002a  e015              B        |L21.88|
                  |L21.44|
00002c  4294              CMP      r4,r2                 ;359
00002e  d106              BNE      |L21.62|
000030  f8d10218          LDR      r0,[r1,#0x218]        ;360
000034  f02000c0          BIC      r0,r0,#0xc0           ;360
000038  f0400080          ORR      r0,r0,#0x80           ;360
00003c  e00c              B        |L21.88|
                  |L21.62|
;;;362                CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI2SEL_Msk)) | CLK_CLKSEL2_SPI2SEL_PCLK1;
;;;363            else
;;;364                CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI3SEL_Msk)) | CLK_CLKSEL2_SPI3SEL_PCLK0;
00003e  f8d10218          LDR      r0,[r1,#0x218]
000042  429c              CMP      r4,r3                 ;361
000044  d104              BNE      |L21.80|
000046  f4206040          BIC      r0,r0,#0xc00          ;362
00004a  f4406000          ORR      r0,r0,#0x800          ;362
00004e  e003              B        |L21.88|
                  |L21.80|
000050  f4205040          BIC      r0,r0,#0x3000
000054  f4405000          ORR      r0,r0,#0x2000
                  |L21.88|
000058  f8c10218          STR      r0,[r1,#0x218]        ;362
                  |L21.92|
;;;365        }
;;;366    
;;;367        /* Check clock source of SPI */
;;;368        if(spi == SPI0)
;;;369        {
;;;370            if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_HXT)
;;;371            {
;;;372                u32ClkSrc = __HXT; /* Clock source is HXT */
00005c  483d              LDR      r0,|L21.340|
00005e  42bc              CMP      r4,r7                 ;368
000060  d10f              BNE      |L21.130|
000062  f8d12218          LDR      r2,[r1,#0x218]        ;370
000066  f0120f30          TST      r2,#0x30              ;370
00006a  d047              BEQ      |L21.252|
;;;373            }
;;;374            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_PLL)
00006c  f8d12218          LDR      r2,[r1,#0x218]
000070  f3c21201          UBFX     r2,r2,#4,#2
000074  2a01              CMP      r2,#1
000076  d03c              BEQ      |L21.242|
;;;375            {
;;;376                u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;377            }
;;;378            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_PCLK1)
000078  f8d11218          LDR      r1,[r1,#0x218]
00007c  f3c11101          UBFX     r1,r1,#4,#2
000080  e022              B        |L21.200|
                  |L21.130|
;;;379            {
;;;380                /* Clock source is PCLK1 */
;;;381                u32ClkSrc = CLK_GetPCLK1Freq();
;;;382            }
;;;383            else
;;;384            {
;;;385                u32ClkSrc = __HIRC; /* Clock source is HIRC */
;;;386            }
;;;387        }
;;;388        else if(spi == SPI1)
000082  4294              CMP      r4,r2
000084  d10f              BNE      |L21.166|
;;;389        {
;;;390            if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI1SEL_Msk) == CLK_CLKSEL2_SPI1SEL_HXT)
000086  f8d12218          LDR      r2,[r1,#0x218]
00008a  f0120fc0          TST      r2,#0xc0
00008e  d035              BEQ      |L21.252|
;;;391            {
;;;392                u32ClkSrc = __HXT; /* Clock source is HXT */
;;;393            }
;;;394            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI1SEL_Msk) == CLK_CLKSEL2_SPI1SEL_PLL)
000090  f8d12218          LDR      r2,[r1,#0x218]
000094  f3c21281          UBFX     r2,r2,#6,#2
000098  2a01              CMP      r2,#1
00009a  d02a              BEQ      |L21.242|
;;;395            {
;;;396                u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;397            }
;;;398            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI1SEL_Msk) == CLK_CLKSEL2_SPI1SEL_PCLK0)
00009c  f8d11218          LDR      r1,[r1,#0x218]
0000a0  f3c11181          UBFX     r1,r1,#6,#2
0000a4  e022              B        |L21.236|
                  |L21.166|
;;;399            {
;;;400                /* Clock source is PCLK0 */
;;;401                u32ClkSrc = CLK_GetPCLK0Freq();
;;;402            }
;;;403            else
;;;404            {
;;;405                u32ClkSrc = __HIRC; /* Clock source is HIRC */
;;;406            }
;;;407        }
;;;408        else if(spi == SPI2)
;;;409        {
;;;410            if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI2SEL_Msk) == CLK_CLKSEL2_SPI2SEL_HXT)
;;;411            {
;;;412                u32ClkSrc = __HXT; /* Clock source is HXT */
;;;413            }
;;;414            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI2SEL_Msk) == CLK_CLKSEL2_SPI2SEL_PLL)
;;;415            {
;;;416                u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;417            }
;;;418            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI2SEL_Msk) == CLK_CLKSEL2_SPI2SEL_PCLK1)
;;;419            {
;;;420                /* Clock source is PCLK1 */
;;;421                u32ClkSrc = CLK_GetPCLK1Freq();
;;;422            }
;;;423            else
;;;424            {
;;;425                u32ClkSrc = __HIRC; /* Clock source is HIRC */
;;;426            }
;;;427        }
;;;428        else
;;;429        {
;;;430            if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI3SEL_Msk) == CLK_CLKSEL2_SPI3SEL_HXT)
0000a6  f8d12218          LDR      r2,[r1,#0x218]
0000aa  429c              CMP      r4,r3                 ;408
0000ac  d111              BNE      |L21.210|
0000ae  f4126f40          TST      r2,#0xc00             ;410
0000b2  d023              BEQ      |L21.252|
0000b4  f8d12218          LDR      r2,[r1,#0x218]        ;414
0000b8  f3c22281          UBFX     r2,r2,#10,#2          ;414
0000bc  2a01              CMP      r2,#1                 ;414
0000be  d018              BEQ      |L21.242|
0000c0  f8d11218          LDR      r1,[r1,#0x218]        ;418
0000c4  f3c12181          UBFX     r1,r1,#10,#2          ;418
                  |L21.200|
0000c8  2902              CMP      r1,#2                 ;418
0000ca  d117              BNE      |L21.252|
0000cc  f7fffffe          BL       CLK_GetPCLK1Freq
0000d0  e014              B        |L21.252|
                  |L21.210|
0000d2  f4125f40          TST      r2,#0x3000
0000d6  d011              BEQ      |L21.252|
;;;431            {
;;;432                u32ClkSrc = __HXT; /* Clock source is HXT */
;;;433            }
;;;434            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI3SEL_Msk) == CLK_CLKSEL2_SPI3SEL_PLL)
0000d8  f8d12218          LDR      r2,[r1,#0x218]
0000dc  f3c23201          UBFX     r2,r2,#12,#2
0000e0  2a01              CMP      r2,#1
0000e2  d006              BEQ      |L21.242|
;;;435            {
;;;436                u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;437            }
;;;438            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI3SEL_Msk) == CLK_CLKSEL2_SPI3SEL_PCLK0)
0000e4  f8d11218          LDR      r1,[r1,#0x218]
0000e8  f3c13101          UBFX     r1,r1,#12,#2
                  |L21.236|
0000ec  2902              CMP      r1,#2
0000ee  d003              BEQ      |L21.248|
0000f0  e004              B        |L21.252|
                  |L21.242|
0000f2  f7fffffe          BL       CLK_GetPLLClockFreq
0000f6  e001              B        |L21.252|
                  |L21.248|
;;;439            {
;;;440                /* Clock source is PCLK0 */
;;;441                u32ClkSrc = CLK_GetPCLK0Freq();
0000f8  f7fffffe          BL       CLK_GetPCLK0Freq
                  |L21.252|
0000fc  2100              MOVS     r1,#0
;;;442            }
;;;443            else
;;;444            {
;;;445                u32ClkSrc = __HIRC; /* Clock source is HIRC */
;;;446            }
;;;447        }
;;;448    
;;;449        if(u32BusClock >= u32HCLKFreq)
0000fe  42b5              CMP      r5,r6
000100  d201              BCS      |L21.262|
;;;450        {
;;;451            /* Set DIVIDER = 0 */
;;;452            spi->CLKDIV = 0U;
;;;453            /* Return master peripheral clock rate */
;;;454            u32RetValue = u32ClkSrc;
;;;455        }
;;;456        else if(u32BusClock >= u32ClkSrc)
000102  4285              CMP      r5,r0
000104  d302              BCC      |L21.268|
                  |L21.262|
000106  6061              STR      r1,[r4,#4]            ;452
                  |L21.264|
;;;457        {
;;;458            /* Set DIVIDER = 0 */
;;;459            spi->CLKDIV = 0U;
;;;460            /* Return master peripheral clock rate */
;;;461            u32RetValue = u32ClkSrc;
;;;462        }
;;;463        else if(u32BusClock == 0U)
;;;464        {
;;;465            /* Set DIVIDER to the maximum value 0xFF. f_spi = f_spi_clk_src / (DIVIDER + 1) */
;;;466            spi->CLKDIV |= SPI_CLKDIV_DIVIDER_Msk;
;;;467            /* Return master peripheral clock rate */
;;;468            u32RetValue = (u32ClkSrc / (0xFFU + 1U));
;;;469        }
;;;470        else
;;;471        {
;;;472            u32Div = (((u32ClkSrc * 10U) / u32BusClock + 5U) / 10U) - 1U; /* Round to the nearest integer */
;;;473            if(u32Div > 0x1FFU)
;;;474            {
;;;475                u32Div = 0x1FFU;
;;;476                spi->CLKDIV |= SPI_CLKDIV_DIVIDER_Msk;
;;;477                /* Return master peripheral clock rate */
;;;478                u32RetValue = (u32ClkSrc / (0xFFU + 1U));
;;;479            }
;;;480            else
;;;481            {
;;;482                spi->CLKDIV = (spi->CLKDIV & (~SPI_CLKDIV_DIVIDER_Msk)) | (u32Div << SPI_CLKDIV_DIVIDER_Pos);
;;;483                /* Return master peripheral clock rate */
;;;484                u32RetValue = (u32ClkSrc / (u32Div + 1U));
;;;485            }
;;;486        }
;;;487    
;;;488        return u32RetValue;
;;;489    }
000108  e8bd81f0          POP      {r4-r8,pc}
                  |L21.268|
00010c  f24012ff          MOV      r2,#0x1ff             ;466
000110  b165              CBZ      r5,|L21.300|
000112  eb000180          ADD      r1,r0,r0,LSL #2       ;472
000116  0049              LSLS     r1,r1,#1              ;472
000118  fbb1f1f5          UDIV     r1,r1,r5              ;472
00011c  230a              MOVS     r3,#0xa               ;472
00011e  1d49              ADDS     r1,r1,#5              ;472
000120  fbb1f1f3          UDIV     r1,r1,r3              ;472
000124  1e49              SUBS     r1,r1,#1              ;472
000126  f5b17f00          CMP      r1,#0x200             ;473
00012a  d304              BCC      |L21.310|
                  |L21.300|
00012c  6861              LDR      r1,[r4,#4]            ;466
00012e  4311              ORRS     r1,r1,r2              ;466
000130  6061              STR      r1,[r4,#4]            ;466
000132  0a00              LSRS     r0,r0,#8              ;468
000134  e7e8              B        |L21.264|
                  |L21.310|
000136  6862              LDR      r2,[r4,#4]            ;482
000138  f36f0208          BFC      r2,#0,#9              ;482
00013c  430a              ORRS     r2,r2,r1              ;482
00013e  6062              STR      r2,[r4,#4]            ;482
000140  1c49              ADDS     r1,r1,#1              ;482
000142  fbb0f0f1          UDIV     r0,r0,r1              ;484
000146  e7df              B        |L21.264|
;;;490    
                          ENDP

                  |L21.328|
                          DCD      0x40061000
                  |L21.332|
                          DCD      0x40062000
                  |L21.336|
                          DCD      0x40063000
                  |L21.340|
                          DCD      0x00b71b00

                          AREA ||i.SPI_SetFIFO||, CODE, READONLY, ALIGN=1

                  SPI_SetFIFO PROC
;;;498      */
;;;499    void SPI_SetFIFO(SPI_T *spi, uint32_t u32TxThreshold, uint32_t u32RxThreshold)
000000  6903              LDR      r3,[r0,#0x10]
;;;500    {
;;;501        spi->FIFOCTL = (spi->FIFOCTL & ~(SPI_FIFOCTL_TXTH_Msk | SPI_FIFOCTL_RXTH_Msk)) |
000002  f02343ee          BIC      r3,r3,#0x77000000
000006  ea437101          ORR      r1,r3,r1,LSL #28
00000a  ea416102          ORR      r1,r1,r2,LSL #24
00000e  6101              STR      r1,[r0,#0x10]
;;;502                       (u32TxThreshold << SPI_FIFOCTL_TXTH_Pos) |
;;;503                       (u32RxThreshold << SPI_FIFOCTL_RXTH_Pos);
;;;504    }
000010  4770              BX       lr
;;;505    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_spi_c_SPI_Open____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_spi_c_SPI_Open____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_spi_c_SPI_Open____REVSH|
#line 402
|__asm___5_spi_c_SPI_Open____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_spi_c_SPI_Open____RRX|
#line 587
|__asm___5_spi_c_SPI_Open____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
