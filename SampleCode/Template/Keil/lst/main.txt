; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -I..\..\Template -I..\Kalman_Filter -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.I2C0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  I2C0_Init PROC
;;;53     
;;;54     void I2C0_Init(void)	//PA5 : SCL , PA4 : SDA
000000  b510              PUSH     {r4,lr}
;;;55     {
;;;56         SYS_ResetModule(I2C0_RST);
000002  480e              LDR      r0,|L1.60|
000004  f7fffffe          BL       SYS_ResetModule
;;;57     
;;;58         /* Open I2C module and set bus clock */
;;;59         I2C_Open(MASTER_I2C, LSM6DSL_I2C_SPEED);
000008  4c0e              LDR      r4,|L1.68|
00000a  490d              LDR      r1,|L1.64|
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       I2C_Open
;;;60     
;;;61         I2C_SetSlaveAddr(MASTER_I2C, 0, LSM6DSL_ADDRESS, I2C_GCMODE_DISABLE);   /* Slave Address : 1101011b */
000012  2300              MOVS     r3,#0
000014  22d6              MOVS     r2,#0xd6
000016  4619              MOV      r1,r3
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       I2C_SetSlaveAddr
;;;62     
;;;63         /* Get I2C0 Bus Clock */
;;;64         printf("I2C clock %d Hz\n", I2C_GetBusClockFreq(MASTER_I2C));
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       I2C_GetBusClockFreq
000024  4601              MOV      r1,r0
000026  a008              ADR      r0,|L1.72|
000028  f7fffffe          BL       __2printf
;;;65     
;;;66     	#if defined (ENABLE_I2C_IRQ)
;;;67         I2C_EnableInt(MASTER_I2C);
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       I2C_EnableInt
;;;68         NVIC_EnableIRQ(MASTER_I2C_IRQn);
000032  e8bd4010          POP      {r4,lr}
000036  2026              MOVS     r0,#0x26
000038  f7ffbffe          B.W      NVIC_EnableIRQ
;;;69     	#endif
;;;70     	
;;;71     }
;;;72     
                          ENDP

                  |L1.60|
                          DCD      0x04000008
                  |L1.64|
                          DCD      0x000186a0
                  |L1.68|
                          DCD      0x40080000
                  |L1.72|
000048  49324320          DCB      "I2C clock %d Hz\n",0
00004c  636c6f63
000050  6b202564
000054  20487a0a
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0

                          AREA ||i.LED_Init||, CODE, READONLY, ALIGN=2

                  LED_Init PROC
;;;201    
;;;202    void LED_Init(void)
000000  b510              PUSH     {r4,lr}
;;;203    {
;;;204    	GPIO_SetMode(PH,BIT0,GPIO_MODE_OUTPUT);
000002  4c09              LDR      r4,|L2.40|
000004  2201              MOVS     r2,#1
000006  4611              MOV      r1,r2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GPIO_SetMode
;;;205    	GPIO_SetMode(PH,BIT1,GPIO_MODE_OUTPUT);
00000e  2201              MOVS     r2,#1
000010  2102              MOVS     r1,#2
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_SetMode
;;;206    	GPIO_SetMode(PH,BIT2,GPIO_MODE_OUTPUT);
000018  4620              MOV      r0,r4
00001a  2201              MOVS     r2,#1
00001c  e8bd4010          POP      {r4,lr}
000020  2104              MOVS     r1,#4
000022  f7ffbffe          B.W      GPIO_SetMode
;;;207    	
;;;208    }
;;;209    
                          ENDP

000026  0000              DCW      0x0000
                  |L2.40|
                          DCD      0x400041c0

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1625    */
;;;1626   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1627   {
;;;1628     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01100          STR      r1,[r0,#0x100]
;;;1629   }
000014  4770              BX       lr
;;;1630   
                          ENDP


                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;209    
;;;210    void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
000002  2059              MOVS     r0,#0x59
000004  0784              LSLS     r4,r0,#30
000006  2116              MOVS     r1,#0x16
000008  2288              MOVS     r2,#0x88
                  |L4.10|
00000a  f8c40100          STR      r0,[r4,#0x100]
00000e  f8c41100          STR      r1,[r4,#0x100]
000012  f8c42100          STR      r2,[r4,#0x100]
000016  f8d43100          LDR      r3,[r4,#0x100]
00001a  2b00              CMP      r3,#0
00001c  d0f5              BEQ      |L4.10|
;;;211    {
;;;212        /*---------------------------------------------------------------------------------------------------------*/
;;;213        /* Init System Clock                                                                                       */
;;;214        /*---------------------------------------------------------------------------------------------------------*/
;;;215        /* Unlock protected registers */
;;;216        SYS_UnlockReg();
;;;217    
;;;218        /* Set XT1_OUT(PF.2) and XT1_IN(PF.3) to input mode */
;;;219        PF->MODE &= ~(GPIO_MODE_MODE2_Msk | GPIO_MODE_MODE3_Msk);
00001e  f04f2040          MOV      r0,#0x40004000
000022  f8d01140          LDR      r1,[r0,#0x140]
000026  f02101f0          BIC      r1,r1,#0xf0
00002a  f8c01140          STR      r1,[r0,#0x140]
;;;220    
;;;221        /* Enable External XTAL (4~24 MHz) */
;;;222        CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
00002e  2001              MOVS     r0,#1
000030  f7fffffe          BL       CLK_EnableXtalRC
;;;223    
;;;224        /* Waiting for 12MHz clock ready */
;;;225        CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
000034  2001              MOVS     r0,#1
000036  f7fffffe          BL       CLK_WaitClockReady
;;;226    
;;;227        /* Set core clock as PLL_CLOCK from PLL */
;;;228        CLK_SetCoreClock(FREQ_192MHZ);
00003a  4816              LDR      r0,|L4.148|
00003c  f7fffffe          BL       CLK_SetCoreClock
;;;229        /* Set PCLK0/PCLK1 to HCLK/2 */
;;;230        CLK->PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);
000040  2011              MOVS     r0,#0x11
000042  f8c40234          STR      r0,[r4,#0x234]
;;;231    
;;;232        /* Enable UART clock */
;;;233        CLK_EnableModuleClock(UART0_MODULE);
000046  4d14              LDR      r5,|L4.152|
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       CLK_EnableModuleClock
;;;234    
;;;235        /* Select UART clock source from HXT */
;;;236        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HXT, CLK_CLKDIV0_UART0(1));
00004e  2200              MOVS     r2,#0
000050  4611              MOV      r1,r2
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       CLK_SetModuleClock
;;;237    
;;;238        CLK_EnableModuleClock(I2C0_MODULE);
000058  4810              LDR      r0,|L4.156|
00005a  f7fffffe          BL       CLK_EnableModuleClock
;;;239    
;;;240        CLK_EnableModuleClock(PDMA_MODULE);
00005e  2001              MOVS     r0,#1
000060  f7fffffe          BL       CLK_EnableModuleClock
;;;241    
;;;242    	TIMER0_HW_Init();
000064  f7fffffe          BL       TIMER0_HW_Init
;;;243    	TIMER1_HW_Init();
000068  f7fffffe          BL       TIMER1_HW_Init
;;;244    	
;;;245        /* Update System Core Clock */
;;;246        /* User can use SystemCoreClockUpdate() to calculate SystemCoreClock. */
;;;247        SystemCoreClockUpdate();
00006c  f7fffffe          BL       SystemCoreClockUpdate
;;;248    
;;;249        /* Set GPB multi-function pins for UART0 RXD and TXD */
;;;250        SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk);
000070  6be0              LDR      r0,[r4,#0x3c]
000072  f420007f          BIC      r0,r0,#0xff0000
000076  63e0              STR      r0,[r4,#0x3c]
;;;251        SYS->GPB_MFPH |= (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
000078  6be0              LDR      r0,[r4,#0x3c]
00007a  f44000cc          ORR      r0,r0,#0x660000
00007e  63e0              STR      r0,[r4,#0x3c]
;;;252    
;;;253        /* Set I2C0 multi-function pins */
;;;254        SYS->GPA_MFPL = (SYS->GPA_MFPL & ~(SYS_GPA_MFPL_PA5MFP_Msk | SYS_GPA_MFPL_PA4MFP_Msk)) |
000080  6b20              LDR      r0,[r4,#0x30]
000082  f420007f          BIC      r0,r0,#0xff0000
000086  f4400019          ORR      r0,r0,#0x990000
00008a  6320              STR      r0,[r4,#0x30]
00008c  2000              MOVS     r0,#0
00008e  f8c40100          STR      r0,[r4,#0x100]
;;;255                        (SYS_GPA_MFPL_PA4MFP_I2C0_SDA | SYS_GPA_MFPL_PA5MFP_I2C0_SCL);
;;;256    	
;;;257        /* Lock protected registers */
;;;258        SYS_LockReg();
;;;259    }
000092  bd70              POP      {r4-r6,pc}
;;;260    
                          ENDP

                  |L4.148|
                          DCD      0x0b71b000
                  |L4.152|
                          DCD      0x57803d10
                  |L4.156|
                          DCD      0x40000008

                          AREA ||i.TIMER0_HW_Init||, CODE, READONLY, ALIGN=2

                  TIMER0_HW_Init PROC
;;;190    
;;;191    void TIMER0_HW_Init(void)
000000  b510              PUSH     {r4,lr}
;;;192    {
;;;193    	CLK_EnableModuleClock(TMR0_MODULE);
000002  4c06              LDR      r4,|L5.28|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       CLK_EnableModuleClock
;;;194    	CLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0SEL_PCLK0, 0);
00000a  4620              MOV      r0,r4
00000c  e8bd4010          POP      {r4,lr}
000010  2200              MOVS     r2,#0
000012  f44f7100          MOV      r1,#0x200
000016  f7ffbffe          B.W      CLK_SetModuleClock
;;;195    }
;;;196    
                          ENDP

00001a  0000              DCW      0x0000
                  |L5.28|
                          DCD      0x5e800002

                          AREA ||i.TIMER0_Polling||, CODE, READONLY, ALIGN=2

                  TIMER0_Polling PROC
;;;196    
;;;197    void TIMER0_Polling(uint32_t u32Usec)
000000  4601              MOV      r1,r0
;;;198    {
;;;199    	TIMER_Delay(TIMER0, u32Usec);
000002  4801              LDR      r0,|L6.8|
000004  f7ffbffe          B.W      TIMER_Delay
;;;200    }
;;;201    
                          ENDP

                  |L6.8|
                          DCD      0x40050000

                          AREA ||i.TIMER1_HW_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_HW_Init PROC
;;;176    
;;;177    void TIMER1_HW_Init(void)
000000  b510              PUSH     {r4,lr}
;;;178    {
;;;179        CLK_EnableModuleClock(TMR1_MODULE);
000002  4c06              LDR      r4,|L7.28|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       CLK_EnableModuleClock
;;;180        CLK_SetModuleClock(TMR1_MODULE, CLK_CLKSEL1_TMR1SEL_HIRC, 0);
00000a  4620              MOV      r0,r4
00000c  e8bd4010          POP      {r4,lr}
000010  2200              MOVS     r2,#0
000012  f44f41e0          MOV      r1,#0x7000
000016  f7ffbffe          B.W      CLK_SetModuleClock
;;;181    }
;;;182    
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      0x5ec00003

                          AREA ||i.TIMER1_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_Init PROC
;;;182    
;;;183    void TIMER1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;184    {
;;;185        TIMER_Open(TIMER1, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L8.44|
000004  f44f727a          MOV      r2,#0x3e8
000008  f04f6100          MOV      r1,#0x8000000
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  f0405000          ORR      r0,r0,#0x20000000
000018  6020              STR      r0,[r4,#0]
;;;186        TIMER_EnableInt(TIMER1);
;;;187        NVIC_EnableIRQ(TMR1_IRQn);	
00001a  2021              MOVS     r0,#0x21
00001c  f7fffffe          BL       NVIC_EnableIRQ
000020  6820              LDR      r0,[r4,#0]
000022  f0404080          ORR      r0,r0,#0x40000000
000026  6020              STR      r0,[r4,#0]
;;;188        TIMER_Start(TIMER1);
;;;189    }
000028  bd10              POP      {r4,pc}
;;;190    
                          ENDP

00002a  0000              DCW      0x0000
                  |L8.44|
                          DCD      0x40050100

                          AREA ||i.TMR1_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR1_IRQHandler PROC
;;;144    
;;;145    void TMR1_IRQHandler(void)
000000  4811              LDR      r0,|L9.72|
000002  6881              LDR      r1,[r0,#8]
000004  f3c10100          UBFX     r1,r1,#0,#1
;;;146    {
000008  2900              CMP      r1,#0
00000a  d01c              BEQ      |L9.70|
00000c  2101              MOVS     r1,#1
00000e  6081              STR      r1,[r0,#8]
;;;147    	static uint16_t CNT = 0;	
;;;148    //	static uint32_t log = 0;	
;;;149    
;;;150    	static uint16_t CNT_SWITCH = 0;
;;;151    	
;;;152        if(TIMER_GetIntFlag(TIMER1) == 1)
;;;153        {
;;;154            TIMER_ClearIntFlag(TIMER1);
;;;155    	
;;;156    		if (CNT++ > 1000)
000010  490e              LDR      r1,|L9.76|
000012  2300              MOVS     r3,#0
000014  8808              LDRH     r0,[r1,#0]  ; CNT
000016  1c42              ADDS     r2,r0,#1
000018  800a              STRH     r2,[r1,#0]
00001a  f5b07f7a          CMP      r0,#0x3e8
00001e  d905              BLS      |L9.44|
;;;157    		{		
;;;158    			CNT = 0;
;;;159    //			printf("%s : %2d\r\n" , __FUNCTION__ , log++);
;;;160    
;;;161    			LED_G ^= 1;
000020  480b              LDR      r0,|L9.80|
000022  800b              STRH     r3,[r1,#0]            ;158
000024  6802              LDR      r2,[r0,#0]
000026  f0820201          EOR      r2,r2,#1
00002a  6002              STR      r2,[r0,#0]
                  |L9.44|
;;;162    		}
;;;163    
;;;164    		if (CNT_SWITCH++ >= 10000)
00002c  8848              LDRH     r0,[r1,#2]  ; CNT_SWITCH
00002e  1c42              ADDS     r2,r0,#1
000030  804a              STRH     r2,[r1,#2]
000032  f2427210          MOV      r2,#0x2710
000036  4290              CMP      r0,r2
000038  d305              BCC      |L9.70|
;;;165    		{		
;;;166    			CNT_SWITCH = 0;
;;;167    			FlagSwitch ^= 1;
00003a  4806              LDR      r0,|L9.84|
00003c  804b              STRH     r3,[r1,#2]            ;166
00003e  7801              LDRB     r1,[r0,#0]  ; FlagSwitch
000040  f0810101          EOR      r1,r1,#1
000044  7001              STRB     r1,[r0,#0]
                  |L9.70|
;;;168    
;;;169    //        	printf("addr : 0x%2X\r\n",LSM6DS3_ADDRESS);			
;;;170    //			convertDecToBin(LSM6DS3_ADDRESS);
;;;171    //			printf("\r\n");			
;;;172    		}	
;;;173    		
;;;174        }
;;;175    }
000046  4770              BX       lr
;;;176    
                          ENDP

                  |L9.72|
                          DCD      0x40050100
                  |L9.76|
                          DCD      ||area_number.17||
                  |L9.80|
                          DCD      0x400049c8
                  |L9.84|
                          DCD      FlagSwitch

                          AREA ||i.UART0_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART0_IRQHandler PROC
;;;103    
;;;104    void UART0_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;105    {
;;;106        if(UART_GET_INT_FLAG(UART0, UART_INTSTS_RDAINT_Msk | UART_INTSTS_RXTOINT_Msk))     /* UART receive data available flag */
000002  4c0b              LDR      r4,|L10.48|
000004  69e0              LDR      r0,[r4,#0x1c]
000006  f4105f88          TST      r0,#0x1100
00000a  d102              BNE      |L10.18|
00000c  e004              B        |L10.24|
                  |L10.14|
;;;107        {
;;;108            while(UART_GET_RX_EMPTY(UART0) == 0)
;;;109            {
;;;110    			UARTx_Process();
00000e  f7fffffe          BL       UARTx_Process
                  |L10.18|
000012  69a1              LDR      r1,[r4,#0x18]         ;108
000014  0449              LSLS     r1,r1,#17             ;108
000016  d5fa              BPL      |L10.14|
                  |L10.24|
;;;111            }
;;;112        }
;;;113    
;;;114        if(UART0->FIFOSTS & (UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_PEF_Msk | UART_FIFOSTS_RXOVIF_Msk))
000018  69a1              LDR      r1,[r4,#0x18]
00001a  4620              MOV      r0,r4
00001c  f0110f71          TST      r1,#0x71
000020  d005              BEQ      |L10.46|
;;;115        {
;;;116            UART_ClearIntFlag(UART0, (UART_INTSTS_RLSINT_Msk| UART_INTSTS_BUFERRINT_Msk));
000022  e8bd4010          POP      {r4,lr}
000026  f44f5110          MOV      r1,#0x2400
00002a  f7ffbffe          B.W      UART_ClearIntFlag
                  |L10.46|
;;;117        }
;;;118    }
00002e  bd10              POP      {r4,pc}
;;;119    
                          ENDP

                  |L10.48|
                          DCD      0x40070000

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;119    
;;;120    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;121    {
;;;122        SYS_ResetModule(UART0_RST);
000002  481e              LDR      r0,|L11.124|
000004  f7fffffe          BL       SYS_ResetModule
;;;123    
;;;124        /* Configure UART0 and set UART0 baud rate */
;;;125        UART_Open(UART0, 115200);
000008  4c1d              LDR      r4,|L11.128|
00000a  f44f31e1          MOV      r1,#0x1c200
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       UART_Open
;;;126    
;;;127    	/* Set UART receive time-out */
;;;128    	UART_SetTimeoutCnt(UART0, 20);
000014  2114              MOVS     r1,#0x14
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       UART_SetTimeoutCnt
;;;129    
;;;130    	UART0->FIFO &= ~UART_FIFO_RFITL_4BYTES;
00001c  68a0              LDR      r0,[r4,#8]
00001e  f0200010          BIC      r0,r0,#0x10
000022  60a0              STR      r0,[r4,#8]
;;;131    	UART0->FIFO |= UART_FIFO_RFITL_8BYTES;
000024  68a0              LDR      r0,[r4,#8]
000026  f0400020          ORR      r0,r0,#0x20
00002a  60a0              STR      r0,[r4,#8]
;;;132    
;;;133    	/* Enable UART Interrupt - */
;;;134    	UART_ENABLE_INT(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_TOCNTEN_Msk | UART_INTEN_RXTOIEN_Msk);
00002c  6860              LDR      r0,[r4,#4]
00002e  f6400111          MOV      r1,#0x811
000032  4308              ORRS     r0,r0,r1
000034  6060              STR      r0,[r4,#4]
;;;135    	
;;;136    	NVIC_EnableIRQ(UART0_IRQn);
000036  2024              MOVS     r0,#0x24
000038  f7fffffe          BL       NVIC_EnableIRQ
;;;137    
;;;138    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
00003c  f7fffffe          BL       CLK_GetCPUFreq
000040  4601              MOV      r1,r0
000042  a010              ADR      r0,|L11.132|
000044  f7fffffe          BL       __2printf
;;;139    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
000048  f7fffffe          BL       CLK_GetHXTFreq
00004c  4601              MOV      r1,r0
00004e  a014              ADR      r0,|L11.160|
000050  f7fffffe          BL       __2printf
;;;140    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
000054  f7fffffe          BL       CLK_GetLXTFreq
000058  4601              MOV      r1,r0
00005a  a017              ADR      r0,|L11.184|
00005c  f7fffffe          BL       __2printf
;;;141    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
000060  f7fffffe          BL       CLK_GetPCLK0Freq
000064  4601              MOV      r1,r0
000066  a01a              ADR      r0,|L11.208|
000068  f7fffffe          BL       __2printf
;;;142    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());	
00006c  f7fffffe          BL       CLK_GetPCLK1Freq
000070  4601              MOV      r1,r0
000072  e8bd4010          POP      {r4,lr}
000076  a01d              ADR      r0,|L11.236|
000078  f7ffbffe          B.W      __2printf
;;;143    }
;;;144    
                          ENDP

                  |L11.124|
                          DCD      0x04000010
                  |L11.128|
                          DCD      0x40070000
                  |L11.132|
000084  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
000088  4b5f4765
00008c  74435055
000090  46726571
000094  203a2025
000098  38640d0a
00009c  00      
00009d  00                DCB      0
00009e  00                DCB      0
00009f  00                DCB      0
                  |L11.160|
0000a0  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
0000a4  47657448
0000a8  58544672
0000ac  6571203a
0000b0  20253864
0000b4  0d0a00  
0000b7  00                DCB      0
                  |L11.184|
0000b8  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
0000bc  4765744c
0000c0  58544672
0000c4  6571203a
0000c8  20253864
0000cc  0d0a00  
0000cf  00                DCB      0
                  |L11.208|
0000d0  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000d4  47657450
0000d8  434c4b30
0000dc  46726571
0000e0  203a2025
0000e4  38640d0a
0000e8  00      
0000e9  00                DCB      0
0000ea  00                DCB      0
0000eb  00                DCB      0
                  |L11.236|
0000ec  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000f0  47657450
0000f4  434c4b31
0000f8  46726571
0000fc  203a2025
000100  38640d0a
000104  00      
000105  00                DCB      0
000106  00                DCB      0
000107  00                DCB      0

                          AREA ||i.UARTx_Process||, CODE, READONLY, ALIGN=2

                  UARTx_Process PROC
;;;73     
;;;74     void UARTx_Process(void)
000000  4811              LDR      r0,|L12.72|
;;;75     {
;;;76     	uint8_t res = 0;
;;;77     	
;;;78     	res = UART_READ(UART0);
000002  6800              LDR      r0,[r0,#0]
000004  b2c0              UXTB     r0,r0
;;;79     
;;;80     	if (res > 0x7F)
000006  287f              CMP      r0,#0x7f
000008  d901              BLS      |L12.14|
;;;81     	{
;;;82     		printf("invalid command\r\n");
00000a  a010              ADR      r0,|L12.76|
00000c  e019              B        |L12.66|
                  |L12.14|
;;;83     	}
;;;84     	else
;;;85     	{
;;;86     		switch(res)
00000e  285a              CMP      r0,#0x5a
000010  d009              BEQ      |L12.38|
000012  dc04              BGT      |L12.30|
000014  2831              CMP      r0,#0x31
000016  d013              BEQ      |L12.64|
000018  2858              CMP      r0,#0x58
00001a  d114              BNE      |L12.70|
00001c  e003              B        |L12.38|
                  |L12.30|
00001e  2878              CMP      r0,#0x78
000020  d001              BEQ      |L12.38|
000022  287a              CMP      r0,#0x7a
000024  d10f              BNE      |L12.70|
                  |L12.38|
000026  f3bf8f4f          DSB      
00002a  480d              LDR      r0,|L12.96|
00002c  6801              LDR      r1,[r0,#0]
00002e  4a0d              LDR      r2,|L12.100|
000030  f40161e0          AND      r1,r1,#0x700
000034  4311              ORRS     r1,r1,r2
000036  6001              STR      r1,[r0,#0]
000038  f3bf8f4f          DSB      
                  |L12.60|
00003c  bf00              NOP      
00003e  e7fd              B        |L12.60|
                  |L12.64|
;;;87     		{
;;;88     			case '1':
;;;89     				printf("...\r\n\r\n");
000040  a009              ADR      r0,|L12.104|
                  |L12.66|
000042  f7ffbffe          B.W      __2printf
                  |L12.70|
;;;90     				break;	
;;;91     
;;;92     			case 'X':
;;;93     			case 'x':
;;;94     			case 'Z':
;;;95     			case 'z':
;;;96     				NVIC_SystemReset();
;;;97     			
;;;98     				break;		
;;;99     			
;;;100    		}
;;;101    	}
;;;102    }
000046  4770              BX       lr
;;;103    
                          ENDP

                  |L12.72|
                          DCD      0x40070000
                  |L12.76|
00004c  696e7661          DCB      "invalid command\r\n",0
000050  6c696420
000054  636f6d6d
000058  616e640d
00005c  0a00    
00005e  00                DCB      0
00005f  00                DCB      0
                  |L12.96|
                          DCD      0xe000ed0c
                  |L12.100|
                          DCD      0x05fa0004
                  |L12.104|
000068  2e2e2e0d          DCB      "...\r\n\r\n",0
00006c  0a0d0a00

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;268    
;;;269    int main()
000000  f7fffffe          BL       SYS_Init
;;;270    {	
;;;271    
;;;272        SYS_Init();
;;;273    	UART0_Init();
000004  f7fffffe          BL       UART0_Init
;;;274    
;;;275    	I2C0_Init();
000008  f7fffffe          BL       I2C0_Init
;;;276    	
;;;277    	LED_Init();
00000c  f7fffffe          BL       LED_Init
;;;278    	TIMER1_Init();
000010  f7fffffe          BL       TIMER1_Init
;;;279    
;;;280    	appLSM6DSL_Setup();
000014  f7fffffe          BL       appLSM6DSL_Setup
;;;281    
;;;282        /* Got no where to go, just loop forever */
;;;283        while(1)
;;;284        {
;;;285    //		TIMER0_Polling(1000);
;;;286    
;;;287    		appLSM6DSL_GetData();
;;;288    //		appLSM6DSL_GetWhoAmI();
;;;289    
;;;290    		LED_Y ^= 1;
000018  4c03              LDR      r4,|L13.40|
                  |L13.26|
00001a  f7fffffe          BL       appLSM6DSL_GetData
00001e  6820              LDR      r0,[r4,#0]
000020  f0800001          EOR      r0,r0,#1
000024  6020              STR      r0,[r4,#0]
000026  e7f8              B        |L13.26|
;;;291    		
;;;292    	
;;;293        }
;;;294    
;;;295    }
;;;296    
                          ENDP

                  |L13.40|
                          DCD      0x400049c4

                          AREA ||.data||, DATA, ALIGN=2

                  BitFlag
                          DCD      0x00000000

                          AREA ||area_number.17||, DATA, ALIGN=1

                          EXPORTAS ||area_number.17||, ||.data||
                  ||CNT||
000000  0000              DCW      0x0000
                  CNT_SWITCH
000002  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_BitFlag____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REVSH|
#line 402
|__asm___6_main_c_BitFlag____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____RRX|
#line 587
|__asm___6_main_c_BitFlag____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
