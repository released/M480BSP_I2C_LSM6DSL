; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\qspi.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\qspi.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\qspi.crf ..\..\..\Library\StdDriver\src\qspi.c]
                          THUMB

                          AREA ||i.QSPI_ClearIntFlag||, CODE, READONLY, ALIGN=1

                  QSPI_ClearIntFlag PROC
;;;722      */
;;;723    void QSPI_ClearIntFlag(QSPI_T *qspi, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;724    {
000002  d001              BEQ      |L1.8|
;;;725        if(u32Mask & QSPI_UNIT_INT_MASK)
;;;726        {
;;;727            qspi->STATUS = QSPI_STATUS_UNITIF_Msk; /* Clear unit transfer interrupt flag */
000004  2202              MOVS     r2,#2
000006  6142              STR      r2,[r0,#0x14]
                  |L1.8|
;;;728        }
;;;729    
;;;730        if(u32Mask & QSPI_SSACT_INT_MASK)
000008  078a              LSLS     r2,r1,#30
00000a  d501              BPL      |L1.16|
;;;731        {
;;;732            qspi->STATUS = QSPI_STATUS_SSACTIF_Msk; /* Clear slave selection signal active interrupt flag */
00000c  2204              MOVS     r2,#4
00000e  6142              STR      r2,[r0,#0x14]
                  |L1.16|
;;;733        }
;;;734    
;;;735        if(u32Mask & QSPI_SSINACT_INT_MASK)
000010  074a              LSLS     r2,r1,#29
000012  d501              BPL      |L1.24|
;;;736        {
;;;737            qspi->STATUS = QSPI_STATUS_SSINAIF_Msk; /* Clear slave selection signal inactive interrupt flag */
000014  2208              MOVS     r2,#8
000016  6142              STR      r2,[r0,#0x14]
                  |L1.24|
;;;738        }
;;;739    
;;;740        if(u32Mask & QSPI_SLVUR_INT_MASK)
000018  070a              LSLS     r2,r1,#28
00001a  d501              BPL      |L1.32|
;;;741        {
;;;742            qspi->STATUS = QSPI_STATUS_SLVURIF_Msk; /* Clear slave TX under run interrupt flag */
00001c  2280              MOVS     r2,#0x80
00001e  6142              STR      r2,[r0,#0x14]
                  |L1.32|
;;;743        }
;;;744    
;;;745        if(u32Mask & QSPI_SLVBE_INT_MASK)
000020  06ca              LSLS     r2,r1,#27
000022  d501              BPL      |L1.40|
;;;746        {
;;;747            qspi->STATUS = QSPI_STATUS_SLVBEIF_Msk; /* Clear slave bit count error interrupt flag */
000024  2240              MOVS     r2,#0x40
000026  6142              STR      r2,[r0,#0x14]
                  |L1.40|
;;;748        }
;;;749    
;;;750        if(u32Mask & QSPI_TXUF_INT_MASK)
000028  064a              LSLS     r2,r1,#25
00002a  d502              BPL      |L1.50|
;;;751        {
;;;752            qspi->STATUS = QSPI_STATUS_TXUFIF_Msk; /* Clear slave TX underflow interrupt flag */
00002c  f44f2200          MOV      r2,#0x80000
000030  6142              STR      r2,[r0,#0x14]
                  |L1.50|
;;;753        }
;;;754    
;;;755        if(u32Mask & QSPI_FIFO_RXOV_INT_MASK)
000032  058a              LSLS     r2,r1,#22
000034  d502              BPL      |L1.60|
;;;756        {
;;;757            qspi->STATUS = QSPI_STATUS_RXOVIF_Msk; /* Clear RX overrun interrupt flag */
000036  f44f6200          MOV      r2,#0x800
00003a  6142              STR      r2,[r0,#0x14]
                  |L1.60|
;;;758        }
;;;759    
;;;760        if(u32Mask & QSPI_FIFO_RXTO_INT_MASK)
00003c  0549              LSLS     r1,r1,#21
00003e  d502              BPL      |L1.70|
;;;761        {
;;;762            qspi->STATUS = QSPI_STATUS_RXTOIF_Msk; /* Clear RX time-out interrupt flag */
000040  f44f5180          MOV      r1,#0x1000
000044  6141              STR      r1,[r0,#0x14]
                  |L1.70|
;;;763        }
;;;764    }
000046  4770              BX       lr
;;;765    
                          ENDP


                          AREA ||i.QSPI_ClearRxFIFO||, CODE, READONLY, ALIGN=1

                  QSPI_ClearRxFIFO PROC
;;;211      */
;;;212    void QSPI_ClearRxFIFO(QSPI_T *qspi)
000000  6901              LDR      r1,[r0,#0x10]
;;;213    {
;;;214        qspi->FIFOCTL |= QSPI_FIFOCTL_RXFBCLR_Msk;
000002  f4417180          ORR      r1,r1,#0x100
000006  6101              STR      r1,[r0,#0x10]
;;;215    }
000008  4770              BX       lr
;;;216    
                          ENDP


                          AREA ||i.QSPI_ClearTxFIFO||, CODE, READONLY, ALIGN=1

                  QSPI_ClearTxFIFO PROC
;;;223      */
;;;224    void QSPI_ClearTxFIFO(QSPI_T *qspi)
000000  6901              LDR      r1,[r0,#0x10]
;;;225    {
;;;226        qspi->FIFOCTL |= QSPI_FIFOCTL_TXFBCLR_Msk;
000002  f4417100          ORR      r1,r1,#0x200
000006  6101              STR      r1,[r0,#0x10]
;;;227    }
000008  4770              BX       lr
;;;228    
                          ENDP


                          AREA ||i.QSPI_Close||, CODE, READONLY, ALIGN=2

                  QSPI_Close PROC
;;;190      */
;;;191    void QSPI_Close(QSPI_T *qspi)
000000  4a0c              LDR      r2,|L4.52|
;;;192    {
;;;193        /* Reset QSPI */
;;;194        if (qspi == QSPI0)
;;;195        {
;;;196            SYS->IPRST1 |= SYS_IPRST1_QSPI0RST_Msk;
000002  f04f4180          MOV      r1,#0x40000000
000006  4290              CMP      r0,r2                 ;194
000008  d108              BNE      |L4.28|
00000a  68c8              LDR      r0,[r1,#0xc]
00000c  f4405080          ORR      r0,r0,#0x1000
000010  60c8              STR      r0,[r1,#0xc]
;;;197            SYS->IPRST1 &= ~SYS_IPRST1_QSPI0RST_Msk;
000012  68c8              LDR      r0,[r1,#0xc]
000014  f4205080          BIC      r0,r0,#0x1000
000018  60c8              STR      r0,[r1,#0xc]
                  |L4.26|
;;;198        }
;;;199        else if (qspi == QSPI1)
;;;200        {
;;;201            SYS->IPRST2 |= SYS_IPRST2_QSPI1RST_Msk;
;;;202            SYS->IPRST2 &= ~SYS_IPRST2_QSPI1RST_Msk;
;;;203        }
;;;204    }
00001a  4770              BX       lr
                  |L4.28|
00001c  4a06              LDR      r2,|L4.56|
00001e  4290              CMP      r0,r2                 ;199
000020  d1fb              BNE      |L4.26|
000022  6908              LDR      r0,[r1,#0x10]         ;201
000024  f0400010          ORR      r0,r0,#0x10           ;201
000028  6108              STR      r0,[r1,#0x10]         ;201
00002a  6908              LDR      r0,[r1,#0x10]         ;202
00002c  f0200010          BIC      r0,r0,#0x10           ;202
000030  6108              STR      r0,[r1,#0x10]         ;202
000032  4770              BX       lr
;;;205    
                          ENDP

                  |L4.52|
                          DCD      0x40060000
                  |L4.56|
                          DCD      0x40069000

                          AREA ||i.QSPI_DisableAutoSS||, CODE, READONLY, ALIGN=1

                  QSPI_DisableAutoSS PROC
;;;234      */
;;;235    void QSPI_DisableAutoSS(QSPI_T *qspi)
000000  6881              LDR      r1,[r0,#8]
;;;236    {
;;;237        qspi->SSCTL &= ~(QSPI_SSCTL_AUTOSS_Msk | QSPI_SSCTL_SS_Msk);
000002  f0210109          BIC      r1,r1,#9
000006  6081              STR      r1,[r0,#8]
;;;238    }
000008  4770              BX       lr
;;;239    
                          ENDP


                          AREA ||i.QSPI_DisableInt||, CODE, READONLY, ALIGN=1

                  QSPI_DisableInt PROC
;;;544      */
;;;545    void QSPI_DisableInt(QSPI_T *qspi, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;546    {
000002  d003              BEQ      |L6.12|
;;;547        /* Disable unit transfer interrupt flag */
;;;548        if((u32Mask & QSPI_UNIT_INT_MASK) == QSPI_UNIT_INT_MASK)
;;;549        {
;;;550            qspi->CTL &= ~QSPI_CTL_UNITIEN_Msk;
000004  6802              LDR      r2,[r0,#0]
000006  f4223200          BIC      r2,r2,#0x20000
00000a  6002              STR      r2,[r0,#0]
                  |L6.12|
;;;551        }
;;;552    
;;;553        /* Disable slave selection signal active interrupt flag */
;;;554        if((u32Mask & QSPI_SSACT_INT_MASK) == QSPI_SSACT_INT_MASK)
00000c  078a              LSLS     r2,r1,#30
00000e  d503              BPL      |L6.24|
;;;555        {
;;;556            qspi->SSCTL &= ~QSPI_SSCTL_SSACTIEN_Msk;
000010  6882              LDR      r2,[r0,#8]
000012  f4225280          BIC      r2,r2,#0x1000
000016  6082              STR      r2,[r0,#8]
                  |L6.24|
;;;557        }
;;;558    
;;;559        /* Disable slave selection signal inactive interrupt flag */
;;;560        if((u32Mask & QSPI_SSINACT_INT_MASK) == QSPI_SSINACT_INT_MASK)
000018  074a              LSLS     r2,r1,#29
00001a  d503              BPL      |L6.36|
;;;561        {
;;;562            qspi->SSCTL &= ~QSPI_SSCTL_SSINAIEN_Msk;
00001c  6882              LDR      r2,[r0,#8]
00001e  f4225200          BIC      r2,r2,#0x2000
000022  6082              STR      r2,[r0,#8]
                  |L6.36|
;;;563        }
;;;564    
;;;565        /* Disable slave TX under run interrupt flag */
;;;566        if((u32Mask & QSPI_SLVUR_INT_MASK) == QSPI_SLVUR_INT_MASK)
000024  070a              LSLS     r2,r1,#28
000026  d503              BPL      |L6.48|
;;;567        {
;;;568            qspi->SSCTL &= ~QSPI_SSCTL_SLVURIEN_Msk;
000028  6882              LDR      r2,[r0,#8]
00002a  f4227200          BIC      r2,r2,#0x200
00002e  6082              STR      r2,[r0,#8]
                  |L6.48|
;;;569        }
;;;570    
;;;571        /* Disable slave bit count error interrupt flag */
;;;572        if((u32Mask & QSPI_SLVBE_INT_MASK) == QSPI_SLVBE_INT_MASK)
000030  06ca              LSLS     r2,r1,#27
000032  d503              BPL      |L6.60|
;;;573        {
;;;574            qspi->SSCTL &= ~QSPI_SSCTL_SLVBEIEN_Msk;
000034  6882              LDR      r2,[r0,#8]
000036  f4227280          BIC      r2,r2,#0x100
00003a  6082              STR      r2,[r0,#8]
                  |L6.60|
;;;575        }
;;;576    
;;;577        /* Disable slave TX underflow interrupt flag */
;;;578        if((u32Mask & QSPI_TXUF_INT_MASK) == QSPI_TXUF_INT_MASK)
00003c  064a              LSLS     r2,r1,#25
00003e  d503              BPL      |L6.72|
;;;579        {
;;;580            qspi->FIFOCTL &= ~QSPI_FIFOCTL_TXUFIEN_Msk;
000040  6902              LDR      r2,[r0,#0x10]
000042  f0220280          BIC      r2,r2,#0x80
000046  6102              STR      r2,[r0,#0x10]
                  |L6.72|
;;;581        }
;;;582    
;;;583        /* Disable TX threshold interrupt flag */
;;;584        if((u32Mask & QSPI_FIFO_TXTH_INT_MASK) == QSPI_FIFO_TXTH_INT_MASK)
000048  060a              LSLS     r2,r1,#24
00004a  d503              BPL      |L6.84|
;;;585        {
;;;586            qspi->FIFOCTL &= ~QSPI_FIFOCTL_TXTHIEN_Msk;
00004c  6902              LDR      r2,[r0,#0x10]
00004e  f0220208          BIC      r2,r2,#8
000052  6102              STR      r2,[r0,#0x10]
                  |L6.84|
;;;587        }
;;;588    
;;;589        /* Disable RX threshold interrupt flag */
;;;590        if((u32Mask & QSPI_FIFO_RXTH_INT_MASK) == QSPI_FIFO_RXTH_INT_MASK)
000054  05ca              LSLS     r2,r1,#23
000056  d503              BPL      |L6.96|
;;;591        {
;;;592            qspi->FIFOCTL &= ~QSPI_FIFOCTL_RXTHIEN_Msk;
000058  6902              LDR      r2,[r0,#0x10]
00005a  f0220204          BIC      r2,r2,#4
00005e  6102              STR      r2,[r0,#0x10]
                  |L6.96|
;;;593        }
;;;594    
;;;595        /* Disable RX overrun interrupt flag */
;;;596        if((u32Mask & QSPI_FIFO_RXOV_INT_MASK) == QSPI_FIFO_RXOV_INT_MASK)
000060  058a              LSLS     r2,r1,#22
000062  d503              BPL      |L6.108|
;;;597        {
;;;598            qspi->FIFOCTL &= ~QSPI_FIFOCTL_RXOVIEN_Msk;
000064  6902              LDR      r2,[r0,#0x10]
000066  f0220220          BIC      r2,r2,#0x20
00006a  6102              STR      r2,[r0,#0x10]
                  |L6.108|
;;;599        }
;;;600    
;;;601        /* Disable RX time-out interrupt flag */
;;;602        if((u32Mask & QSPI_FIFO_RXTO_INT_MASK) == QSPI_FIFO_RXTO_INT_MASK)
00006c  0549              LSLS     r1,r1,#21
00006e  d503              BPL      |L6.120|
;;;603        {
;;;604            qspi->FIFOCTL &= ~QSPI_FIFOCTL_RXTOIEN_Msk;
000070  6901              LDR      r1,[r0,#0x10]
000072  f0210110          BIC      r1,r1,#0x10
000076  6101              STR      r1,[r0,#0x10]
                  |L6.120|
;;;605        }
;;;606    }
000078  4770              BX       lr
;;;607    
                          ENDP


                          AREA ||i.QSPI_EnableAutoSS||, CODE, READONLY, ALIGN=1

                  QSPI_EnableAutoSS PROC
;;;248      */
;;;249    void QSPI_EnableAutoSS(QSPI_T *qspi, uint32_t u32SSPinMask, uint32_t u32ActiveLevel)
000000  6883              LDR      r3,[r0,#8]
;;;250    {
;;;251        qspi->SSCTL = (qspi->SSCTL & (~(QSPI_SSCTL_AUTOSS_Msk | QSPI_SSCTL_SSACTPOL_Msk | QSPI_SSCTL_SS_Msk))) | (u32SSPinMask | u32ActiveLevel | QSPI_SSCTL_AUTOSS_Msk);
000002  4311              ORRS     r1,r1,r2
000004  f023030d          BIC      r3,r3,#0xd
000008  430b              ORRS     r3,r3,r1
00000a  f0430108          ORR      r1,r3,#8
00000e  6081              STR      r1,[r0,#8]
;;;252    }
000010  4770              BX       lr
;;;253    
                          ENDP


                          AREA ||i.QSPI_EnableInt||, CODE, READONLY, ALIGN=1

                  QSPI_EnableInt PROC
;;;461      */
;;;462    void QSPI_EnableInt(QSPI_T *qspi, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;463    {
000002  d003              BEQ      |L8.12|
;;;464        /* Enable unit transfer interrupt flag */
;;;465        if((u32Mask & QSPI_UNIT_INT_MASK) == QSPI_UNIT_INT_MASK)
;;;466        {
;;;467            qspi->CTL |= QSPI_CTL_UNITIEN_Msk;
000004  6802              LDR      r2,[r0,#0]
000006  f4423200          ORR      r2,r2,#0x20000
00000a  6002              STR      r2,[r0,#0]
                  |L8.12|
;;;468        }
;;;469    
;;;470        /* Enable slave selection signal active interrupt flag */
;;;471        if((u32Mask & QSPI_SSACT_INT_MASK) == QSPI_SSACT_INT_MASK)
00000c  078a              LSLS     r2,r1,#30
00000e  d503              BPL      |L8.24|
;;;472        {
;;;473            qspi->SSCTL |= QSPI_SSCTL_SSACTIEN_Msk;
000010  6882              LDR      r2,[r0,#8]
000012  f4425280          ORR      r2,r2,#0x1000
000016  6082              STR      r2,[r0,#8]
                  |L8.24|
;;;474        }
;;;475    
;;;476        /* Enable slave selection signal inactive interrupt flag */
;;;477        if((u32Mask & QSPI_SSINACT_INT_MASK) == QSPI_SSINACT_INT_MASK)
000018  074a              LSLS     r2,r1,#29
00001a  d503              BPL      |L8.36|
;;;478        {
;;;479            qspi->SSCTL |= QSPI_SSCTL_SSINAIEN_Msk;
00001c  6882              LDR      r2,[r0,#8]
00001e  f4425200          ORR      r2,r2,#0x2000
000022  6082              STR      r2,[r0,#8]
                  |L8.36|
;;;480        }
;;;481    
;;;482        /* Enable slave TX under run interrupt flag */
;;;483        if((u32Mask & QSPI_SLVUR_INT_MASK) == QSPI_SLVUR_INT_MASK)
000024  070a              LSLS     r2,r1,#28
000026  d503              BPL      |L8.48|
;;;484        {
;;;485            qspi->SSCTL |= QSPI_SSCTL_SLVURIEN_Msk;
000028  6882              LDR      r2,[r0,#8]
00002a  f4427200          ORR      r2,r2,#0x200
00002e  6082              STR      r2,[r0,#8]
                  |L8.48|
;;;486        }
;;;487    
;;;488        /* Enable slave bit count error interrupt flag */
;;;489        if((u32Mask & QSPI_SLVBE_INT_MASK) == QSPI_SLVBE_INT_MASK)
000030  06ca              LSLS     r2,r1,#27
000032  d503              BPL      |L8.60|
;;;490        {
;;;491            qspi->SSCTL |= QSPI_SSCTL_SLVBEIEN_Msk;
000034  6882              LDR      r2,[r0,#8]
000036  f4427280          ORR      r2,r2,#0x100
00003a  6082              STR      r2,[r0,#8]
                  |L8.60|
;;;492        }
;;;493    
;;;494        /* Enable slave TX underflow interrupt flag */
;;;495        if((u32Mask & QSPI_TXUF_INT_MASK) == QSPI_TXUF_INT_MASK)
00003c  064a              LSLS     r2,r1,#25
00003e  d503              BPL      |L8.72|
;;;496        {
;;;497            qspi->FIFOCTL |= QSPI_FIFOCTL_TXUFIEN_Msk;
000040  6902              LDR      r2,[r0,#0x10]
000042  f0420280          ORR      r2,r2,#0x80
000046  6102              STR      r2,[r0,#0x10]
                  |L8.72|
;;;498        }
;;;499    
;;;500        /* Enable TX threshold interrupt flag */
;;;501        if((u32Mask & QSPI_FIFO_TXTH_INT_MASK) == QSPI_FIFO_TXTH_INT_MASK)
000048  060a              LSLS     r2,r1,#24
00004a  d503              BPL      |L8.84|
;;;502        {
;;;503            qspi->FIFOCTL |= QSPI_FIFOCTL_TXTHIEN_Msk;
00004c  6902              LDR      r2,[r0,#0x10]
00004e  f0420208          ORR      r2,r2,#8
000052  6102              STR      r2,[r0,#0x10]
                  |L8.84|
;;;504        }
;;;505    
;;;506        /* Enable RX threshold interrupt flag */
;;;507        if((u32Mask & QSPI_FIFO_RXTH_INT_MASK) == QSPI_FIFO_RXTH_INT_MASK)
000054  05ca              LSLS     r2,r1,#23
000056  d503              BPL      |L8.96|
;;;508        {
;;;509            qspi->FIFOCTL |= QSPI_FIFOCTL_RXTHIEN_Msk;
000058  6902              LDR      r2,[r0,#0x10]
00005a  f0420204          ORR      r2,r2,#4
00005e  6102              STR      r2,[r0,#0x10]
                  |L8.96|
;;;510        }
;;;511    
;;;512        /* Enable RX overrun interrupt flag */
;;;513        if((u32Mask & QSPI_FIFO_RXOV_INT_MASK) == QSPI_FIFO_RXOV_INT_MASK)
000060  058a              LSLS     r2,r1,#22
000062  d503              BPL      |L8.108|
;;;514        {
;;;515            qspi->FIFOCTL |= QSPI_FIFOCTL_RXOVIEN_Msk;
000064  6902              LDR      r2,[r0,#0x10]
000066  f0420220          ORR      r2,r2,#0x20
00006a  6102              STR      r2,[r0,#0x10]
                  |L8.108|
;;;516        }
;;;517    
;;;518        /* Enable RX time-out interrupt flag */
;;;519        if((u32Mask & QSPI_FIFO_RXTO_INT_MASK) == QSPI_FIFO_RXTO_INT_MASK)
00006c  0549              LSLS     r1,r1,#21
00006e  d503              BPL      |L8.120|
;;;520        {
;;;521            qspi->FIFOCTL |= QSPI_FIFOCTL_RXTOIEN_Msk;
000070  6901              LDR      r1,[r0,#0x10]
000072  f0410110          ORR      r1,r1,#0x10
000076  6101              STR      r1,[r0,#0x10]
                  |L8.120|
;;;522        }
;;;523    }
000078  4770              BX       lr
;;;524    
                          ENDP


                          AREA ||i.QSPI_GetBusClock||, CODE, READONLY, ALIGN=2

                  QSPI_GetBusClock PROC
;;;387      */
;;;388    uint32_t QSPI_GetBusClock(QSPI_T *qspi)
000000  b570              PUSH     {r4-r6,lr}
;;;389    {
;;;390        uint32_t u32Div;
;;;391        uint32_t u32ClkSrc;
;;;392    
;;;393        /* Get DIVIDER setting */
;;;394        u32Div = (qspi->CLKDIV & QSPI_CLKDIV_DIVIDER_Msk) >> QSPI_CLKDIV_DIVIDER_Pos;
000002  6842              LDR      r2,[r0,#4]
;;;395    
;;;396        /* Check clock source of QSPI */
;;;397        if (qspi == QSPI0)
000004  4d1d              LDR      r5,|L9.124|
000006  f3c20408          UBFX     r4,r2,#0,#9           ;394
;;;398        {
;;;399            if((CLK->CLKSEL2 & CLK_CLKSEL2_QSPI0SEL_Msk) == CLK_CLKSEL2_QSPI0SEL_HXT)
;;;400            {
;;;401                u32ClkSrc = __HXT; /* Clock source is HXT */
00000a  4a1d              LDR      r2,|L9.128|
00000c  f04f4380          MOV      r3,#0x40000000        ;399
000010  42a8              CMP      r0,r5                 ;397
000012  d113              BNE      |L9.60|
000014  f8d30218          LDR      r0,[r3,#0x218]        ;399
000018  f0100f0c          TST      r0,#0xc               ;399
00001c  d022              BEQ      |L9.100|
;;;402            }
;;;403            else if((CLK->CLKSEL2 & CLK_CLKSEL2_QSPI0SEL_Msk) == CLK_CLKSEL2_QSPI0SEL_PLL)
00001e  f8d30218          LDR      r0,[r3,#0x218]
000022  f3c00081          UBFX     r0,r0,#2,#2
000026  2801              CMP      r0,#1
000028  d021              BEQ      |L9.110|
;;;404            {
;;;405                u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;406            }
;;;407            else if((CLK->CLKSEL2 & CLK_CLKSEL2_QSPI0SEL_Msk) == CLK_CLKSEL2_QSPI0SEL_PCLK0)
00002a  f8d30218          LDR      r0,[r3,#0x218]
00002e  f3c00081          UBFX     r0,r0,#2,#2
000032  2802              CMP      r0,#2
000034  d116              BNE      |L9.100|
;;;408            {
;;;409                /* Clock source is PCLK0 */
;;;410                u32ClkSrc = CLK_GetPCLK0Freq();
000036  f7fffffe          BL       CLK_GetPCLK0Freq
00003a  e014              B        |L9.102|
                  |L9.60|
;;;411            }
;;;412            else
;;;413            {
;;;414                u32ClkSrc = __HIRC; /* Clock source is HIRC */
;;;415            }
;;;416        }
;;;417        else if (qspi == QSPI1)
00003c  4d11              LDR      r5,|L9.132|
00003e  42a8              CMP      r0,r5
000040  d111              BNE      |L9.102|
;;;418        {
;;;419            if((CLK->CLKSEL3 & CLK_CLKSEL3_QSPI1SEL_Msk) == CLK_CLKSEL3_QSPI1SEL_HXT)
000042  f8d3021c          LDR      r0,[r3,#0x21c]
000046  f4105f40          TST      r0,#0x3000
00004a  d00b              BEQ      |L9.100|
;;;420            {
;;;421                u32ClkSrc = __HXT; /* Clock source is HXT */
;;;422            }
;;;423            else if((CLK->CLKSEL3 & CLK_CLKSEL3_QSPI1SEL_Msk) == CLK_CLKSEL3_QSPI1SEL_PLL)
00004c  f8d3021c          LDR      r0,[r3,#0x21c]
000050  f3c03001          UBFX     r0,r0,#12,#2
000054  2801              CMP      r0,#1
000056  d00a              BEQ      |L9.110|
;;;424            {
;;;425                u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;426            }
;;;427            else if((CLK->CLKSEL3 & CLK_CLKSEL3_QSPI1SEL_Msk) == CLK_CLKSEL3_QSPI1SEL_PCLK1)
000058  f8d3021c          LDR      r0,[r3,#0x21c]
00005c  f3c03001          UBFX     r0,r0,#12,#2
000060  2802              CMP      r0,#2
000062  d007              BEQ      |L9.116|
                  |L9.100|
;;;428            {
;;;429                /* Clock source is PCLK1 */
;;;430                u32ClkSrc = CLK_GetPCLK1Freq();
;;;431            }
;;;432            else
;;;433            {
;;;434                u32ClkSrc = __HIRC; /* Clock source is HIRC */
000064  4610              MOV      r0,r2
                  |L9.102|
000066  1c64              ADDS     r4,r4,#1
;;;435            }
;;;436        }
;;;437    
;;;438        /* Return QSPI bus clock rate */
;;;439        return (u32ClkSrc / (u32Div + 1U));
000068  fbb0f0f4          UDIV     r0,r0,r4
;;;440    }
00006c  bd70              POP      {r4-r6,pc}
                  |L9.110|
00006e  f7fffffe          BL       CLK_GetPLLClockFreq
000072  e7f8              B        |L9.102|
                  |L9.116|
000074  f7fffffe          BL       CLK_GetPCLK1Freq
000078  e7f5              B        |L9.102|
;;;441    
                          ENDP

00007a  0000              DCW      0x0000
                  |L9.124|
                          DCD      0x40060000
                  |L9.128|
                          DCD      0x00b71b00
                  |L9.132|
                          DCD      0x40069000

                          AREA ||i.QSPI_GetIntFlag||, CODE, READONLY, ALIGN=1

                  QSPI_GetIntFlag PROC
;;;627      */
;;;628    uint32_t QSPI_GetIntFlag(QSPI_T *qspi, uint32_t u32Mask)
000000  b510              PUSH     {r4,lr}
;;;629    {
000002  4602              MOV      r2,r0
;;;630        uint32_t u32IntFlag = 0U, u32TmpVal;
000004  2000              MOVS     r0,#0
;;;631    
;;;632        u32TmpVal = qspi->STATUS & QSPI_STATUS_UNITIF_Msk;
000006  6953              LDR      r3,[r2,#0x14]
;;;633        /* Check unit transfer interrupt flag */
;;;634        if((u32Mask & QSPI_UNIT_INT_MASK) && (u32TmpVal))
000008  07cc              LSLS     r4,r1,#31
00000a  f0030302          AND      r3,r3,#2              ;632
00000e  d001              BEQ      |L10.20|
000010  b103              CBZ      r3,|L10.20|
;;;635        {
;;;636            u32IntFlag |= QSPI_UNIT_INT_MASK;
000012  2001              MOVS     r0,#1
                  |L10.20|
;;;637        }
;;;638    
;;;639        u32TmpVal = qspi->STATUS & QSPI_STATUS_SSACTIF_Msk;
000014  6953              LDR      r3,[r2,#0x14]
;;;640        /* Check slave selection signal active interrupt flag */
;;;641        if((u32Mask & QSPI_SSACT_INT_MASK) && (u32TmpVal))
000016  078c              LSLS     r4,r1,#30
000018  f0030304          AND      r3,r3,#4              ;639
00001c  d502              BPL      |L10.36|
00001e  b10b              CBZ      r3,|L10.36|
;;;642        {
;;;643            u32IntFlag |= QSPI_SSACT_INT_MASK;
000020  f0400002          ORR      r0,r0,#2
                  |L10.36|
;;;644        }
;;;645    
;;;646        u32TmpVal = qspi->STATUS & QSPI_STATUS_SSINAIF_Msk;
000024  6953              LDR      r3,[r2,#0x14]
;;;647        /* Check slave selection signal inactive interrupt flag */
;;;648        if((u32Mask & QSPI_SSINACT_INT_MASK) && (u32TmpVal))
000026  074c              LSLS     r4,r1,#29
000028  f0030308          AND      r3,r3,#8              ;646
00002c  d502              BPL      |L10.52|
00002e  b10b              CBZ      r3,|L10.52|
;;;649        {
;;;650            u32IntFlag |= QSPI_SSINACT_INT_MASK;
000030  f0400004          ORR      r0,r0,#4
                  |L10.52|
;;;651        }
;;;652    
;;;653        u32TmpVal = qspi->STATUS & QSPI_STATUS_SLVURIF_Msk;
000034  6953              LDR      r3,[r2,#0x14]
;;;654        /* Check slave TX under run interrupt flag */
;;;655        if((u32Mask & QSPI_SLVUR_INT_MASK) && (u32TmpVal))
000036  070c              LSLS     r4,r1,#28
000038  f0030380          AND      r3,r3,#0x80           ;653
00003c  d502              BPL      |L10.68|
00003e  b10b              CBZ      r3,|L10.68|
;;;656        {
;;;657            u32IntFlag |= QSPI_SLVUR_INT_MASK;
000040  f0400008          ORR      r0,r0,#8
                  |L10.68|
;;;658        }
;;;659    
;;;660        u32TmpVal = qspi->STATUS & QSPI_STATUS_SLVBEIF_Msk;
000044  6953              LDR      r3,[r2,#0x14]
;;;661        /* Check slave bit count error interrupt flag */
;;;662        if((u32Mask & QSPI_SLVBE_INT_MASK) && (u32TmpVal))
000046  06cc              LSLS     r4,r1,#27
000048  f0030340          AND      r3,r3,#0x40           ;660
00004c  d502              BPL      |L10.84|
00004e  b10b              CBZ      r3,|L10.84|
;;;663        {
;;;664            u32IntFlag |= QSPI_SLVBE_INT_MASK;
000050  f0400010          ORR      r0,r0,#0x10
                  |L10.84|
;;;665        }
;;;666    
;;;667        u32TmpVal = qspi->STATUS & QSPI_STATUS_TXUFIF_Msk;
000054  6953              LDR      r3,[r2,#0x14]
;;;668        /* Check slave TX underflow interrupt flag */
;;;669        if((u32Mask & QSPI_TXUF_INT_MASK) && (u32TmpVal))
000056  064c              LSLS     r4,r1,#25
000058  f4032300          AND      r3,r3,#0x80000        ;667
00005c  d502              BPL      |L10.100|
00005e  b10b              CBZ      r3,|L10.100|
;;;670        {
;;;671            u32IntFlag |= QSPI_TXUF_INT_MASK;
000060  f0400040          ORR      r0,r0,#0x40
                  |L10.100|
;;;672        }
;;;673    
;;;674        u32TmpVal = qspi->STATUS & QSPI_STATUS_TXTHIF_Msk;
000064  6953              LDR      r3,[r2,#0x14]
;;;675        /* Check TX threshold interrupt flag */
;;;676        if((u32Mask & QSPI_FIFO_TXTH_INT_MASK) && (u32TmpVal))
000066  060c              LSLS     r4,r1,#24
000068  f4032380          AND      r3,r3,#0x40000        ;674
00006c  d502              BPL      |L10.116|
00006e  b10b              CBZ      r3,|L10.116|
;;;677        {
;;;678            u32IntFlag |= QSPI_FIFO_TXTH_INT_MASK;
000070  f0400080          ORR      r0,r0,#0x80
                  |L10.116|
;;;679        }
;;;680    
;;;681        u32TmpVal = qspi->STATUS & QSPI_STATUS_RXTHIF_Msk;
000074  6953              LDR      r3,[r2,#0x14]
;;;682        /* Check RX threshold interrupt flag */
;;;683        if((u32Mask & QSPI_FIFO_RXTH_INT_MASK) && (u32TmpVal))
000076  05cc              LSLS     r4,r1,#23
000078  f4036380          AND      r3,r3,#0x400          ;681
00007c  d502              BPL      |L10.132|
00007e  b10b              CBZ      r3,|L10.132|
;;;684        {
;;;685            u32IntFlag |= QSPI_FIFO_RXTH_INT_MASK;
000080  f4407080          ORR      r0,r0,#0x100
                  |L10.132|
;;;686        }
;;;687    
;;;688        u32TmpVal = qspi->STATUS & QSPI_STATUS_RXOVIF_Msk;
000084  6953              LDR      r3,[r2,#0x14]
;;;689        /* Check RX overrun interrupt flag */
;;;690        if((u32Mask & QSPI_FIFO_RXOV_INT_MASK) && (u32TmpVal))
000086  058c              LSLS     r4,r1,#22
000088  f4036300          AND      r3,r3,#0x800          ;688
00008c  d502              BPL      |L10.148|
00008e  b10b              CBZ      r3,|L10.148|
;;;691        {
;;;692            u32IntFlag |= QSPI_FIFO_RXOV_INT_MASK;
000090  f4407000          ORR      r0,r0,#0x200
                  |L10.148|
;;;693        }
;;;694    
;;;695        u32TmpVal = qspi->STATUS & QSPI_STATUS_RXTOIF_Msk;
000094  6952              LDR      r2,[r2,#0x14]
;;;696        /* Check RX time-out interrupt flag */
;;;697        if((u32Mask & QSPI_FIFO_RXTO_INT_MASK) && (u32TmpVal))
000096  0549              LSLS     r1,r1,#21
000098  f4025280          AND      r2,r2,#0x1000         ;695
00009c  d503              BPL      |L10.166|
00009e  2a00              CMP      r2,#0
0000a0  d001              BEQ      |L10.166|
;;;698        {
;;;699            u32IntFlag |= QSPI_FIFO_RXTO_INT_MASK;
0000a2  f4406080          ORR      r0,r0,#0x400
                  |L10.166|
;;;700        }
;;;701    
;;;702        return u32IntFlag;
;;;703    }
0000a6  bd10              POP      {r4,pc}
;;;704    
                          ENDP


                          AREA ||i.QSPI_GetStatus||, CODE, READONLY, ALIGN=1

                  QSPI_GetStatus PROC
;;;783      */
;;;784    uint32_t QSPI_GetStatus(QSPI_T *qspi, uint32_t u32Mask)
000000  b510              PUSH     {r4,lr}
;;;785    {
000002  4602              MOV      r2,r0
;;;786        uint32_t u32Flag = 0U, u32TmpValue;
000004  2000              MOVS     r0,#0
;;;787    
;;;788        u32TmpValue = qspi->STATUS & QSPI_STATUS_BUSY_Msk;
000006  6953              LDR      r3,[r2,#0x14]
;;;789        /* Check busy status */
;;;790        if((u32Mask & QSPI_BUSY_MASK) && (u32TmpValue))
000008  07cc              LSLS     r4,r1,#31
00000a  f0030301          AND      r3,r3,#1              ;788
00000e  d001              BEQ      |L11.20|
000010  b103              CBZ      r3,|L11.20|
;;;791        {
;;;792            u32Flag |= QSPI_BUSY_MASK;
000012  2001              MOVS     r0,#1
                  |L11.20|
;;;793        }
;;;794    
;;;795        u32TmpValue = qspi->STATUS & QSPI_STATUS_RXEMPTY_Msk;
000014  6953              LDR      r3,[r2,#0x14]
;;;796        /* Check RX empty flag */
;;;797        if((u32Mask & QSPI_RX_EMPTY_MASK) && (u32TmpValue))
000016  078c              LSLS     r4,r1,#30
000018  f4037380          AND      r3,r3,#0x100          ;795
00001c  d502              BPL      |L11.36|
00001e  b10b              CBZ      r3,|L11.36|
;;;798        {
;;;799            u32Flag |= QSPI_RX_EMPTY_MASK;
000020  f0400002          ORR      r0,r0,#2
                  |L11.36|
;;;800        }
;;;801    
;;;802        u32TmpValue = qspi->STATUS & QSPI_STATUS_RXFULL_Msk;
000024  6953              LDR      r3,[r2,#0x14]
;;;803        /* Check RX full flag */
;;;804        if((u32Mask & QSPI_RX_FULL_MASK) && (u32TmpValue))
000026  074c              LSLS     r4,r1,#29
000028  f4037300          AND      r3,r3,#0x200          ;802
00002c  d502              BPL      |L11.52|
00002e  b10b              CBZ      r3,|L11.52|
;;;805        {
;;;806            u32Flag |= QSPI_RX_FULL_MASK;
000030  f0400004          ORR      r0,r0,#4
                  |L11.52|
;;;807        }
;;;808    
;;;809        u32TmpValue = qspi->STATUS & QSPI_STATUS_TXEMPTY_Msk;
000034  6953              LDR      r3,[r2,#0x14]
;;;810        /* Check TX empty flag */
;;;811        if((u32Mask & QSPI_TX_EMPTY_MASK) && (u32TmpValue))
000036  070c              LSLS     r4,r1,#28
000038  f4033380          AND      r3,r3,#0x10000        ;809
00003c  d502              BPL      |L11.68|
00003e  b10b              CBZ      r3,|L11.68|
;;;812        {
;;;813            u32Flag |= QSPI_TX_EMPTY_MASK;
000040  f0400008          ORR      r0,r0,#8
                  |L11.68|
;;;814        }
;;;815    
;;;816        u32TmpValue = qspi->STATUS & QSPI_STATUS_TXFULL_Msk;
000044  6953              LDR      r3,[r2,#0x14]
;;;817        /* Check TX full flag */
;;;818        if((u32Mask & QSPI_TX_FULL_MASK) && (u32TmpValue))
000046  06cc              LSLS     r4,r1,#27
000048  f4033300          AND      r3,r3,#0x20000        ;816
00004c  d502              BPL      |L11.84|
00004e  b10b              CBZ      r3,|L11.84|
;;;819        {
;;;820            u32Flag |= QSPI_TX_FULL_MASK;
000050  f0400010          ORR      r0,r0,#0x10
                  |L11.84|
;;;821        }
;;;822    
;;;823        u32TmpValue = qspi->STATUS & QSPI_STATUS_TXRXRST_Msk;
000054  6953              LDR      r3,[r2,#0x14]
;;;824        /* Check TX/RX reset flag */
;;;825        if((u32Mask & QSPI_TXRX_RESET_MASK) && (u32TmpValue))
000056  068c              LSLS     r4,r1,#26
000058  f4030300          AND      r3,r3,#0x800000       ;823
00005c  d502              BPL      |L11.100|
00005e  b10b              CBZ      r3,|L11.100|
;;;826        {
;;;827            u32Flag |= QSPI_TXRX_RESET_MASK;
000060  f0400020          ORR      r0,r0,#0x20
                  |L11.100|
;;;828        }
;;;829    
;;;830        u32TmpValue = qspi->STATUS & QSPI_STATUS_QSPIENSTS_Msk;
000064  6953              LDR      r3,[r2,#0x14]
;;;831        /* Check QSPIEN flag */
;;;832        if((u32Mask & QSPI_QSPIEN_STS_MASK) && (u32TmpValue))
000066  064c              LSLS     r4,r1,#25
000068  f4034300          AND      r3,r3,#0x8000         ;830
00006c  d502              BPL      |L11.116|
00006e  b10b              CBZ      r3,|L11.116|
;;;833        {
;;;834            u32Flag |= QSPI_QSPIEN_STS_MASK;
000070  f0400040          ORR      r0,r0,#0x40
                  |L11.116|
;;;835        }
;;;836    
;;;837        u32TmpValue = qspi->STATUS & QSPI_STATUS_SSLINE_Msk;
000074  6952              LDR      r2,[r2,#0x14]
;;;838        /* Check QSPIx_SS line status */
;;;839        if((u32Mask & QSPI_SSLINE_STS_MASK) && (u32TmpValue))
000076  0609              LSLS     r1,r1,#24
000078  f0020210          AND      r2,r2,#0x10           ;837
00007c  d503              BPL      |L11.134|
00007e  2a00              CMP      r2,#0
000080  d001              BEQ      |L11.134|
;;;840        {
;;;841            u32Flag |= QSPI_SSLINE_STS_MASK;
000082  f0400080          ORR      r0,r0,#0x80
                  |L11.134|
;;;842        }
;;;843    
;;;844        return u32Flag;
;;;845    }
000086  bd10              POP      {r4,pc}
;;;846    
                          ENDP


                          AREA ||i.QSPI_Open||, CODE, READONLY, ALIGN=2

                  QSPI_Open PROC
;;;41       */
;;;42     uint32_t QSPI_Open(QSPI_T *qspi,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;43                        uint32_t u32MasterSlave,
;;;44                        uint32_t u32QSPIMode,
;;;45                        uint32_t u32DataWidth,
;;;46                        uint32_t u32BusClock)
;;;47     {
;;;48         uint32_t u32ClkSrc = 0U, u32Div, u32HCLKFreq, u32RetValue=0U;
000004  2500              MOVS     r5,#0
;;;49     
;;;50         if(u32DataWidth == 32U)
000006  9f0e              LDR      r7,[sp,#0x38]
000008  4699              MOV      r9,r3                 ;47
00000a  468b              MOV      r11,r1                ;47
00000c  4604              MOV      r4,r0                 ;47
00000e  462e              MOV      r6,r5                 ;48
000010  2b20              CMP      r3,#0x20
000012  d101              BNE      |L12.24|
;;;51         {
;;;52             u32DataWidth = 0U;
000014  f04f0900          MOV      r9,#0
                  |L12.24|
;;;53         }
;;;54     
;;;55         /* Get system clock frequency */
;;;56         u32HCLKFreq = CLK_GetHCLKFreq();
000018  f7fffffe          BL       CLK_GetHCLKFreq
;;;57     
;;;58         if(u32MasterSlave == QSPI_MASTER)
;;;59         {
;;;60             /* Default setting: slave selection signal is active low; disable automatic slave selection function. */
;;;61             qspi->SSCTL = QSPI_SS_ACTIVE_LOW;
;;;62     
;;;63             /* Default setting: MSB first, disable unit transfer interrupt, SP_CYCLE = 0. */
;;;64             qspi->CTL = u32MasterSlave | (u32DataWidth << QSPI_CTL_DWIDTH_Pos) | (u32QSPIMode) | QSPI_CTL_QSPIEN_Msk;
;;;65     
;;;66             if(u32BusClock >= u32HCLKFreq)
;;;67             {
;;;68                 /* Select PCLK as the clock source of QSPI */
;;;69                 if (qspi == QSPI0)
;;;70                     CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_QSPI0SEL_Msk)) | CLK_CLKSEL2_QSPI0SEL_PCLK0;
;;;71                 else if (qspi == QSPI1)
00001c  4a55              LDR      r2,|L12.372|
00001e  4682              MOV      r10,r0                ;56
000020  f04f0800          MOV      r8,#0                 ;56
000024  4b52              LDR      r3,|L12.368|
000026  0490              LSLS     r0,r2,#18             ;70
000028  f1bb0f00          CMP      r11,#0                ;58
;;;72                     CLK->CLKSEL3 = (CLK->CLKSEL3 & (~CLK_CLKSEL3_QSPI1SEL_Msk)) | CLK_CLKSEL3_QSPI1SEL_PCLK1;
;;;73             }
;;;74     
;;;75             /* Check clock source of QSPI */
;;;76             if (qspi == QSPI0)
;;;77             {
;;;78                 if((CLK->CLKSEL2 & CLK_CLKSEL2_QSPI0SEL_Msk) == CLK_CLKSEL2_QSPI0SEL_HXT)
;;;79                 {
;;;80                     u32ClkSrc = __HXT; /* Clock source is HXT */
;;;81                 }
;;;82                 else if((CLK->CLKSEL2 & CLK_CLKSEL2_QSPI0SEL_Msk) == CLK_CLKSEL2_QSPI0SEL_PLL)
;;;83                 {
;;;84                     u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;85                 }
;;;86                 else if((CLK->CLKSEL2 & CLK_CLKSEL2_QSPI0SEL_Msk) == CLK_CLKSEL2_QSPI0SEL_PCLK0)
;;;87                 {
;;;88                     /* Clock source is PCLK0 */
;;;89                     u32ClkSrc = CLK_GetPCLK0Freq();
;;;90                 }
;;;91                 else
;;;92                 {
;;;93                     u32ClkSrc = __HIRC; /* Clock source is HIRC */
;;;94                 }
;;;95             }
;;;96             else if (qspi == QSPI1)
;;;97             {
;;;98                 if((CLK->CLKSEL3 & CLK_CLKSEL3_QSPI1SEL_Msk) == CLK_CLKSEL3_QSPI1SEL_HXT)
;;;99                 {
;;;100                    u32ClkSrc = __HXT; /* Clock source is HXT */
;;;101                }
;;;102                else if((CLK->CLKSEL3 & CLK_CLKSEL3_QSPI1SEL_Msk) == CLK_CLKSEL3_QSPI1SEL_PLL)
;;;103                {
;;;104                    u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;105                }
;;;106                else if((CLK->CLKSEL3 & CLK_CLKSEL3_QSPI1SEL_Msk) == CLK_CLKSEL3_QSPI1SEL_PCLK1)
;;;107                {
;;;108                    /* Clock source is PCLK1 */
;;;109                    u32ClkSrc = CLK_GetPCLK1Freq();
;;;110                }
;;;111                else
;;;112                {
;;;113                    u32ClkSrc = __HIRC; /* Clock source is HIRC */
;;;114                }
;;;115            }
;;;116    
;;;117            if(u32BusClock >= u32HCLKFreq)
;;;118            {
;;;119                /* Set DIVIDER = 0 */
;;;120                qspi->CLKDIV = 0U;
;;;121                /* Return master peripheral clock rate */
;;;122                u32RetValue = u32ClkSrc;
;;;123            }
;;;124            else if(u32BusClock >= u32ClkSrc)
;;;125            {
;;;126                /* Set DIVIDER = 0 */
;;;127                qspi->CLKDIV = 0U;
;;;128                /* Return master peripheral clock rate */
;;;129                u32RetValue = u32ClkSrc;
;;;130            }
;;;131            else if(u32BusClock == 0U)
;;;132            {
;;;133                /* Set DIVIDER to the maximum value 0xFF. f_qspi = f_qspi_clk_src / (DIVIDER + 1) */
;;;134                qspi->CLKDIV |= QSPI_CLKDIV_DIVIDER_Msk;
;;;135                /* Return master peripheral clock rate */
;;;136                u32RetValue = (u32ClkSrc / (0xFFU + 1U));
;;;137            }
;;;138            else
;;;139            {
;;;140                u32Div = (((u32ClkSrc * 10U) / u32BusClock + 5U) / 10U) - 1U; /* Round to the nearest integer */
;;;141                if(u32Div > 0xFFU)
;;;142                {
;;;143                    u32Div = 0xFFU;
;;;144                    qspi->CLKDIV |= QSPI_CLKDIV_DIVIDER_Msk;
;;;145                    /* Return master peripheral clock rate */
;;;146                    u32RetValue = (u32ClkSrc / (0xFFU + 1U));
;;;147                }
;;;148                else
;;;149                {
;;;150                    qspi->CLKDIV = (qspi->CLKDIV & (~QSPI_CLKDIV_DIVIDER_Msk)) | (u32Div << QSPI_CLKDIV_DIVIDER_Pos);
;;;151                    /* Return master peripheral clock rate */
;;;152                    u32RetValue = (u32ClkSrc / (u32Div + 1U));
;;;153                }
;;;154            }
;;;155        }
;;;156        else     /* For slave mode, force the QSPI peripheral clock rate to equal APB clock rate. */
;;;157        {
;;;158            /* Default setting: slave selection signal is low level active. */
;;;159            qspi->SSCTL = QSPI_SS_ACTIVE_LOW;
00002c  f8c48008          STR      r8,[r4,#8]
000030  d015              BEQ      |L12.94|
;;;160    
;;;161            /* Default setting: MSB first, disable unit transfer interrupt, SP_CYCLE = 0. */
;;;162            qspi->CTL = u32MasterSlave | (u32DataWidth << QSPI_CTL_DWIDTH_Pos) | (u32QSPIMode) | QSPI_CTL_QSPIEN_Msk;
000032  9d02              LDR      r5,[sp,#8]
000034  ea4b2109          ORR      r1,r11,r9,LSL #8
000038  4329              ORRS     r1,r1,r5
00003a  f0410101          ORR      r1,r1,#1
00003e  6021              STR      r1,[r4,#0]
;;;163    
;;;164            /* Set DIVIDER = 0 */
;;;165            qspi->CLKDIV = 0U;
000040  f8c48004          STR      r8,[r4,#4]
;;;166    
;;;167            /* Select PCLK as the clock source of QSPI */
;;;168            if (qspi == QSPI0)
000044  429c              CMP      r4,r3
000046  d177              BNE      |L12.312|
;;;169            {
;;;170                CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_QSPI0SEL_Msk)) | CLK_CLKSEL2_QSPI0SEL_PCLK0;
000048  f8d01218          LDR      r1,[r0,#0x218]
00004c  f021010c          BIC      r1,r1,#0xc
000050  f0410108          ORR      r1,r1,#8
000054  f8c01218          STR      r1,[r0,#0x218]
;;;171                /* Return slave peripheral clock rate */
;;;172                u32RetValue = CLK_GetPCLK0Freq();
000058  f7fffffe          BL       CLK_GetPCLK0Freq
00005c  e082              B        |L12.356|
                  |L12.94|
00005e  9e02              LDR      r6,[sp,#8]            ;64
000060  ea482109          ORR      r1,r8,r9,LSL #8       ;64
000064  4331              ORRS     r1,r1,r6              ;64
000066  f0410101          ORR      r1,r1,#1              ;64
00006a  6021              STR      r1,[r4,#0]            ;64
00006c  4557              CMP      r7,r10                ;66
00006e  d314              BCC      |L12.154|
000070  429c              CMP      r4,r3                 ;69
000072  d108              BNE      |L12.134|
000074  f8d01218          LDR      r1,[r0,#0x218]        ;70
000078  f021010c          BIC      r1,r1,#0xc            ;70
00007c  f0410108          ORR      r1,r1,#8              ;70
000080  f8c01218          STR      r1,[r0,#0x218]        ;70
000084  e009              B        |L12.154|
                  |L12.134|
000086  4294              CMP      r4,r2                 ;71
000088  d107              BNE      |L12.154|
00008a  f8d0121c          LDR      r1,[r0,#0x21c]        ;72
00008e  f4215140          BIC      r1,r1,#0x3000         ;72
000092  f4415100          ORR      r1,r1,#0x2000         ;72
000096  f8c0121c          STR      r1,[r0,#0x21c]        ;72
                  |L12.154|
00009a  4937              LDR      r1,|L12.376|
00009c  429c              CMP      r4,r3                 ;76
00009e  d117              BNE      |L12.208|
0000a0  f8d02218          LDR      r2,[r0,#0x218]        ;78
0000a4  f0120f0c          TST      r2,#0xc               ;78
0000a8  d025              BEQ      |L12.246|
0000aa  f8d02218          LDR      r2,[r0,#0x218]        ;82
0000ae  f3c20281          UBFX     r2,r2,#2,#2           ;82
0000b2  2a01              CMP      r2,#1                 ;82
0000b4  d006              BEQ      |L12.196|
0000b6  f8d00218          LDR      r0,[r0,#0x218]        ;86
0000ba  f3c00081          UBFX     r0,r0,#2,#2           ;86
0000be  2802              CMP      r0,#2                 ;86
0000c0  d003              BEQ      |L12.202|
0000c2  e018              B        |L12.246|
                  |L12.196|
0000c4  f7fffffe          BL       CLK_GetPLLClockFreq
0000c8  e020              B        |L12.268|
                  |L12.202|
0000ca  f7fffffe          BL       CLK_GetPCLK0Freq
0000ce  e01d              B        |L12.268|
                  |L12.208|
0000d0  4294              CMP      r4,r2                 ;96
0000d2  d111              BNE      |L12.248|
0000d4  f8d0221c          LDR      r2,[r0,#0x21c]        ;98
0000d8  f4125f40          TST      r2,#0x3000            ;98
0000dc  d00b              BEQ      |L12.246|
0000de  f8d0221c          LDR      r2,[r0,#0x21c]        ;102
0000e2  f3c23201          UBFX     r2,r2,#12,#2          ;102
0000e6  2a01              CMP      r2,#1                 ;102
0000e8  d0ec              BEQ      |L12.196|
0000ea  f8d0021c          LDR      r0,[r0,#0x21c]        ;106
0000ee  f3c03001          UBFX     r0,r0,#12,#2          ;106
0000f2  2802              CMP      r0,#2                 ;106
0000f4  d008              BEQ      |L12.264|
                  |L12.246|
0000f6  460d              MOV      r5,r1                 ;113
                  |L12.248|
0000f8  4557              CMP      r7,r10                ;117
0000fa  d201              BCS      |L12.256|
0000fc  42af              CMP      r7,r5                 ;124
0000fe  d307              BCC      |L12.272|
                  |L12.256|
000100  f8c48004          STR      r8,[r4,#4]            ;127
000104  462e              MOV      r6,r5                 ;129
000106  e02e              B        |L12.358|
                  |L12.264|
000108  f7fffffe          BL       CLK_GetPCLK1Freq
                  |L12.268|
00010c  4605              MOV      r5,r0                 ;109
00010e  e7f3              B        |L12.248|
                  |L12.272|
000110  f24011ff          MOV      r1,#0x1ff             ;134
000114  b15f              CBZ      r7,|L12.302|
000116  eb050085          ADD      r0,r5,r5,LSL #2       ;140
00011a  0040              LSLS     r0,r0,#1              ;140
00011c  fbb0f0f7          UDIV     r0,r0,r7              ;140
000120  220a              MOVS     r2,#0xa               ;140
000122  1d40              ADDS     r0,r0,#5              ;140
000124  fbb0f0f2          UDIV     r0,r0,r2              ;140
000128  1e40              SUBS     r0,r0,#1              ;140
00012a  28ff              CMP      r0,#0xff              ;141
00012c  d905              BLS      |L12.314|
                  |L12.302|
00012e  6860              LDR      r0,[r4,#4]            ;144
000130  4308              ORRS     r0,r0,r1              ;144
000132  6060              STR      r0,[r4,#4]            ;144
000134  0a2e              LSRS     r6,r5,#8              ;146
000136  e016              B        |L12.358|
                  |L12.312|
000138  e008              B        |L12.332|
                  |L12.314|
00013a  6861              LDR      r1,[r4,#4]            ;150
00013c  f36f0108          BFC      r1,#0,#9              ;150
000140  4301              ORRS     r1,r1,r0              ;150
000142  6061              STR      r1,[r4,#4]            ;150
000144  1c40              ADDS     r0,r0,#1              ;150
000146  fbb5f6f0          UDIV     r6,r5,r0              ;152
00014a  e00c              B        |L12.358|
                  |L12.332|
;;;173            }
;;;174            else if (qspi == QSPI1)
00014c  4294              CMP      r4,r2
00014e  d10a              BNE      |L12.358|
;;;175            {
;;;176                CLK->CLKSEL3 = (CLK->CLKSEL3 & (~CLK_CLKSEL3_QSPI1SEL_Msk)) | CLK_CLKSEL3_QSPI1SEL_PCLK1;
000150  f8d0121c          LDR      r1,[r0,#0x21c]
000154  f4215140          BIC      r1,r1,#0x3000
000158  f4415100          ORR      r1,r1,#0x2000
00015c  f8c0121c          STR      r1,[r0,#0x21c]
;;;177                /* Return slave peripheral clock rate */
;;;178                u32RetValue = CLK_GetPCLK1Freq();
000160  f7fffffe          BL       CLK_GetPCLK1Freq
                  |L12.356|
000164  4606              MOV      r6,r0
                  |L12.358|
;;;179            }
;;;180        }
;;;181    
;;;182        return u32RetValue;
;;;183    }
000166  b004              ADD      sp,sp,#0x10
000168  4630              MOV      r0,r6                 ;182
00016a  e8bd9ff0          POP      {r4-r12,pc}
;;;184    
                          ENDP

00016e  0000              DCW      0x0000
                  |L12.368|
                          DCD      0x40060000
                  |L12.372|
                          DCD      0x40069000
                  |L12.376|
                          DCD      0x00b71b00

                          AREA ||i.QSPI_SetBusClock||, CODE, READONLY, ALIGN=2

                  QSPI_SetBusClock PROC
;;;265      */
;;;266    uint32_t QSPI_SetBusClock(QSPI_T *qspi, uint32_t u32BusClock)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;267    {
000004  460e              MOV      r6,r1
000006  4604              MOV      r4,r0
;;;268        uint32_t u32ClkSrc, u32HCLKFreq;
;;;269        uint32_t u32Div, u32RetValue;
;;;270    
;;;271        /* Get system clock frequency */
;;;272        u32HCLKFreq = CLK_GetHCLKFreq();
000008  f7fffffe          BL       CLK_GetHCLKFreq
;;;273    
;;;274        if(u32BusClock >= u32HCLKFreq)
;;;275        {
;;;276            /* Select PCLK as the clock source of QSPI */
;;;277            if (qspi == QSPI0)
;;;278                CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_QSPI0SEL_Msk)) | CLK_CLKSEL2_QSPI0SEL_PCLK0;
;;;279            else if (qspi == QSPI1)
00000c  4a3b              LDR      r2,|L13.252|
00000e  4607              MOV      r7,r0                 ;272
000010  4b39              LDR      r3,|L13.248|
000012  0490              LSLS     r0,r2,#18             ;278
000014  42be              CMP      r6,r7                 ;274
000016  d314              BCC      |L13.66|
000018  429c              CMP      r4,r3                 ;277
00001a  d108              BNE      |L13.46|
00001c  f8d01218          LDR      r1,[r0,#0x218]        ;278
000020  f021010c          BIC      r1,r1,#0xc            ;278
000024  f0410108          ORR      r1,r1,#8              ;278
000028  f8c01218          STR      r1,[r0,#0x218]        ;278
00002c  e009              B        |L13.66|
                  |L13.46|
00002e  4294              CMP      r4,r2
000030  d107              BNE      |L13.66|
;;;280                CLK->CLKSEL3 = (CLK->CLKSEL3 & (~CLK_CLKSEL3_QSPI1SEL_Msk)) | CLK_CLKSEL3_QSPI1SEL_PCLK1;
000032  f8d0121c          LDR      r1,[r0,#0x21c]
000036  f4215140          BIC      r1,r1,#0x3000
00003a  f4415100          ORR      r1,r1,#0x2000
00003e  f8c0121c          STR      r1,[r0,#0x21c]
                  |L13.66|
;;;281        }
;;;282    
;;;283        /* Check clock source of QSPI */
;;;284        if (qspi == QSPI0)
;;;285        {
;;;286            if((CLK->CLKSEL2 & CLK_CLKSEL2_QSPI0SEL_Msk) == CLK_CLKSEL2_QSPI0SEL_HXT)
;;;287            {
;;;288                u32ClkSrc = __HXT; /* Clock source is HXT */
000042  492f              LDR      r1,|L13.256|
000044  429c              CMP      r4,r3                 ;284
000046  d117              BNE      |L13.120|
000048  f8d02218          LDR      r2,[r0,#0x218]        ;286
00004c  f0120f0c          TST      r2,#0xc               ;286
000050  d025              BEQ      |L13.158|
;;;289            }
;;;290            else if((CLK->CLKSEL2 & CLK_CLKSEL2_QSPI0SEL_Msk) == CLK_CLKSEL2_QSPI0SEL_PLL)
000052  f8d02218          LDR      r2,[r0,#0x218]
000056  f3c20281          UBFX     r2,r2,#2,#2
00005a  2a01              CMP      r2,#1
00005c  d006              BEQ      |L13.108|
;;;291            {
;;;292                u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;293            }
;;;294            else if((CLK->CLKSEL2 & CLK_CLKSEL2_QSPI0SEL_Msk) == CLK_CLKSEL2_QSPI0SEL_PCLK0)
00005e  f8d00218          LDR      r0,[r0,#0x218]
000062  f3c00081          UBFX     r0,r0,#2,#2
000066  2802              CMP      r0,#2
000068  d003              BEQ      |L13.114|
00006a  e018              B        |L13.158|
                  |L13.108|
00006c  f7fffffe          BL       CLK_GetPLLClockFreq
000070  e021              B        |L13.182|
                  |L13.114|
;;;295            {
;;;296                /* Clock source is PCLK0 */
;;;297                u32ClkSrc = CLK_GetPCLK0Freq();
000072  f7fffffe          BL       CLK_GetPCLK0Freq
000076  e01e              B        |L13.182|
                  |L13.120|
;;;298            }
;;;299            else
;;;300            {
;;;301                u32ClkSrc = __HIRC; /* Clock source is HIRC */
;;;302            }
;;;303        }
;;;304        else if (qspi == QSPI1)
000078  4294              CMP      r4,r2
00007a  d111              BNE      |L13.160|
;;;305        {
;;;306            if((CLK->CLKSEL3 & CLK_CLKSEL3_QSPI1SEL_Msk) == CLK_CLKSEL3_QSPI1SEL_HXT)
00007c  f8d0221c          LDR      r2,[r0,#0x21c]
000080  f4125f40          TST      r2,#0x3000
000084  d00b              BEQ      |L13.158|
;;;307            {
;;;308                u32ClkSrc = __HXT; /* Clock source is HXT */
;;;309            }
;;;310            else if((CLK->CLKSEL3 & CLK_CLKSEL3_QSPI1SEL_Msk) == CLK_CLKSEL3_QSPI1SEL_PLL)
000086  f8d0221c          LDR      r2,[r0,#0x21c]
00008a  f3c23201          UBFX     r2,r2,#12,#2
00008e  2a01              CMP      r2,#1
000090  d0ec              BEQ      |L13.108|
;;;311            {
;;;312                u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;313            }
;;;314            else if((CLK->CLKSEL3 & CLK_CLKSEL3_QSPI1SEL_Msk) == CLK_CLKSEL3_QSPI1SEL_PCLK1)
000092  f8d0021c          LDR      r0,[r0,#0x21c]
000096  f3c03001          UBFX     r0,r0,#12,#2
00009a  2802              CMP      r0,#2
00009c  d009              BEQ      |L13.178|
                  |L13.158|
;;;315            {
;;;316                /* Clock source is PCLK1 */
;;;317                u32ClkSrc = CLK_GetPCLK1Freq();
;;;318            }
;;;319            else
;;;320            {
;;;321                u32ClkSrc = __HIRC; /* Clock source is HIRC */
00009e  460d              MOV      r5,r1
                  |L13.160|
0000a0  2000              MOVS     r0,#0
;;;322            }
;;;323        }
;;;324    
;;;325        if(u32BusClock >= u32HCLKFreq)
0000a2  42be              CMP      r6,r7
0000a4  d201              BCS      |L13.170|
;;;326        {
;;;327            /* Set DIVIDER = 0 */
;;;328            qspi->CLKDIV = 0U;
;;;329            /* Return master peripheral clock rate */
;;;330            u32RetValue = u32ClkSrc;
;;;331        }
;;;332        else if(u32BusClock >= u32ClkSrc)
0000a6  42ae              CMP      r6,r5
0000a8  d307              BCC      |L13.186|
                  |L13.170|
0000aa  6060              STR      r0,[r4,#4]            ;328
0000ac  4628              MOV      r0,r5                 ;330
                  |L13.174|
;;;333        {
;;;334            /* Set DIVIDER = 0 */
;;;335            qspi->CLKDIV = 0U;
;;;336            /* Return master peripheral clock rate */
;;;337            u32RetValue = u32ClkSrc;
;;;338        }
;;;339        else if(u32BusClock == 0U)
;;;340        {
;;;341            /* Set DIVIDER to the maximum value 0xFF. f_qspi = f_qspi_clk_src / (DIVIDER + 1) */
;;;342            qspi->CLKDIV |= QSPI_CLKDIV_DIVIDER_Msk;
;;;343            /* Return master peripheral clock rate */
;;;344            u32RetValue = (u32ClkSrc / (0xFFU + 1U));
;;;345        }
;;;346        else
;;;347        {
;;;348            u32Div = (((u32ClkSrc * 10U) / u32BusClock + 5U) / 10U) - 1U; /* Round to the nearest integer */
;;;349            if(u32Div > 0x1FFU)
;;;350            {
;;;351                u32Div = 0x1FFU;
;;;352                qspi->CLKDIV |= QSPI_CLKDIV_DIVIDER_Msk;
;;;353                /* Return master peripheral clock rate */
;;;354                u32RetValue = (u32ClkSrc / (0xFFU + 1U));
;;;355            }
;;;356            else
;;;357            {
;;;358                qspi->CLKDIV = (qspi->CLKDIV & (~QSPI_CLKDIV_DIVIDER_Msk)) | (u32Div << QSPI_CLKDIV_DIVIDER_Pos);
;;;359                /* Return master peripheral clock rate */
;;;360                u32RetValue = (u32ClkSrc / (u32Div + 1U));
;;;361            }
;;;362        }
;;;363    
;;;364        return u32RetValue;
;;;365    }
0000ae  e8bd81f0          POP      {r4-r8,pc}
                  |L13.178|
0000b2  f7fffffe          BL       CLK_GetPCLK1Freq
                  |L13.182|
0000b6  4605              MOV      r5,r0                 ;317
0000b8  e7f2              B        |L13.160|
                  |L13.186|
0000ba  f24011ff          MOV      r1,#0x1ff             ;342
0000be  b166              CBZ      r6,|L13.218|
0000c0  eb050085          ADD      r0,r5,r5,LSL #2       ;348
0000c4  0040              LSLS     r0,r0,#1              ;348
0000c6  fbb0f0f6          UDIV     r0,r0,r6              ;348
0000ca  220a              MOVS     r2,#0xa               ;348
0000cc  1d40              ADDS     r0,r0,#5              ;348
0000ce  fbb0f0f2          UDIV     r0,r0,r2              ;348
0000d2  1e40              SUBS     r0,r0,#1              ;348
0000d4  f5b07f00          CMP      r0,#0x200             ;349
0000d8  d304              BCC      |L13.228|
                  |L13.218|
0000da  6860              LDR      r0,[r4,#4]            ;342
0000dc  4308              ORRS     r0,r0,r1              ;342
0000de  6060              STR      r0,[r4,#4]            ;342
0000e0  0a28              LSRS     r0,r5,#8              ;344
0000e2  e7e4              B        |L13.174|
                  |L13.228|
0000e4  6861              LDR      r1,[r4,#4]            ;358
0000e6  f36f0108          BFC      r1,#0,#9              ;358
0000ea  4301              ORRS     r1,r1,r0              ;358
0000ec  6061              STR      r1,[r4,#4]            ;358
0000ee  1c40              ADDS     r0,r0,#1              ;358
0000f0  fbb5f0f0          UDIV     r0,r5,r0              ;360
0000f4  e7db              B        |L13.174|
;;;366    
                          ENDP

0000f6  0000              DCW      0x0000
                  |L13.248|
                          DCD      0x40060000
                  |L13.252|
                          DCD      0x40069000
                  |L13.256|
                          DCD      0x00b71b00

                          AREA ||i.QSPI_SetFIFO||, CODE, READONLY, ALIGN=1

                  QSPI_SetFIFO PROC
;;;374      */
;;;375    void QSPI_SetFIFO(QSPI_T *qspi, uint32_t u32TxThreshold, uint32_t u32RxThreshold)
000000  6903              LDR      r3,[r0,#0x10]
;;;376    {
;;;377        qspi->FIFOCTL = (qspi->FIFOCTL & ~(QSPI_FIFOCTL_TXTH_Msk | QSPI_FIFOCTL_RXTH_Msk)) |
000002  f02343ee          BIC      r3,r3,#0x77000000
000006  ea437101          ORR      r1,r3,r1,LSL #28
00000a  ea416102          ORR      r1,r1,r2,LSL #24
00000e  6101              STR      r1,[r0,#0x10]
;;;378                        (u32TxThreshold << QSPI_FIFOCTL_TXTH_Pos) |
;;;379                        (u32RxThreshold << QSPI_FIFOCTL_RXTH_Pos);
;;;380    }
000010  4770              BX       lr
;;;381    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\qspi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_qspi_c_cc4eac31____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_qspi_c_cc4eac31____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_qspi_c_cc4eac31____REVSH|
#line 402
|__asm___6_qspi_c_cc4eac31____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_qspi_c_cc4eac31____RRX|
#line 587
|__asm___6_qspi_c_cc4eac31____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
