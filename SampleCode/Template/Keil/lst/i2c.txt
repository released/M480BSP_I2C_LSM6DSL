; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\i2c.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\i2c.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -I..\..\Template -I..\Kalman_Filter -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\i2c.crf ..\..\..\Library\StdDriver\src\i2c.c]
                          THUMB

                          AREA ||i.I2C_ClearTimeoutFlag||, CODE, READONLY, ALIGN=1

                  I2C_ClearTimeoutFlag PROC
;;;97       */
;;;98     void I2C_ClearTimeoutFlag(I2C_T *i2c)
000000  6941              LDR      r1,[r0,#0x14]
;;;99     {
;;;100        i2c->TOCTL |= I2C_TOCTL_TOIF_Msk;
000002  f0410101          ORR      r1,r1,#1
000006  6141              STR      r1,[r0,#0x14]
;;;101    }
000008  4770              BX       lr
;;;102    
                          ENDP


                          AREA ||i.I2C_Close||, CODE, READONLY, ALIGN=2

                  I2C_Close PROC
;;;69     
;;;70     void I2C_Close(I2C_T *i2c)
000000  4a0d              LDR      r2,|L2.56|
;;;71     {
;;;72         /* Reset I2C Controller */
;;;73         if((uint32_t)i2c == I2C0_BASE)
;;;74         {
;;;75             SYS->IPRST1 |= SYS_IPRST1_I2C0RST_Msk;
000002  02d1              LSLS     r1,r2,#11
000004  4290              CMP      r0,r2                 ;73
000006  d107              BNE      |L2.24|
000008  68ca              LDR      r2,[r1,#0xc]
00000a  f4427280          ORR      r2,r2,#0x100
00000e  60ca              STR      r2,[r1,#0xc]
;;;76             SYS->IPRST1 &= ~SYS_IPRST1_I2C0RST_Msk;
000010  68ca              LDR      r2,[r1,#0xc]
000012  f4227280          BIC      r2,r2,#0x100
000016  e009              B        |L2.44|
                  |L2.24|
;;;77         }
;;;78         else if((uint32_t)i2c == I2C1_BASE)
000018  4a08              LDR      r2,|L2.60|
00001a  4290              CMP      r0,r2
00001c  d107              BNE      |L2.46|
;;;79         {
;;;80             SYS->IPRST1 |= SYS_IPRST1_I2C1RST_Msk;
00001e  68ca              LDR      r2,[r1,#0xc]
000020  f4427200          ORR      r2,r2,#0x200
000024  60ca              STR      r2,[r1,#0xc]
;;;81             SYS->IPRST1 &= ~SYS_IPRST1_I2C1RST_Msk;
000026  68ca              LDR      r2,[r1,#0xc]
000028  f4227200          BIC      r2,r2,#0x200
                  |L2.44|
00002c  60ca              STR      r2,[r1,#0xc]
                  |L2.46|
;;;82         }
;;;83     
;;;84         /* Disable I2C */
;;;85         i2c->CTL0 &= ~I2C_CTL0_I2CEN_Msk;
00002e  6801              LDR      r1,[r0,#0]
000030  f0210140          BIC      r1,r1,#0x40
000034  6001              STR      r1,[r0,#0]
;;;86     }
000036  4770              BX       lr
;;;87     
                          ENDP

                  |L2.56|
                          DCD      0x40080000
                  |L2.60|
                          DCD      0x40081000

                          AREA ||i.I2C_DisableInt||, CODE, READONLY, ALIGN=1

                  I2C_DisableInt PROC
;;;153      */
;;;154    void I2C_DisableInt(I2C_T *i2c)
000000  6801              LDR      r1,[r0,#0]
;;;155    {
;;;156        i2c->CTL0 &= ~I2C_CTL0_INTEN_Msk;
000002  f0210180          BIC      r1,r1,#0x80
000006  6001              STR      r1,[r0,#0]
;;;157    }
000008  4770              BX       lr
;;;158    
                          ENDP


                          AREA ||i.I2C_DisableTimeout||, CODE, READONLY, ALIGN=1

                  I2C_DisableTimeout PROC
;;;399     */
;;;400    void I2C_DisableTimeout(I2C_T *i2c)
000000  6941              LDR      r1,[r0,#0x14]
;;;401    {
;;;402        i2c->TOCTL &= ~I2C_TOCTL_TOCEN_Msk;
000002  f0210104          BIC      r1,r1,#4
000006  6141              STR      r1,[r0,#0x14]
;;;403    }
000008  4770              BX       lr
;;;404    
                          ENDP


                          AREA ||i.I2C_DisableWakeup||, CODE, READONLY, ALIGN=1

                  I2C_DisableWakeup PROC
;;;429     */
;;;430    void I2C_DisableWakeup(I2C_T *i2c)
000000  6bc1              LDR      r1,[r0,#0x3c]
;;;431    {
;;;432        i2c->WKCTL &= ~I2C_WKCTL_WKEN_Msk;
000002  f0210101          BIC      r1,r1,#1
000006  63c1              STR      r1,[r0,#0x3c]
;;;433    }
000008  4770              BX       lr
;;;434    
                          ENDP


                          AREA ||i.I2C_EnableInt||, CODE, READONLY, ALIGN=1

                  I2C_EnableInt PROC
;;;168      */
;;;169    void I2C_EnableInt(I2C_T *i2c)
000000  6801              LDR      r1,[r0,#0]
;;;170    {
;;;171        i2c->CTL0 |= I2C_CTL0_INTEN_Msk;
000002  f0410180          ORR      r1,r1,#0x80
000006  6001              STR      r1,[r0,#0]
;;;172    }
000008  4770              BX       lr
;;;173    
                          ENDP


                          AREA ||i.I2C_EnableTimeout||, CODE, READONLY, ALIGN=1

                  I2C_EnableTimeout PROC
;;;375     */
;;;376    void I2C_EnableTimeout(I2C_T *i2c, uint8_t u8LongTimeout)
000000  2900              CMP      r1,#0
;;;377    {
;;;378        if(u8LongTimeout)
;;;379        {
;;;380            i2c->TOCTL |= I2C_TOCTL_TOCDIV4_Msk;
;;;381        }
;;;382        else
;;;383        {
;;;384            i2c->TOCTL &= ~I2C_TOCTL_TOCDIV4_Msk;
000002  6941              LDR      r1,[r0,#0x14]
000004  d002              BEQ      |L7.12|
000006  f0410102          ORR      r1,r1,#2              ;380
00000a  e001              B        |L7.16|
                  |L7.12|
00000c  f0210102          BIC      r1,r1,#2
                  |L7.16|
000010  6141              STR      r1,[r0,#0x14]
;;;385        }
;;;386    
;;;387        i2c->TOCTL |= I2C_TOCTL_TOCEN_Msk;
000012  6941              LDR      r1,[r0,#0x14]
000014  f0410104          ORR      r1,r1,#4
000018  6141              STR      r1,[r0,#0x14]
;;;388    }
00001a  4770              BX       lr
;;;389    
                          ENDP


                          AREA ||i.I2C_EnableWakeup||, CODE, READONLY, ALIGN=1

                  I2C_EnableWakeup PROC
;;;414     */
;;;415    void I2C_EnableWakeup(I2C_T *i2c)
000000  6bc1              LDR      r1,[r0,#0x3c]
;;;416    {
;;;417        i2c->WKCTL |= I2C_WKCTL_WKEN_Msk;
000002  f0410101          ORR      r1,r1,#1
000006  63c1              STR      r1,[r0,#0x3c]
;;;418    }
000008  4770              BX       lr
;;;419    
                          ENDP


                          AREA ||i.I2C_GetBusClockFreq||, CODE, READONLY, ALIGN=2

                  I2C_GetBusClockFreq PROC
;;;182     */
;;;183    uint32_t I2C_GetBusClockFreq(I2C_T *i2c)
000000  b510              PUSH     {r4,lr}
;;;184    {
;;;185        uint32_t u32Divider = i2c->CLKDIV;
000002  6904              LDR      r4,[r0,#0x10]
;;;186        uint32_t u32Pclk;
;;;187    
;;;188        if(i2c == I2C1)
000004  4906              LDR      r1,|L9.32|
000006  4288              CMP      r0,r1
000008  d102              BNE      |L9.16|
;;;189        {
;;;190            u32Pclk = CLK_GetPCLK1Freq();
00000a  f7fffffe          BL       CLK_GetPCLK1Freq
00000e  e001              B        |L9.20|
                  |L9.16|
;;;191        }
;;;192        else
;;;193        {
;;;194            u32Pclk = CLK_GetPCLK0Freq();
000010  f7fffffe          BL       CLK_GetPCLK0Freq
                  |L9.20|
;;;195        }
;;;196    
;;;197        return (u32Pclk / ((u32Divider + 1U) << 2U));
000014  00a1              LSLS     r1,r4,#2
000016  1d09              ADDS     r1,r1,#4
000018  fbb0f0f1          UDIV     r0,r0,r1
;;;198    }
00001c  bd10              POP      {r4,pc}
;;;199    
                          ENDP

00001e  0000              DCW      0x0000
                  |L9.32|
                          DCD      0x40081000

                          AREA ||i.I2C_GetData||, CODE, READONLY, ALIGN=1

                  I2C_GetData PROC
;;;277     */
;;;278    uint8_t I2C_GetData(I2C_T *i2c)
000000  6880              LDR      r0,[r0,#8]
;;;279    {
;;;280        return (uint8_t)(i2c->DAT);
000002  b2c0              UXTB     r0,r0
;;;281    }
000004  4770              BX       lr
;;;282    
                          ENDP


                          AREA ||i.I2C_GetIntFlag||, CODE, READONLY, ALIGN=1

                  I2C_GetIntFlag PROC
;;;238     */
;;;239    uint32_t I2C_GetIntFlag(I2C_T *i2c)
000000  6800              LDR      r0,[r0,#0]
;;;240    {
;;;241        uint32_t u32Value;
;;;242    
;;;243        if((i2c->CTL0 & I2C_CTL0_SI_Msk) == I2C_CTL0_SI_Msk)
000002  0700              LSLS     r0,r0,#28
000004  d501              BPL      |L11.10|
;;;244        {
;;;245            u32Value = 1U;
000006  2001              MOVS     r0,#1
;;;246        }
;;;247        else
;;;248        {
;;;249            u32Value = 0U;
;;;250        }
;;;251    
;;;252        return u32Value;
;;;253    }
000008  4770              BX       lr
                  |L11.10|
00000a  2000              MOVS     r0,#0                 ;249
00000c  4770              BX       lr
;;;254    
                          ENDP


                          AREA ||i.I2C_GetStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetStatus PROC
;;;263     */
;;;264    uint32_t I2C_GetStatus(I2C_T *i2c)
000000  68c0              LDR      r0,[r0,#0xc]
;;;265    {
;;;266        return (i2c->STATUS0);
;;;267    }
000002  4770              BX       lr
;;;268    
                          ENDP


                          AREA ||i.I2C_Open||, CODE, READONLY, ALIGN=2

                  I2C_Open PROC
;;;35       */
;;;36     uint32_t I2C_Open(I2C_T *i2c, uint32_t u32BusClock)
000000  b570              PUSH     {r4-r6,lr}
;;;37     {
000002  4604              MOV      r4,r0
;;;38         uint32_t u32Div;
;;;39         uint32_t u32Pclk;
;;;40     
;;;41         if(i2c == I2C1)
000004  480e              LDR      r0,|L13.64|
000006  460d              MOV      r5,r1                 ;37
000008  4284              CMP      r4,r0
00000a  d102              BNE      |L13.18|
;;;42         {
;;;43             u32Pclk = CLK_GetPCLK1Freq();
00000c  f7fffffe          BL       CLK_GetPCLK1Freq
000010  e001              B        |L13.22|
                  |L13.18|
;;;44         }
;;;45         else
;;;46         {
;;;47             u32Pclk = CLK_GetPCLK0Freq();
000012  f7fffffe          BL       CLK_GetPCLK0Freq
                  |L13.22|
;;;48         }
;;;49     
;;;50         u32Div = (uint32_t)(((u32Pclk * 10U) / (u32BusClock * 4U) + 5U) / 10U - 1U); /* Compute proper divider for I2C clock */
000016  eb000180          ADD      r1,r0,r0,LSL #2
00001a  0049              LSLS     r1,r1,#1
00001c  00aa              LSLS     r2,r5,#2
00001e  fbb1f1f2          UDIV     r1,r1,r2
000022  220a              MOVS     r2,#0xa
000024  1d49              ADDS     r1,r1,#5
000026  fbb1f1f2          UDIV     r1,r1,r2
00002a  1e4a              SUBS     r2,r1,#1
;;;51         i2c->CLKDIV = u32Div;
00002c  6122              STR      r2,[r4,#0x10]
;;;52     
;;;53         /* Enable I2C */
;;;54         i2c->CTL0 |= I2C_CTL0_I2CEN_Msk;
00002e  6822              LDR      r2,[r4,#0]
000030  f0420240          ORR      r2,r2,#0x40
000034  6022              STR      r2,[r4,#0]
;;;55     
;;;56         return (u32Pclk / ((u32Div + 1U) << 2U));
;;;57     }
000036  0089              LSLS     r1,r1,#2
000038  fbb0f0f1          UDIV     r0,r0,r1              ;56
00003c  bd70              POP      {r4-r6,pc}
;;;58     
                          ENDP

00003e  0000              DCW      0x0000
                  |L13.64|
                          DCD      0x40081000

                          AREA ||i.I2C_ReadByte||, CODE, READONLY, ALIGN=1

                  I2C_ReadByte PROC
;;;1048     */
;;;1049   uint8_t I2C_ReadByte(I2C_T *i2c, uint8_t u8SlaveAddr)
000000  b570              PUSH     {r4-r6,lr}
;;;1050   {
;;;1051       uint8_t u8Xfering = 1u, u8Err = 0u, rdata = 0u, u8Ctrl = 0u;
000002  2501              MOVS     r5,#1
000004  2300              MOVS     r3,#0
;;;1052   
;;;1053       I2C_START(i2c);                                                /* Send START */
000006  6802              LDR      r2,[r0,#0]
000008  461c              MOV      r4,r3                 ;1051
00000a  f0220208          BIC      r2,r2,#8
00000e  f0420220          ORR      r2,r2,#0x20
000012  6002              STR      r2,[r0,#0]
                  |L14.20|
;;;1054       while(u8Xfering && (u8Err == 0u))
;;;1055       {
;;;1056           I2C_WAIT_READY(i2c) {}
000014  6802              LDR      r2,[r0,#0]
000016  0712              LSLS     r2,r2,#28
000018  d5fc              BPL      |L14.20|
;;;1057           switch(I2C_GET_STATUS(i2c))
00001a  68c2              LDR      r2,[r0,#0xc]
00001c  2a08              CMP      r2,#8
00001e  d00d              BEQ      |L14.60|
000020  2a40              CMP      r2,#0x40
000022  d010              BEQ      |L14.70|
000024  2a48              CMP      r2,#0x48
000026  d010              BEQ      |L14.74|
000028  2a58              CMP      r2,#0x58
00002a  d011              BEQ      |L14.80|
;;;1058           {
;;;1059           case 0x08u:
;;;1060               I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1u) | 0x01u));    /* Write SLA+R to Register I2CDAT */
;;;1061               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1062               break;
;;;1063           case 0x40u:                                             /* Slave Address ACK */
;;;1064               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1065               break;
;;;1066           case 0x48u:                                             /* Slave Address NACK */
;;;1067               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1068               u8Err = 1u;
;;;1069               break;
;;;1070           case 0x58u:
;;;1071               rdata = (unsigned char) I2C_GET_DATA(i2c);         /* Receive Data */
;;;1072               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1073               u8Xfering = 0u;
;;;1074               break;
;;;1075           case 0x38u:                                             /* Arbitration Lost */
;;;1076           default:                                               /* Unknow status */
;;;1077               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);        /* Clear SI and send STOP */
00002c  6802              LDR      r2,[r0,#0]
00002e  f022023c          BIC      r2,r2,#0x3c
000032  f0420218          ORR      r2,r2,#0x18
000036  6002              STR      r2,[r0,#0]
;;;1078               u8Ctrl = I2C_CTL_SI;
000038  2208              MOVS     r2,#8
;;;1079               u8Err = 1u;
;;;1080               break;
00003a  e007              B        |L14.76|
                  |L14.60|
00003c  2201              MOVS     r2,#1                 ;1060
00003e  eb020241          ADD      r2,r2,r1,LSL #1       ;1060
000042  b2d2              UXTB     r2,r2                 ;1060
000044  6082              STR      r2,[r0,#8]            ;1060
                  |L14.70|
000046  2208              MOVS     r2,#8                 ;1064
000048  e006              B        |L14.88|
                  |L14.74|
00004a  2218              MOVS     r2,#0x18              ;1067
                  |L14.76|
00004c  2301              MOVS     r3,#1                 ;1068
00004e  e003              B        |L14.88|
                  |L14.80|
000050  6882              LDR      r2,[r0,#8]            ;1071
000052  b2d4              UXTB     r4,r2                 ;1071
000054  2218              MOVS     r2,#0x18              ;1072
000056  2500              MOVS     r5,#0                 ;1073
                  |L14.88|
;;;1081           }
;;;1082           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                          /* Write controlbit to I2C_CTL register */
000058  6806              LDR      r6,[r0,#0]
00005a  f026063c          BIC      r6,r6,#0x3c
00005e  4316              ORRS     r6,r6,r2
000060  6006              STR      r6,[r0,#0]
000062  b115              CBZ      r5,|L14.106|
000064  2b00              CMP      r3,#0                 ;1054
000066  d0d5              BEQ      |L14.20|
000068  e000              B        |L14.108|
                  |L14.106|
;;;1083       }
;;;1084       if(u8Err)
00006a  b103              CBZ      r3,|L14.110|
                  |L14.108|
;;;1085       {
;;;1086           rdata = 0u;                                                 /* If occurs error, return 0 */
00006c  2400              MOVS     r4,#0
                  |L14.110|
;;;1087       }
;;;1088       return rdata;                                                  /* Return read data */
00006e  4620              MOV      r0,r4
;;;1089   }
000070  bd70              POP      {r4-r6,pc}
;;;1090   
                          ENDP


                          AREA ||i.I2C_ReadByteOneReg||, CODE, READONLY, ALIGN=1

                  I2C_ReadByteOneReg PROC
;;;1169     */
;;;1170   uint8_t I2C_ReadByteOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1171   {
;;;1172       uint8_t u8Xfering = 1u, u8Err = 0u, rdata = 0u, u8Ctrl = 0u;
000002  2701              MOVS     r7,#1
000004  2400              MOVS     r4,#0
;;;1173   
;;;1174       I2C_START(i2c);                                                /* Send START */
000006  6805              LDR      r5,[r0,#0]
000008  4626              MOV      r6,r4                 ;1172
00000a  4623              MOV      r3,r4                 ;1172
00000c  f0250508          BIC      r5,r5,#8
000010  f0450520          ORR      r5,r5,#0x20
000014  6005              STR      r5,[r0,#0]
                  |L15.22|
;;;1175       while(u8Xfering && (u8Err == 0u))
;;;1176       {
;;;1177           I2C_WAIT_READY(i2c) {}
000016  6805              LDR      r5,[r0,#0]
000018  072d              LSLS     r5,r5,#28
00001a  d5fc              BPL      |L15.22|
;;;1178           switch(I2C_GET_STATUS(i2c))
00001c  68c5              LDR      r5,[r0,#0xc]
00001e  f0150f07          TST      r5,#7
000022  d127              BNE      |L15.116|
000024  10ed              ASRS     r5,r5,#3
000026  2d0c              CMP      r5,#0xc
000028  d224              BCS      |L15.116|
00002a  e8dff005          TBB      [pc,r5]
00002e  2306              DCB      0x23,0x06
000030  0f080a0d          DCB      0x0f,0x08,0x0a,0x0d
000034  0a23140a          DCB      0x0a,0x23,0x14,0x0a
000038  2316              DCB      0x23,0x16
;;;1179           {
;;;1180           case 0x08u:
;;;1181               I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1u | 0x00u));      /* Write SLA+W to Register I2CDAT */
00003a  004b              LSLS     r3,r1,#1
;;;1182               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1183               break;
00003c  e009              B        |L15.82|
;;;1184           case 0x18u:                                             /* Slave Address ACK */
;;;1185               I2C_SET_DATA(i2c, u8DataAddr);                     /* Write Lo byte address of register */
00003e  6082              STR      r2,[r0,#8]
;;;1186               break;
000040  e00f              B        |L15.98|
;;;1187           case 0x20u:                                             /* Slave Address NACK */
;;;1188           case 0x30u:                                             /* Master transmit data NACK */
;;;1189               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
000042  2318              MOVS     r3,#0x18
                  |L15.68|
;;;1190               u8Err = 1u;
000044  2401              MOVS     r4,#1
000046  e00c              B        |L15.98|
;;;1191               break;
;;;1192           case 0x28u:
;;;1193               u8Ctrl = I2C_CTL_STA_SI;                         /* Send repeat START */
000048  2328              MOVS     r3,#0x28
;;;1194               break;
00004a  e00a              B        |L15.98|
;;;1195           case 0x10u:
;;;1196               I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1u) | 0x01u));    /* Write SLA+R to Register I2CDAT */
00004c  2301              MOVS     r3,#1
00004e  eb030341          ADD      r3,r3,r1,LSL #1
                  |L15.82|
000052  b2db              UXTB     r3,r3                 ;1181
000054  6083              STR      r3,[r0,#8]            ;1181
;;;1197               u8Ctrl = I2C_CTL_SI;                               /* Clear SI */
;;;1198               break;
;;;1199           case 0x40u:                                             /* Slave Address ACK */
;;;1200               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
000056  2308              MOVS     r3,#8
;;;1201               break;
000058  e003              B        |L15.98|
;;;1202           case 0x48u:                                             /* Slave Address NACK */
;;;1203               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1204               u8Err = 1u;
;;;1205               break;
;;;1206           case 0x58u:
;;;1207               rdata = (uint8_t) I2C_GET_DATA(i2c);               /* Receive Data */
00005a  6883              LDR      r3,[r0,#8]
00005c  b2de              UXTB     r6,r3
;;;1208               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
00005e  2318              MOVS     r3,#0x18
;;;1209               u8Xfering = 0u;
000060  2700              MOVS     r7,#0
                  |L15.98|
;;;1210               break;
;;;1211           case 0x38u:                                             /* Arbitration Lost */
;;;1212           default:                                               /* Unknow status */
;;;1213               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);        /* Clear SI and send STOP */
;;;1214               u8Ctrl = I2C_CTL_SI;
;;;1215               u8Err = 1u;
;;;1216               break;
;;;1217           }
;;;1218           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                          /* Write controlbit to I2C_CTL register */
000062  6805              LDR      r5,[r0,#0]
000064  f025053c          BIC      r5,r5,#0x3c
000068  431d              ORRS     r5,r5,r3
00006a  6005              STR      r5,[r0,#0]
00006c  b157              CBZ      r7,|L15.132|
00006e  2c00              CMP      r4,#0                 ;1175
000070  d0d1              BEQ      |L15.22|
000072  e008              B        |L15.134|
                  |L15.116|
000074  6803              LDR      r3,[r0,#0]            ;1213
000076  f023033c          BIC      r3,r3,#0x3c           ;1213
00007a  f0430318          ORR      r3,r3,#0x18           ;1213
00007e  6003              STR      r3,[r0,#0]            ;1213
000080  2308              MOVS     r3,#8                 ;1214
000082  e7df              B        |L15.68|
                  |L15.132|
;;;1219       }
;;;1220       if(u8Err)
000084  b104              CBZ      r4,|L15.136|
                  |L15.134|
;;;1221       {
;;;1222           rdata = 0u;                                                 /* If occurs error, return 0 */
000086  2600              MOVS     r6,#0
                  |L15.136|
;;;1223       }
;;;1224       return rdata;                                                  /* Return read data */
000088  4630              MOV      r0,r6
;;;1225   }
00008a  bdf0              POP      {r4-r7,pc}
;;;1226   
                          ENDP


                          AREA ||i.I2C_ReadByteTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_ReadByteTwoRegs PROC
;;;1319     */
;;;1320   uint8_t I2C_ReadByteTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1321   {
;;;1322       uint8_t u8Xfering = 1u, u8Err = 0u, rdata = 0u, u8Addr = 1u, u8Ctrl = 0u;
000002  2400              MOVS     r4,#0
000004  f04f0c01          MOV      r12,#1
;;;1323   
;;;1324       I2C_START(i2c);                                                         /* Send START */
000008  6805              LDR      r5,[r0,#0]
00000a  4626              MOV      r6,r4                 ;1322
00000c  4667              MOV      r7,r12                ;1322
00000e  4623              MOV      r3,r4                 ;1322
000010  f0250508          BIC      r5,r5,#8
000014  f0450520          ORR      r5,r5,#0x20
000018  6005              STR      r5,[r0,#0]
                  |L16.26|
;;;1325       while(u8Xfering && (u8Err == 0u))
;;;1326       {
;;;1327           I2C_WAIT_READY(i2c) {}
00001a  6805              LDR      r5,[r0,#0]
00001c  072d              LSLS     r5,r5,#28
00001e  d5fc              BPL      |L16.26|
;;;1328           switch(I2C_GET_STATUS(i2c))
000020  68c5              LDR      r5,[r0,#0xc]
000022  f0150f07          TST      r5,#7
000026  d130              BNE      |L16.138|
000028  10ed              ASRS     r5,r5,#3
00002a  2d0c              CMP      r5,#0xc
00002c  d22d              BCS      |L16.138|
00002e  e8dff005          TBB      [pc,r5]
000032  2c06              DCB      0x2c,0x06
000034  15080b0e          DCB      0x15,0x08,0x0b,0x0e
000038  0b2c1a0b          DCB      0x0b,0x2c,0x1a,0x0b
00003c  2c1c              DCB      0x2c,0x1c
;;;1329           {
;;;1330           case 0x08u:
;;;1331               I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1u | 0x00u));               /* Write SLA+W to Register I2CDAT */
00003e  004b              LSLS     r3,r1,#1
;;;1332               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1333               break;
000040  e00f              B        |L16.98|
;;;1334           case 0x18u:                                                      /* Slave Address ACK */
;;;1335               I2C_SET_DATA(i2c, (uint8_t)((u16DataAddr & 0xFF00u) >> 8u));    /* Write Hi byte address of register */
000042  0a15              LSRS     r5,r2,#8
000044  6085              STR      r5,[r0,#8]
;;;1336               break;
000046  e015              B        |L16.116|
;;;1337           case 0x20u:                                                      /* Slave Address NACK */
;;;1338           case 0x30u:                                                      /* Master transmit data NACK */
;;;1339               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
000048  2318              MOVS     r3,#0x18
                  |L16.74|
;;;1340               u8Err = 1u;
00004a  2401              MOVS     r4,#1
00004c  e012              B        |L16.116|
;;;1341               break;
;;;1342           case 0x28u:
;;;1343               if(u8Addr)
00004e  b11f              CBZ      r7,|L16.88|
;;;1344               {
;;;1345                   I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFFu));       /* Write Lo byte address of register */
000050  b2d5              UXTB     r5,r2
000052  6085              STR      r5,[r0,#8]
;;;1346                   u8Addr = 0u;
000054  2700              MOVS     r7,#0
000056  e00d              B        |L16.116|
                  |L16.88|
;;;1347               }
;;;1348               else
;;;1349               {
;;;1350                   u8Ctrl = I2C_CTL_STA_SI;                              /* Clear SI and send repeat START */
000058  2328              MOVS     r3,#0x28
00005a  e00b              B        |L16.116|
;;;1351               }
;;;1352               break;
;;;1353           case 0x10u:
;;;1354               I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1u) | 0x01u));             /* Write SLA+R to Register I2CDAT */
00005c  2301              MOVS     r3,#1
00005e  eb030341          ADD      r3,r3,r1,LSL #1
                  |L16.98|
000062  b2db              UXTB     r3,r3                 ;1331
000064  6083              STR      r3,[r0,#8]            ;1331
;;;1355               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1356               break;
;;;1357           case 0x40u:                                                      /* Slave Address ACK */
;;;1358               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
000066  2308              MOVS     r3,#8
;;;1359               break;
000068  e004              B        |L16.116|
;;;1360           case 0x48u:                                                      /* Slave Address NACK */
;;;1361               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1362               u8Err = 1u;
;;;1363               break;
;;;1364           case 0x58u:
;;;1365               rdata = (unsigned char) I2C_GET_DATA(i2c);                  /* Receive Data */
00006a  6883              LDR      r3,[r0,#8]
;;;1366               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1367               u8Xfering = 0u;
00006c  f04f0c00          MOV      r12,#0
000070  b2de              UXTB     r6,r3                 ;1365
000072  2318              MOVS     r3,#0x18              ;1366
                  |L16.116|
;;;1368               break;
;;;1369           case 0x38u:                                                      /* Arbitration Lost */
;;;1370           default:                                                        /* Unknow status */
;;;1371               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);                 /* Clear SI and send STOP */
;;;1372               u8Ctrl = I2C_CTL_SI;
;;;1373               u8Err = 1u;
;;;1374               break;
;;;1375           }
;;;1376           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                   /* Write controlbit to I2C_CTL register */
000074  6805              LDR      r5,[r0,#0]
000076  f025053c          BIC      r5,r5,#0x3c
00007a  431d              ORRS     r5,r5,r3
00007c  6005              STR      r5,[r0,#0]
00007e  f1bc0f00          CMP      r12,#0                ;1325
000082  d00a              BEQ      |L16.154|
000084  2c00              CMP      r4,#0                 ;1325
000086  d0c8              BEQ      |L16.26|
000088  e008              B        |L16.156|
                  |L16.138|
00008a  6803              LDR      r3,[r0,#0]            ;1371
00008c  f023033c          BIC      r3,r3,#0x3c           ;1371
000090  f0430318          ORR      r3,r3,#0x18           ;1371
000094  6003              STR      r3,[r0,#0]            ;1371
000096  2308              MOVS     r3,#8                 ;1372
000098  e7d7              B        |L16.74|
                  |L16.154|
;;;1377       }
;;;1378       if(u8Err)
00009a  b104              CBZ      r4,|L16.158|
                  |L16.156|
;;;1379       {
;;;1380           rdata = 0u;                                                          /* If occurs error, return 0 */
00009c  2600              MOVS     r6,#0
                  |L16.158|
;;;1381       }
;;;1382       return rdata;                                                           /* Return read data */
00009e  4630              MOV      r0,r6
;;;1383   }
0000a0  bdf0              POP      {r4-r7,pc}
;;;1384   
                          ENDP


                          AREA ||i.I2C_ReadMultiBytes||, CODE, READONLY, ALIGN=1

                  I2C_ReadMultiBytes PROC
;;;1105     */
;;;1106   uint32_t I2C_ReadMultiBytes(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t rdata[], uint32_t u32rLen)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1107   {
;;;1108       uint8_t u8Xfering = 1u, u8Err = 0u, u8Ctrl = 0u;
000002  2701              MOVS     r7,#1
000004  2600              MOVS     r6,#0
;;;1109       uint32_t u32rxLen = 0u;
;;;1110   
;;;1111       I2C_START(i2c);                                                /* Send START */
000006  6805              LDR      r5,[r0,#0]
000008  4634              MOV      r4,r6                 ;1109
00000a  f0250508          BIC      r5,r5,#8
00000e  f0450520          ORR      r5,r5,#0x20
000012  6005              STR      r5,[r0,#0]
                  |L17.20|
;;;1112       while(u8Xfering && (u8Err == 0u))
;;;1113       {
;;;1114           I2C_WAIT_READY(i2c) {}
000014  6805              LDR      r5,[r0,#0]
000016  072d              LSLS     r5,r5,#28
000018  d5fc              BPL      |L17.20|
;;;1115           switch(I2C_GET_STATUS(i2c))
00001a  68c5              LDR      r5,[r0,#0xc]
00001c  2d48              CMP      r5,#0x48
00001e  d017              BEQ      |L17.80|
000020  dc04              BGT      |L17.44|
000022  2d08              CMP      r5,#8
000024  d00e              BEQ      |L17.68|
000026  2d40              CMP      r5,#0x40
000028  d104              BNE      |L17.52|
00002a  e01a              B        |L17.98|
                  |L17.44|
00002c  2d50              CMP      r5,#0x50
00002e  d012              BEQ      |L17.86|
000030  2d58              CMP      r5,#0x58
000032  d01a              BEQ      |L17.106|
                  |L17.52|
;;;1116           {
;;;1117           case 0x08u:
;;;1118               I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1u) | 0x01u));    /* Write SLA+R to Register I2CDAT */
;;;1119               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1120               break;
;;;1121           case 0x40u:                                             /* Slave Address ACK */
;;;1122               u8Ctrl = I2C_CTL_SI_AA;                          /* Clear SI and set ACK */
;;;1123               break;
;;;1124           case 0x48u:                                             /* Slave Address NACK */
;;;1125               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1126               u8Err = 1u;
;;;1127               break;
;;;1128           case 0x50u:
;;;1129               rdata[u32rxLen++] = (unsigned char) I2C_GET_DATA(i2c);    /* Receive Data */
;;;1130               if(u32rxLen < (u32rLen - 1u))
;;;1131               {
;;;1132                   u8Ctrl = I2C_CTL_SI_AA;                             /* Clear SI and set ACK */
;;;1133               }
;;;1134               else
;;;1135               {
;;;1136                   u8Ctrl = I2C_CTL_SI;                                /* Clear SI */
;;;1137               }
;;;1138               break;
;;;1139           case 0x58u:
;;;1140               rdata[u32rxLen++] = (unsigned char) I2C_GET_DATA(i2c);    /* Receive Data */
;;;1141               u8Ctrl = I2C_CTL_STO_SI;                                /* Clear SI and send STOP */
;;;1142               u8Xfering = 0u;
;;;1143               break;
;;;1144           case 0x38u:                                                    /* Arbitration Lost */
;;;1145           default:                                                      /* Unknow status */
;;;1146               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);               /* Clear SI and send STOP */
000034  6805              LDR      r5,[r0,#0]
000036  f025053c          BIC      r5,r5,#0x3c
00003a  f0450518          ORR      r5,r5,#0x18
00003e  6005              STR      r5,[r0,#0]
;;;1147               u8Ctrl = I2C_CTL_SI;
000040  2508              MOVS     r5,#8
;;;1148               u8Err = 1u;
;;;1149               break;
000042  e006              B        |L17.82|
                  |L17.68|
000044  2501              MOVS     r5,#1                 ;1118
000046  eb050541          ADD      r5,r5,r1,LSL #1       ;1118
00004a  b2ed              UXTB     r5,r5                 ;1118
00004c  6085              STR      r5,[r0,#8]            ;1118
00004e  e00a              B        |L17.102|
                  |L17.80|
000050  2518              MOVS     r5,#0x18              ;1125
                  |L17.82|
000052  2601              MOVS     r6,#1                 ;1126
000054  e00e              B        |L17.116|
                  |L17.86|
000056  6885              LDR      r5,[r0,#8]            ;1129
000058  5515              STRB     r5,[r2,r4]            ;1129
00005a  1e5d              SUBS     r5,r3,#1              ;1130
00005c  1c64              ADDS     r4,r4,#1              ;1130
00005e  42ac              CMP      r4,r5                 ;1130
000060  d201              BCS      |L17.102|
                  |L17.98|
000062  250c              MOVS     r5,#0xc               ;1132
000064  e006              B        |L17.116|
                  |L17.102|
000066  2508              MOVS     r5,#8                 ;1136
000068  e004              B        |L17.116|
                  |L17.106|
00006a  6885              LDR      r5,[r0,#8]            ;1140
00006c  5515              STRB     r5,[r2,r4]            ;1140
00006e  2518              MOVS     r5,#0x18              ;1141
000070  2700              MOVS     r7,#0                 ;1142
000072  1c64              ADDS     r4,r4,#1              ;1142
                  |L17.116|
;;;1150           }
;;;1151           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                 /* Write controlbit to I2C_CTL register */
000074  f8d0c000          LDR      r12,[r0,#0]
000078  f02c0c3c          BIC      r12,r12,#0x3c
00007c  ea4c0c05          ORR      r12,r12,r5
000080  f8c0c000          STR      r12,[r0,#0]
000084  b10f              CBZ      r7,|L17.138|
000086  2e00              CMP      r6,#0                 ;1112
000088  d0c4              BEQ      |L17.20|
                  |L17.138|
;;;1152       }
;;;1153       return u32rxLen;                                                      /* Return bytes length that have been received */
00008a  4620              MOV      r0,r4
;;;1154   }
00008c  bdf0              POP      {r4-r7,pc}
;;;1155   
                          ENDP


                          AREA ||i.I2C_ReadMultiBytesOneReg||, CODE, READONLY, ALIGN=1

                  I2C_ReadMultiBytesOneReg PROC
;;;1241     */
;;;1242   uint32_t I2C_ReadMultiBytesOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, uint8_t rdata[], uint32_t u32rLen)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;1243   {
;;;1244       uint8_t u8Xfering = 1u, u8Err = 0u, u8Ctrl = 0u;
000004  2600              MOVS     r6,#0
;;;1245       uint32_t u32rxLen = 0u;
;;;1246   
;;;1247       I2C_START(i2c);                                                /* Send START */
000006  f8dd901c          LDR      r9,[sp,#0x1c]
00000a  6807              LDR      r7,[r0,#0]
00000c  f04f0c01          MOV      r12,#1                ;1244
000010  4634              MOV      r4,r6                 ;1244
000012  4635              MOV      r5,r6                 ;1245
000014  f0270708          BIC      r7,r7,#8
000018  f0470720          ORR      r7,r7,#0x20
00001c  6007              STR      r7,[r0,#0]
                  |L18.30|
;;;1248       while(u8Xfering && (u8Err == 0u))
;;;1249       {
;;;1250           I2C_WAIT_READY(i2c) {}
00001e  6807              LDR      r7,[r0,#0]
000020  073f              LSLS     r7,r7,#28
000022  d5fc              BPL      |L18.30|
;;;1251           switch(I2C_GET_STATUS(i2c))
000024  68c7              LDR      r7,[r0,#0xc]
000026  f0170f07          TST      r7,#7
00002a  d137              BNE      |L18.156|
00002c  10ff              ASRS     r7,r7,#3
00002e  2f0c              CMP      r7,#0xc
000030  d234              BCS      |L18.156|
000032  e8dff007          TBB      [pc,r7]
000036  3306              DCB      0x33,0x06
000038  0f080a0d          DCB      0x0f,0x08,0x0a,0x0d
00003c  0a331c0a          DCB      0x0a,0x33,0x1c,0x0a
000040  1520              DCB      0x15,0x20
;;;1252           {
;;;1253           case 0x08u:
;;;1254               I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1u | 0x00u));      /* Write SLA+W to Register I2CDAT */
000042  004c              LSLS     r4,r1,#1
;;;1255               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1256               break;
000044  e009              B        |L18.90|
;;;1257           case 0x18u:                                             /* Slave Address ACK */
;;;1258               I2C_SET_DATA(i2c, u8DataAddr);                     /* Write Lo byte address of register */
000046  6082              STR      r2,[r0,#8]
;;;1259               break;
000048  e01b              B        |L18.130|
;;;1260           case 0x20u:                                             /* Slave Address NACK */
;;;1261           case 0x30u:                                             /* Master transmit data NACK */
;;;1262               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
00004a  2418              MOVS     r4,#0x18
                  |L18.76|
;;;1263               u8Err = 1u;
00004c  2601              MOVS     r6,#1
00004e  e018              B        |L18.130|
;;;1264               break;
;;;1265           case 0x28u:
;;;1266               u8Ctrl = I2C_CTL_STA_SI;                         /* Send repeat START */
000050  2428              MOVS     r4,#0x28
;;;1267               break;
000052  e016              B        |L18.130|
;;;1268           case 0x10u:
;;;1269               I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1u) | 0x01u));    /* Write SLA+R to Register I2CDAT */
000054  2401              MOVS     r4,#1
000056  eb040441          ADD      r4,r4,r1,LSL #1
                  |L18.90|
00005a  b2e4              UXTB     r4,r4
00005c  6084              STR      r4,[r0,#8]
00005e  e008              B        |L18.114|
;;;1270               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1271               break;
;;;1272           case 0x40u:                                             /* Slave Address ACK */
;;;1273               u8Ctrl = I2C_CTL_SI_AA;                          /* Clear SI and set ACK */
;;;1274               break;
;;;1275           case 0x48u:                                             /* Slave Address NACK */
;;;1276               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1277               u8Err = 1u;
;;;1278               break;
;;;1279           case 0x50u:
;;;1280               rdata[u32rxLen++] = (uint8_t) I2C_GET_DATA(i2c);   /* Receive Data */
000060  6884              LDR      r4,[r0,#8]
000062  555c              STRB     r4,[r3,r5]
;;;1281               if(u32rxLen < (u32rLen - 1u))
000064  f1a90401          SUB      r4,r9,#1
000068  1c6d              ADDS     r5,r5,#1
00006a  42a5              CMP      r5,r4
00006c  d201              BCS      |L18.114|
;;;1282               {
;;;1283                   u8Ctrl = I2C_CTL_SI_AA;                      /* Clear SI and set ACK */
00006e  240c              MOVS     r4,#0xc
000070  e007              B        |L18.130|
                  |L18.114|
;;;1284               }
;;;1285               else
;;;1286               {
;;;1287                   u8Ctrl = I2C_CTL_SI;                         /* Clear SI */
000072  2408              MOVS     r4,#8
000074  e005              B        |L18.130|
;;;1288               }
;;;1289               break;
;;;1290           case 0x58u:
;;;1291               rdata[u32rxLen++] = (uint8_t) I2C_GET_DATA(i2c);   /* Receive Data */
000076  6884              LDR      r4,[r0,#8]
000078  555c              STRB     r4,[r3,r5]
;;;1292               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
00007a  2418              MOVS     r4,#0x18
;;;1293               u8Xfering = 0u;
00007c  f04f0c00          MOV      r12,#0
000080  1c6d              ADDS     r5,r5,#1
                  |L18.130|
;;;1294               break;
;;;1295           case 0x38u:                                             /* Arbitration Lost */
;;;1296           default:                                               /* Unknow status */
;;;1297               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);        /* Clear SI and send STOP */
;;;1298               u8Ctrl = I2C_CTL_SI;
;;;1299               u8Err = 1u;
;;;1300               break;
;;;1301           }
;;;1302           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                          /* Write controlbit to I2C_CTL register */
000082  6807              LDR      r7,[r0,#0]
000084  f027073c          BIC      r7,r7,#0x3c
000088  4327              ORRS     r7,r7,r4
00008a  6007              STR      r7,[r0,#0]
00008c  f1bc0f00          CMP      r12,#0                ;1248
000090  d001              BEQ      |L18.150|
000092  2e00              CMP      r6,#0                 ;1248
000094  d0c3              BEQ      |L18.30|
                  |L18.150|
;;;1303       }
;;;1304       return u32rxLen;                                               /* Return bytes length that have been received */
000096  4628              MOV      r0,r5
;;;1305   }
000098  e8bd83f0          POP      {r4-r9,pc}
                  |L18.156|
00009c  6804              LDR      r4,[r0,#0]            ;1297
00009e  f024043c          BIC      r4,r4,#0x3c           ;1297
0000a2  f0440418          ORR      r4,r4,#0x18           ;1297
0000a6  6004              STR      r4,[r0,#0]            ;1297
0000a8  2408              MOVS     r4,#8                 ;1298
0000aa  e7cf              B        |L18.76|
;;;1306   
                          ENDP


                          AREA ||i.I2C_ReadMultiBytesTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_ReadMultiBytesTwoRegs PROC
;;;1399     */
;;;1400   uint32_t I2C_ReadMultiBytesTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, uint8_t rdata[], uint32_t u32rLen)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1401   {
;;;1402       uint8_t u8Xfering = 1u, u8Err = 0u, u8Addr = 1u, u8Ctrl = 0u;
000004  2500              MOVS     r5,#0
000006  4691              MOV      r9,r2                 ;1401
000008  f04f0c01          MOV      r12,#1
;;;1403       uint32_t u32rxLen = 0u;
;;;1404   
;;;1405       I2C_START(i2c);                                                         /* Send START */
00000c  f8dda020          LDR      r10,[sp,#0x20]
000010  6806              LDR      r6,[r0,#0]
000012  4667              MOV      r7,r12                ;1402
000014  462a              MOV      r2,r5                 ;1402
000016  462c              MOV      r4,r5                 ;1403
000018  f0260608          BIC      r6,r6,#8
00001c  f0460620          ORR      r6,r6,#0x20
000020  6006              STR      r6,[r0,#0]
                  |L19.34|
;;;1406       while(u8Xfering && (u8Err == 0u))
;;;1407       {
;;;1408           I2C_WAIT_READY(i2c) {}
000022  6806              LDR      r6,[r0,#0]
000024  0736              LSLS     r6,r6,#28
000026  d5fc              BPL      |L19.34|
;;;1409           switch(I2C_GET_STATUS(i2c))
000028  68c6              LDR      r6,[r0,#0xc]
00002a  f0160f07          TST      r6,#7
00002e  d13f              BNE      |L19.176|
000030  10f6              ASRS     r6,r6,#3
000032  2e0c              CMP      r6,#0xc
000034  d23c              BCS      |L19.176|
000036  e8dff006          TBB      [pc,r6]
00003a  3b06              DCB      0x3b,0x06
00003c  17080c0f          DCB      0x17,0x08,0x0c,0x0f
000040  0c3b240c          DCB      0x0c,0x3b,0x24,0x0c
000044  1d28              DCB      0x1d,0x28
;;;1410           {
;;;1411           case 0x08u:
;;;1412               I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1u | 0x00u));               /* Write SLA+W to Register I2CDAT */
000046  004a              LSLS     r2,r1,#1
;;;1413               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1414               break;
000048  e011              B        |L19.110|
;;;1415           case 0x18u:                                                      /* Slave Address ACK */
;;;1416               I2C_SET_DATA(i2c, (uint8_t)((u16DataAddr & 0xFF00u) >> 8u));    /* Write Hi byte address of register */
00004a  ea4f2619          LSR      r6,r9,#8
00004e  6086              STR      r6,[r0,#8]
;;;1417               break;
000050  e021              B        |L19.150|
;;;1418           case 0x20u:                                                      /* Slave Address NACK */
;;;1419           case 0x30u:                                                      /* Master transmit data NACK */
;;;1420               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
000052  2218              MOVS     r2,#0x18
                  |L19.84|
;;;1421               u8Err = 1u;
000054  2501              MOVS     r5,#1
000056  e01e              B        |L19.150|
;;;1422               break;
;;;1423           case 0x28u:
;;;1424               if(u8Addr)
000058  b127              CBZ      r7,|L19.100|
;;;1425               {
;;;1426                   I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFFu));       /* Write Lo byte address of register */
00005a  f00906ff          AND      r6,r9,#0xff
00005e  6086              STR      r6,[r0,#8]
;;;1427                   u8Addr = 0u;
000060  2700              MOVS     r7,#0
000062  e018              B        |L19.150|
                  |L19.100|
;;;1428               }
;;;1429               else
;;;1430               {
;;;1431                   u8Ctrl = I2C_CTL_STA_SI;                              /* Clear SI and send repeat START */
000064  2228              MOVS     r2,#0x28
000066  e016              B        |L19.150|
;;;1432               }
;;;1433               break;
;;;1434           case 0x10u:
;;;1435               I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1u) | 0x01u));             /* Write SLA+R to Register I2CDAT */
000068  2201              MOVS     r2,#1
00006a  eb020241          ADD      r2,r2,r1,LSL #1
                  |L19.110|
00006e  b2d2              UXTB     r2,r2
000070  6082              STR      r2,[r0,#8]
000072  e008              B        |L19.134|
;;;1436               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1437               break;
;;;1438           case 0x40u:                                                      /* Slave Address ACK */
;;;1439               u8Ctrl = I2C_CTL_SI_AA;                                   /* Clear SI and set ACK */
;;;1440               break;
;;;1441           case 0x48u:                                                      /* Slave Address NACK */
;;;1442               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1443               u8Err = 1u;
;;;1444               break;
;;;1445           case 0x50u:
;;;1446               rdata[u32rxLen++] = (unsigned char) I2C_GET_DATA(i2c);      /* Receive Data */
000074  6882              LDR      r2,[r0,#8]
000076  551a              STRB     r2,[r3,r4]
;;;1447               if(u32rxLen < (u32rLen - 1u))
000078  f1aa0201          SUB      r2,r10,#1
00007c  1c64              ADDS     r4,r4,#1
00007e  4294              CMP      r4,r2
000080  d201              BCS      |L19.134|
;;;1448               {
;;;1449                   u8Ctrl = I2C_CTL_SI_AA;                               /* Clear SI and set ACK */
000082  220c              MOVS     r2,#0xc
000084  e007              B        |L19.150|
                  |L19.134|
;;;1450               }
;;;1451               else
;;;1452               {
;;;1453                   u8Ctrl = I2C_CTL_SI;                                  /* Clear SI */
000086  2208              MOVS     r2,#8
000088  e005              B        |L19.150|
;;;1454               }
;;;1455               break;
;;;1456           case 0x58u:
;;;1457               rdata[u32rxLen++] = (unsigned char) I2C_GET_DATA(i2c);      /* Receive Data */
00008a  6882              LDR      r2,[r0,#8]
00008c  551a              STRB     r2,[r3,r4]
;;;1458               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
00008e  2218              MOVS     r2,#0x18
;;;1459               u8Xfering = 0u;
000090  f04f0c00          MOV      r12,#0
000094  1c64              ADDS     r4,r4,#1
                  |L19.150|
;;;1460               break;
;;;1461           case 0x38u:                                                      /* Arbitration Lost */
;;;1462           default:                                                        /* Unknow status */
;;;1463               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);                 /* Clear SI and send STOP */
;;;1464               u8Ctrl = I2C_CTL_SI;
;;;1465               u8Err = 1u;
;;;1466               break;
;;;1467           }
;;;1468           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                   /* Write controlbit to I2C_CTL register */
000096  6806              LDR      r6,[r0,#0]
000098  f026063c          BIC      r6,r6,#0x3c
00009c  4316              ORRS     r6,r6,r2
00009e  6006              STR      r6,[r0,#0]
0000a0  f1bc0f00          CMP      r12,#0                ;1406
0000a4  d001              BEQ      |L19.170|
0000a6  2d00              CMP      r5,#0                 ;1406
0000a8  d0bb              BEQ      |L19.34|
                  |L19.170|
;;;1469       }
;;;1470       return u32rxLen;                                                        /* Return bytes length that have been received */
0000aa  4620              MOV      r0,r4
;;;1471   }
0000ac  e8bd87f0          POP      {r4-r10,pc}
                  |L19.176|
0000b0  6802              LDR      r2,[r0,#0]            ;1463
0000b2  f022023c          BIC      r2,r2,#0x3c           ;1463
0000b6  f0420218          ORR      r2,r2,#0x18           ;1463
0000ba  6002              STR      r2,[r0,#0]            ;1463
0000bc  2208              MOVS     r2,#8                 ;1464
0000be  e7c9              B        |L19.84|
;;;1472   
                          ENDP


                          AREA ||i.I2C_SMBusClearInterruptFlag||, CODE, READONLY, ALIGN=1

                  I2C_SMBusClearInterruptFlag PROC
;;;460     */
;;;461    void I2C_SMBusClearInterruptFlag(I2C_T *i2c, uint8_t u8SMBusIntFlag)
000000  6581              STR      r1,[r0,#0x58]
;;;462    {
;;;463        i2c->BUSSTS = u8SMBusIntFlag;
;;;464    }
000002  4770              BX       lr
;;;465    
                          ENDP


                          AREA ||i.I2C_SMBusClockLoTimeout||, CODE, READONLY, ALIGN=1

                  I2C_SMBusClockLoTimeout PROC
;;;645    
;;;646    void I2C_SMBusClockLoTimeout(I2C_T *i2c, uint32_t ms, uint32_t u32Pclk)
000000  6d03              LDR      r3,[r0,#0x50]
;;;647    {
;;;648        uint32_t u32Div, u32Pclk_kHz;
;;;649    
;;;650        i2c->BUSCTL &= ~I2C_BUSCTL_TIDLE_Msk;
000002  f4237300          BIC      r3,r3,#0x200
000006  6503              STR      r3,[r0,#0x50]
;;;651    
;;;652        /* DIV4 disabled */
;;;653        i2c->TOCTL &= ~I2C_TOCTL_TOCEN_Msk;
000008  6943              LDR      r3,[r0,#0x14]
00000a  f0230304          BIC      r3,r3,#4
00000e  6143              STR      r3,[r0,#0x14]
;;;654        u32Pclk_kHz = u32Pclk / 1000U;
000010  f44f737a          MOV      r3,#0x3e8
000014  fbb2f2f3          UDIV     r2,r2,r3
;;;655        u32Div = ((ms * u32Pclk_kHz) / (16U * 1024U)) - 1U;
000018  4351              MULS     r1,r2,r1
00001a  f04f33ff          MOV      r3,#0xffffffff
00001e  eb033291          ADD      r2,r3,r1,LSR #14
;;;656        if(u32Div <= 0xFFU)
000022  2aff              CMP      r2,#0xff
000024  d801              BHI      |L21.42|
;;;657        {
;;;658            i2c->CLKTOUT = u32Div;
000026  6682              STR      r2,[r0,#0x68]
;;;659        }
;;;660        else
;;;661        {
;;;662            /* DIV4 enabled */
;;;663            i2c->TOCTL |= I2C_TOCTL_TOCEN_Msk;
;;;664            i2c->CLKTOUT = (((ms * u32Pclk_kHz) / (16U * 1024U * 4U)) - 1U) & 0xFFU; /* The max value is 255 */
;;;665        }
;;;666    }
000028  4770              BX       lr
                  |L21.42|
00002a  6942              LDR      r2,[r0,#0x14]         ;663
00002c  f0420204          ORR      r2,r2,#4              ;663
000030  6142              STR      r2,[r0,#0x14]         ;663
000032  eb034111          ADD      r1,r3,r1,LSR #16      ;664
000036  b2c9              UXTB     r1,r1                 ;664
000038  6681              STR      r1,[r0,#0x68]         ;664
00003a  4770              BX       lr
;;;667    
                          ENDP


                          AREA ||i.I2C_SMBusClose||, CODE, READONLY, ALIGN=1

                  I2C_SMBusClose PROC
;;;518     */
;;;519    void I2C_SMBusClose(I2C_T *i2c)
000000  2100              MOVS     r1,#0
;;;520    {
;;;521    
;;;522        i2c->BUSCTL = 0x00U;
000002  6501              STR      r1,[r0,#0x50]
;;;523    }
000004  4770              BX       lr
;;;524    
                          ENDP


                          AREA ||i.I2C_SMBusGetPECValue||, CODE, READONLY, ALIGN=1

                  I2C_SMBusGetPECValue PROC
;;;559     */
;;;560    uint8_t I2C_SMBusGetPECValue(I2C_T *i2c)
000000  6e00              LDR      r0,[r0,#0x60]
;;;561    {
;;;562        return (uint8_t)i2c->PKTCRC;
000002  b2c0              UXTB     r0,r0
;;;563    }
000004  4770              BX       lr
;;;564    
                          ENDP


                          AREA ||i.I2C_SMBusGetStatus||, CODE, READONLY, ALIGN=1

                  I2C_SMBusGetStatus PROC
;;;444     */
;;;445    uint32_t I2C_SMBusGetStatus(I2C_T *i2c)
000000  6d80              LDR      r0,[r0,#0x58]
;;;446    {
;;;447        return (i2c->BUSSTS);
;;;448    }
000002  4770              BX       lr
;;;449    
                          ENDP


                          AREA ||i.I2C_SMBusIdleTimeout||, CODE, READONLY, ALIGN=1

                  I2C_SMBusIdleTimeout PROC
;;;577    
;;;578    void I2C_SMBusIdleTimeout(I2C_T *i2c, uint32_t us, uint32_t u32Hclk)
000000  6d03              LDR      r3,[r0,#0x50]
;;;579    {
;;;580        uint32_t  u32Div, u32Hclk_kHz;
;;;581    
;;;582        i2c->BUSCTL |= I2C_BUSCTL_TIDLE_Msk;
000002  f4437300          ORR      r3,r3,#0x200
000006  6503              STR      r3,[r0,#0x50]
;;;583        u32Hclk_kHz = u32Hclk / 1000U;
000008  f44f737a          MOV      r3,#0x3e8
00000c  fbb2f2f3          UDIV     r2,r2,r3
;;;584        u32Div = (((us * u32Hclk_kHz) / 1000U) >> 2U) - 1U;
000010  4351              MULS     r1,r2,r1
000012  fbb1f1f3          UDIV     r1,r1,r3
000016  f04f32ff          MOV      r2,#0xffffffff
00001a  eb020191          ADD      r1,r2,r1,LSR #2
;;;585        if(u32Div > 255U)
00001e  29ff              CMP      r1,#0xff
000020  d900              BLS      |L25.36|
;;;586        {
;;;587            i2c->BUSTOUT = 0xFFU;
000022  21ff              MOVS     r1,#0xff
                  |L25.36|
;;;588        }
;;;589        else
;;;590        {
;;;591            i2c->BUSTOUT = u32Div;
000024  6641              STR      r1,[r0,#0x64]
;;;592        }
;;;593    
;;;594    }
000026  4770              BX       lr
;;;595    
                          ENDP


                          AREA ||i.I2C_SMBusOpen||, CODE, READONLY, ALIGN=1

                  I2C_SMBusOpen PROC
;;;492     */
;;;493    void I2C_SMBusOpen(I2C_T *i2c, uint8_t u8HostDevice)
000000  6d02              LDR      r2,[r0,#0x50]
;;;494    {
;;;495        /* Clear  BMHEN, BMDEN of BUSCTL Register */
;;;496        i2c->BUSCTL &=  ~(I2C_BUSCTL_BMHEN_Msk | I2C_BUSCTL_BMDEN_Msk);
000002  f022020c          BIC      r2,r2,#0xc
000006  6502              STR      r2,[r0,#0x50]
;;;497    
;;;498        /* Set SMBus Host/Device Mode, and enable Bus Management*/
;;;499        if(u8HostDevice == (uint8_t)I2C_SMBH_ENABLE)
000008  2901              CMP      r1,#1
;;;500        {
;;;501            i2c->BUSCTL |= (I2C_BUSCTL_BMHEN_Msk | I2C_BUSCTL_BUSEN_Msk);
;;;502        }
;;;503        else
;;;504        {
;;;505            i2c->BUSCTL |= (I2C_BUSCTL_BMDEN_Msk | I2C_BUSCTL_BUSEN_Msk);
00000a  6d01              LDR      r1,[r0,#0x50]
00000c  d003              BEQ      |L26.22|
00000e  f0410184          ORR      r1,r1,#0x84
                  |L26.18|
000012  6501              STR      r1,[r0,#0x50]         ;501
;;;506        }
;;;507    }
000014  4770              BX       lr
                  |L26.22|
000016  f0410188          ORR      r1,r1,#0x88           ;501
00001a  e7fa              B        |L26.18|
;;;508    
                          ENDP


                          AREA ||i.I2C_SMBusPECTxEnable||, CODE, READONLY, ALIGN=1

                  I2C_SMBusPECTxEnable PROC
;;;535     */
;;;536    void I2C_SMBusPECTxEnable(I2C_T *i2c, uint8_t u8PECTxEn)
000000  6d02              LDR      r2,[r0,#0x50]
;;;537    {
;;;538        i2c->BUSCTL &= ~I2C_BUSCTL_PECTXEN_Msk;
000002  f4227280          BIC      r2,r2,#0x100
000006  6502              STR      r2,[r0,#0x50]
;;;539    
;;;540        if(u8PECTxEn)
000008  2900              CMP      r1,#0
;;;541        {
;;;542            i2c->BUSCTL |= (I2C_BUSCTL_PECEN_Msk | I2C_BUSCTL_PECTXEN_Msk);
;;;543        }
;;;544        else
;;;545        {
;;;546            i2c->BUSCTL |= I2C_BUSCTL_PECEN_Msk;
00000a  6d01              LDR      r1,[r0,#0x50]
00000c  d002              BEQ      |L27.20|
00000e  f4417181          ORR      r1,r1,#0x102          ;542
000012  e001              B        |L27.24|
                  |L27.20|
000014  f0410102          ORR      r1,r1,#2
                  |L27.24|
000018  6501              STR      r1,[r0,#0x50]         ;542
;;;547        }
;;;548    }
00001a  4770              BX       lr
;;;549    
                          ENDP


                          AREA ||i.I2C_SMBusSetPacketByteCount||, CODE, READONLY, ALIGN=1

                  I2C_SMBusSetPacketByteCount PROC
;;;476     */
;;;477    void I2C_SMBusSetPacketByteCount(I2C_T *i2c, uint32_t u32PktSize)
000000  65c1              STR      r1,[r0,#0x5c]
;;;478    {
;;;479        i2c->PKTSIZE = u32PktSize;
;;;480    }
000002  4770              BX       lr
;;;481    
                          ENDP


                          AREA ||i.I2C_SMBusTimeout||, CODE, READONLY, ALIGN=1

                  I2C_SMBusTimeout PROC
;;;609    
;;;610    void I2C_SMBusTimeout(I2C_T *i2c, uint32_t ms, uint32_t u32Pclk)
000000  6d03              LDR      r3,[r0,#0x50]
;;;611    {
;;;612        uint32_t u32Div, u32Pclk_kHz;
;;;613    
;;;614        i2c->BUSCTL &= ~I2C_BUSCTL_TIDLE_Msk;
000002  f4237300          BIC      r3,r3,#0x200
000006  6503              STR      r3,[r0,#0x50]
;;;615    
;;;616        /* DIV4 disabled */
;;;617        i2c->TOCTL &= ~I2C_TOCTL_TOCEN_Msk;
000008  6943              LDR      r3,[r0,#0x14]
00000a  f0230304          BIC      r3,r3,#4
00000e  6143              STR      r3,[r0,#0x14]
;;;618        u32Pclk_kHz = u32Pclk / 1000U;
000010  f44f737a          MOV      r3,#0x3e8
000014  fbb2f2f3          UDIV     r2,r2,r3
;;;619        u32Div = ((ms * u32Pclk_kHz) / (16U * 1024U)) - 1U;
000018  4351              MULS     r1,r2,r1
00001a  f04f33ff          MOV      r3,#0xffffffff
00001e  eb033291          ADD      r2,r3,r1,LSR #14
;;;620        if(u32Div <= 0xFFU)
000022  2aff              CMP      r2,#0xff
000024  d801              BHI      |L29.42|
;;;621        {
;;;622            i2c->BUSTOUT = u32Div;
000026  6642              STR      r2,[r0,#0x64]
;;;623        }
;;;624        else
;;;625        {
;;;626            /* DIV4 enabled */
;;;627            i2c->TOCTL |= I2C_TOCTL_TOCEN_Msk;
;;;628            i2c->BUSTOUT = (((ms * u32Pclk_kHz) / (16U * 1024U * 4U)) - 1U) & 0xFFU; /* The max value is 255 */
;;;629        }
;;;630    }
000028  4770              BX       lr
                  |L29.42|
00002a  6942              LDR      r2,[r0,#0x14]         ;627
00002c  f0420204          ORR      r2,r2,#4              ;627
000030  6142              STR      r2,[r0,#0x14]         ;627
000032  eb034111          ADD      r1,r3,r1,LSR #16      ;628
000036  b2c9              UXTB     r1,r1                 ;628
000038  6641              STR      r1,[r0,#0x64]         ;628
00003a  4770              BX       lr
;;;631    
                          ENDP


                          AREA ||i.I2C_SetBusClockFreq||, CODE, READONLY, ALIGN=2

                  I2C_SetBusClockFreq PROC
;;;209     */
;;;210    uint32_t I2C_SetBusClockFreq(I2C_T *i2c, uint32_t u32BusClock)
000000  b570              PUSH     {r4-r6,lr}
;;;211    {
000002  4604              MOV      r4,r0
;;;212        uint32_t u32Div;
;;;213        uint32_t u32Pclk;
;;;214    
;;;215        if(i2c == I2C1)
000004  480c              LDR      r0,|L30.56|
000006  460d              MOV      r5,r1                 ;211
000008  4284              CMP      r4,r0
00000a  d102              BNE      |L30.18|
;;;216        {
;;;217            u32Pclk = CLK_GetPCLK1Freq();
00000c  f7fffffe          BL       CLK_GetPCLK1Freq
000010  e001              B        |L30.22|
                  |L30.18|
;;;218        }
;;;219        else
;;;220        {
;;;221            u32Pclk = CLK_GetPCLK0Freq();
000012  f7fffffe          BL       CLK_GetPCLK0Freq
                  |L30.22|
;;;222        }
;;;223    
;;;224        u32Div = (uint32_t)(((u32Pclk * 10U) / (u32BusClock * 4U) + 5U) / 10U - 1U); /* Compute proper divider for I2C clock */
000016  eb000180          ADD      r1,r0,r0,LSL #2
00001a  0049              LSLS     r1,r1,#1
00001c  00aa              LSLS     r2,r5,#2
00001e  fbb1f1f2          UDIV     r1,r1,r2
000022  220a              MOVS     r2,#0xa
000024  1d49              ADDS     r1,r1,#5
000026  fbb1f1f2          UDIV     r1,r1,r2
00002a  1e4a              SUBS     r2,r1,#1
;;;225        i2c->CLKDIV = u32Div;
00002c  6122              STR      r2,[r4,#0x10]
;;;226    
;;;227        return (u32Pclk / ((u32Div + 1U) << 2U));
;;;228    }
00002e  0089              LSLS     r1,r1,#2
000030  fbb0f0f1          UDIV     r0,r0,r1              ;227
000034  bd70              POP      {r4-r6,pc}
;;;229    
                          ENDP

000036  0000              DCW      0x0000
                  |L30.56|
                          DCD      0x40081000

                          AREA ||i.I2C_SetData||, CODE, READONLY, ALIGN=1

                  I2C_SetData PROC
;;;292     */
;;;293    void I2C_SetData(I2C_T *i2c, uint8_t u8Data)
000000  6081              STR      r1,[r0,#8]
;;;294    {
;;;295        i2c->DAT = u8Data;
;;;296    }
000002  4770              BX       lr
;;;297    
                          ENDP


                          AREA ||i.I2C_SetSlaveAddr||, CODE, READONLY, ALIGN=1

                  I2C_SetSlaveAddr PROC
;;;311     */
;;;312    void I2C_SetSlaveAddr(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddr, uint8_t u8GCMode)
000000  ea430242          ORR      r2,r3,r2,LSL #1
;;;313    {
;;;314        switch(u8SlaveNo)
000004  2901              CMP      r1,#1
000006  d005              BEQ      |L32.20|
000008  2902              CMP      r1,#2
00000a  d005              BEQ      |L32.24|
00000c  2903              CMP      r1,#3
00000e  d005              BEQ      |L32.28|
;;;315        {
;;;316        case 1:
;;;317            i2c->ADDR1  = ((uint32_t)u8SlaveAddr << 1U) | u8GCMode;
;;;318            break;
;;;319        case 2:
;;;320            i2c->ADDR2  = ((uint32_t)u8SlaveAddr << 1U) | u8GCMode;
;;;321            break;
;;;322        case 3:
;;;323            i2c->ADDR3  = ((uint32_t)u8SlaveAddr << 1U) | u8GCMode;
;;;324            break;
;;;325        case 0:
;;;326        default:
;;;327            i2c->ADDR0  = ((uint32_t)u8SlaveAddr << 1U) | u8GCMode;
000010  6042              STR      r2,[r0,#4]
;;;328            break;
;;;329        }
;;;330    }
000012  4770              BX       lr
                  |L32.20|
000014  6182              STR      r2,[r0,#0x18]         ;317
000016  4770              BX       lr
                  |L32.24|
000018  61c2              STR      r2,[r0,#0x1c]         ;320
00001a  4770              BX       lr
                  |L32.28|
00001c  6202              STR      r2,[r0,#0x20]         ;323
00001e  4770              BX       lr
;;;331    
                          ENDP


                          AREA ||i.I2C_SetSlaveAddrMask||, CODE, READONLY, ALIGN=1

                  I2C_SetSlaveAddrMask PROC
;;;343     */
;;;344    void I2C_SetSlaveAddrMask(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddrMask)
000000  0052              LSLS     r2,r2,#1
;;;345    {
;;;346        switch(u8SlaveNo)
000002  2901              CMP      r1,#1
000004  d005              BEQ      |L33.18|
000006  2902              CMP      r1,#2
000008  d005              BEQ      |L33.22|
00000a  2903              CMP      r1,#3
00000c  d005              BEQ      |L33.26|
;;;347        {
;;;348        case 1:
;;;349            i2c->ADDRMSK1  = (uint32_t)u8SlaveAddrMask << 1U;
;;;350            break;
;;;351        case 2:
;;;352            i2c->ADDRMSK2  = (uint32_t)u8SlaveAddrMask << 1U;
;;;353            break;
;;;354        case 3:
;;;355            i2c->ADDRMSK3  = (uint32_t)u8SlaveAddrMask << 1U;
;;;356            break;
;;;357        case 0:
;;;358        default:
;;;359            i2c->ADDRMSK0  = (uint32_t)u8SlaveAddrMask << 1U;
00000e  6242              STR      r2,[r0,#0x24]
;;;360            break;
;;;361        }
;;;362    }
000010  4770              BX       lr
                  |L33.18|
000012  6282              STR      r2,[r0,#0x28]         ;349
000014  4770              BX       lr
                  |L33.22|
000016  62c2              STR      r2,[r0,#0x2c]         ;352
000018  4770              BX       lr
                  |L33.26|
00001a  6302              STR      r2,[r0,#0x30]         ;355
00001c  4770              BX       lr
;;;363    
                          ENDP


                          AREA ||i.I2C_Trigger||, CODE, READONLY, ALIGN=1

                  I2C_Trigger PROC
;;;116      */
;;;117    void I2C_Trigger(I2C_T *i2c, uint8_t u8Start, uint8_t u8Stop, uint8_t u8Si, uint8_t u8Ack)
000000  b530              PUSH     {r4,r5,lr}
;;;118    {
;;;119        uint32_t u32Reg = 0U;
000002  2400              MOVS     r4,#0
000004  9d03              LDR      r5,[sp,#0xc]          ;118
000006  b101              CBZ      r1,|L34.10|
;;;120    
;;;121        if(u8Start)
;;;122        {
;;;123            u32Reg |= I2C_CTL_STA;
000008  2420              MOVS     r4,#0x20
                  |L34.10|
;;;124        }
;;;125    
;;;126        if(u8Stop)
00000a  b10a              CBZ      r2,|L34.16|
;;;127        {
;;;128            u32Reg |= I2C_CTL_STO;
00000c  f0440410          ORR      r4,r4,#0x10
                  |L34.16|
;;;129        }
;;;130    
;;;131        if(u8Si)
000010  b10b              CBZ      r3,|L34.22|
;;;132        {
;;;133            u32Reg |= I2C_CTL_SI;
000012  f0440408          ORR      r4,r4,#8
                  |L34.22|
;;;134        }
;;;135    
;;;136        if(u8Ack)
000016  b10d              CBZ      r5,|L34.28|
;;;137        {
;;;138            u32Reg |= I2C_CTL_AA;
000018  f0440404          ORR      r4,r4,#4
                  |L34.28|
;;;139        }
;;;140    
;;;141        i2c->CTL0 = (i2c->CTL0 & ~0x3CU) | u32Reg;
00001c  6801              LDR      r1,[r0,#0]
00001e  f021013c          BIC      r1,r1,#0x3c
000022  4321              ORRS     r1,r1,r4
000024  6001              STR      r1,[r0,#0]
;;;142    }
000026  bd30              POP      {r4,r5,pc}
;;;143    
                          ENDP


                          AREA ||i.I2C_WriteByte||, CODE, READONLY, ALIGN=1

                  I2C_WriteByte PROC
;;;682    
;;;683    uint8_t I2C_WriteByte(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t data)
000000  b570              PUSH     {r4-r6,lr}
;;;684    {
;;;685        uint8_t u8Xfering = 1u, u8Err = 0u, u8Ctrl = 0u;
000002  2501              MOVS     r5,#1
000004  2400              MOVS     r4,#0
;;;686    
;;;687        I2C_START(i2c);
000006  6806              LDR      r6,[r0,#0]
000008  4623              MOV      r3,r4                 ;685
00000a  f0260608          BIC      r6,r6,#8
00000e  f0460620          ORR      r6,r6,#0x20
000012  6006              STR      r6,[r0,#0]
;;;688        while(u8Xfering && (u8Err == 0u))
;;;689        {
;;;690            I2C_WAIT_READY(i2c) {}
;;;691            switch(I2C_GET_STATUS(i2c))
;;;692            {
;;;693            case 0x08u:
;;;694                I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1u | 0x00u));    /* Write SLA+W to Register I2CDAT */
000014  0649              LSLS     r1,r1,#25
000016  0e0e              LSRS     r6,r1,#24
                  |L35.24|
000018  6801              LDR      r1,[r0,#0]            ;690
00001a  0709              LSLS     r1,r1,#28             ;690
00001c  d5fc              BPL      |L35.24|
00001e  68c1              LDR      r1,[r0,#0xc]          ;691
000020  2920              CMP      r1,#0x20              ;691
000022  d016              BEQ      |L35.82|
000024  dc04              BGT      |L35.48|
000026  2908              CMP      r1,#8                 ;691
000028  d00e              BEQ      |L35.72|
00002a  2918              CMP      r1,#0x18              ;691
00002c  d104              BNE      |L35.56|
00002e  e00e              B        |L35.78|
                  |L35.48|
000030  2928              CMP      r1,#0x28              ;691
000032  d011              BEQ      |L35.88|
000034  2930              CMP      r1,#0x30              ;691
000036  d00c              BEQ      |L35.82|
                  |L35.56|
;;;695                u8Ctrl = I2C_CTL_SI;                              /* Clear SI */
;;;696                break;
;;;697            case 0x18u:                                           /* Slave Address ACK */
;;;698                I2C_SET_DATA(i2c, data);                          /* Write data to I2CDAT */
;;;699                break;
;;;700            case 0x20u:                                           /* Slave Address NACK */
;;;701            case 0x30u:                                           /* Master transmit data NACK */
;;;702                u8Ctrl = I2C_CTL_STO_SI;                          /* Clear SI and send STOP */
;;;703                u8Err = 1u;
;;;704                break;
;;;705            case 0x28u:
;;;706                u8Ctrl = I2C_CTL_STO_SI;                          /* Clear SI and send STOP */
;;;707                u8Xfering = 0u;
;;;708                break;
;;;709            case 0x38u:                                           /* Arbitration Lost */
;;;710            default:                                              /* Unknow status */
;;;711                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
000038  6801              LDR      r1,[r0,#0]
00003a  f021013c          BIC      r1,r1,#0x3c
00003e  f0410118          ORR      r1,r1,#0x18
000042  6001              STR      r1,[r0,#0]
;;;712                u8Ctrl = I2C_CTL_SI;
000044  2308              MOVS     r3,#8
;;;713                u8Err = 1u;
;;;714                break;
000046  e005              B        |L35.84|
                  |L35.72|
000048  6086              STR      r6,[r0,#8]            ;694
00004a  2308              MOVS     r3,#8                 ;695
00004c  e006              B        |L35.92|
                  |L35.78|
00004e  6082              STR      r2,[r0,#8]            ;698
000050  e004              B        |L35.92|
                  |L35.82|
000052  2318              MOVS     r3,#0x18              ;702
                  |L35.84|
000054  2401              MOVS     r4,#1                 ;703
000056  e001              B        |L35.92|
                  |L35.88|
000058  2318              MOVS     r3,#0x18              ;706
00005a  2500              MOVS     r5,#0                 ;707
                  |L35.92|
;;;715            }
;;;716            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                        /* Write controlbit to I2C_CTL register */
00005c  6801              LDR      r1,[r0,#0]
00005e  f021013c          BIC      r1,r1,#0x3c
000062  4319              ORRS     r1,r1,r3
000064  6001              STR      r1,[r0,#0]
000066  b10d              CBZ      r5,|L35.108|
000068  2c00              CMP      r4,#0                 ;688
00006a  d0d5              BEQ      |L35.24|
                  |L35.108|
;;;717        }
;;;718        return (u8Err | u8Xfering);                                  /* return (Success)/(Fail) status */
00006c  ea440005          ORR      r0,r4,r5
;;;719    }
000070  bd70              POP      {r4-r6,pc}
;;;720    
                          ENDP


                          AREA ||i.I2C_WriteByteOneReg||, CODE, READONLY, ALIGN=1

                  I2C_WriteByteOneReg PROC
;;;793    
;;;794    uint8_t I2C_WriteByteOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, uint8_t data)
000000  b5f0              PUSH     {r4-r7,lr}
;;;795    {
;;;796        uint8_t u8Xfering = 1u, u8Err = 0u, u8Ctrl = 0u;
000002  2701              MOVS     r7,#1
000004  2600              MOVS     r6,#0
;;;797        uint32_t u32txLen = 0u;
;;;798    
;;;799        I2C_START(i2c);                                              /* Send START */
000006  6804              LDR      r4,[r0,#0]
000008  4635              MOV      r5,r6                 ;796
00000a  46b4              MOV      r12,r6                ;797
00000c  f0240408          BIC      r4,r4,#8
000010  f0440420          ORR      r4,r4,#0x20
000014  6004              STR      r4,[r0,#0]
                  |L36.22|
;;;800        while(u8Xfering && (u8Err == 0u))
;;;801        {
;;;802            I2C_WAIT_READY(i2c) {}
000016  6804              LDR      r4,[r0,#0]
000018  0724              LSLS     r4,r4,#28
00001a  d5fc              BPL      |L36.22|
;;;803            switch(I2C_GET_STATUS(i2c))
00001c  68c4              LDR      r4,[r0,#0xc]
00001e  2c20              CMP      r4,#0x20
000020  d018              BEQ      |L36.84|
000022  dc04              BGT      |L36.46|
000024  2c08              CMP      r4,#8
000026  d00e              BEQ      |L36.70|
000028  2c18              CMP      r4,#0x18
00002a  d104              BNE      |L36.54|
00002c  e010              B        |L36.80|
                  |L36.46|
00002e  2c28              CMP      r4,#0x28
000030  d013              BEQ      |L36.90|
000032  2c30              CMP      r4,#0x30
000034  d00e              BEQ      |L36.84|
                  |L36.54|
;;;804            {
;;;805            case 0x08u:
;;;806                I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1u | 0x00u));    /* Send Slave address with write bit */
;;;807                u8Ctrl = I2C_CTL_SI;                           /* Clear SI */
;;;808                break;
;;;809            case 0x18u:                                           /* Slave Address ACK */
;;;810                I2C_SET_DATA(i2c, u8DataAddr);                   /* Write Lo byte address of register */
;;;811                break;
;;;812            case 0x20u:                                           /* Slave Address NACK */
;;;813            case 0x30u:                                           /* Master transmit data NACK */
;;;814                u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;815                u8Err = 1u;
;;;816                break;
;;;817            case 0x28u:
;;;818                if(u32txLen < 1u)
;;;819                {
;;;820                    I2C_SET_DATA(i2c, data);
;;;821                    u32txLen++;
;;;822                }
;;;823                else
;;;824                {
;;;825                    u8Ctrl = I2C_CTL_STO_SI;                   /* Clear SI and send STOP */
;;;826                    u8Xfering = 0u;
;;;827                }
;;;828                break;
;;;829            case 0x38u:                                           /* Arbitration Lost */
;;;830            default:                                             /* Unknow status */
;;;831                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
000036  6804              LDR      r4,[r0,#0]
000038  f024043c          BIC      r4,r4,#0x3c
00003c  f0440418          ORR      r4,r4,#0x18
000040  6004              STR      r4,[r0,#0]
;;;832                u8Ctrl = I2C_CTL_SI;
000042  2508              MOVS     r5,#8
;;;833                u8Err = 1u;
;;;834                break;
000044  e007              B        |L36.86|
                  |L36.70|
000046  064c              LSLS     r4,r1,#25             ;806
000048  0e24              LSRS     r4,r4,#24             ;806
00004a  6084              STR      r4,[r0,#8]            ;806
00004c  2508              MOVS     r5,#8                 ;807
00004e  e00d              B        |L36.108|
                  |L36.80|
000050  6082              STR      r2,[r0,#8]            ;810
000052  e00b              B        |L36.108|
                  |L36.84|
000054  2518              MOVS     r5,#0x18              ;814
                  |L36.86|
000056  2601              MOVS     r6,#1                 ;815
000058  e008              B        |L36.108|
                  |L36.90|
00005a  f1bc0f00          CMP      r12,#0                ;818
00005e  d002              BEQ      |L36.102|
000060  2518              MOVS     r5,#0x18              ;825
000062  2700              MOVS     r7,#0                 ;826
000064  e002              B        |L36.108|
                  |L36.102|
000066  6083              STR      r3,[r0,#8]            ;820
000068  f04f0c01          MOV      r12,#1                ;821
                  |L36.108|
;;;835            }
;;;836            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                        /* Write controlbit to I2C_CTL register */
00006c  6804              LDR      r4,[r0,#0]
00006e  f024043c          BIC      r4,r4,#0x3c
000072  432c              ORRS     r4,r4,r5
000074  6004              STR      r4,[r0,#0]
000076  b10f              CBZ      r7,|L36.124|
000078  2e00              CMP      r6,#0                 ;800
00007a  d0cc              BEQ      |L36.22|
                  |L36.124|
;;;837        }
;;;838        return (u8Err | u8Xfering);                                  /* return (Success)/(Fail) status */
00007c  ea460007          ORR      r0,r6,r7
;;;839    }
000080  bdf0              POP      {r4-r7,pc}
;;;840    
                          ENDP


                          AREA ||i.I2C_WriteByteTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_WriteByteTwoRegs PROC
;;;918    
;;;919    uint8_t I2C_WriteByteTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, uint8_t data)
000000  b5f0              PUSH     {r4-r7,lr}
;;;920    {
;;;921        uint8_t u8Xfering = 1u, u8Err = 0u, u8Addr = 1u, u8Ctrl = 0u;
000002  2701              MOVS     r7,#1
000004  2600              MOVS     r6,#0
;;;922        uint32_t u32txLen = 0u;
;;;923    
;;;924        I2C_START(i2c);                                                         /* Send START */
000006  6804              LDR      r4,[r0,#0]
000008  46be              MOV      lr,r7                 ;921
00000a  4635              MOV      r5,r6                 ;921
00000c  46b4              MOV      r12,r6                ;922
00000e  f0240408          BIC      r4,r4,#8
000012  f0440420          ORR      r4,r4,#0x20
000016  6004              STR      r4,[r0,#0]
                  |L37.24|
;;;925        while(u8Xfering && (u8Err == 0u))
;;;926        {
;;;927            I2C_WAIT_READY(i2c) {}
000018  6804              LDR      r4,[r0,#0]
00001a  0724              LSLS     r4,r4,#28
00001c  d5fc              BPL      |L37.24|
;;;928            switch(I2C_GET_STATUS(i2c))
00001e  68c4              LDR      r4,[r0,#0xc]
000020  2c20              CMP      r4,#0x20
000022  d019              BEQ      |L37.88|
000024  dc04              BGT      |L37.48|
000026  2c08              CMP      r4,#8
000028  d00e              BEQ      |L37.72|
00002a  2c18              CMP      r4,#0x18
00002c  d104              BNE      |L37.56|
00002e  e010              B        |L37.82|
                  |L37.48|
000030  2c28              CMP      r4,#0x28
000032  d014              BEQ      |L37.94|
000034  2c30              CMP      r4,#0x30
000036  d00f              BEQ      |L37.88|
                  |L37.56|
;;;929            {
;;;930            case 0x08u:
;;;931                I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1u | 0x00u));               /* Write SLA+W to Register I2CDAT */
;;;932                u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;933                break;
;;;934            case 0x18u:                                                      /* Slave Address ACK */
;;;935                I2C_SET_DATA(i2c, (uint8_t)((u16DataAddr & 0xFF00u) >> 8u));    /* Write Hi byte address of register */
;;;936                break;
;;;937            case 0x20u:                                                      /* Slave Address NACK */
;;;938            case 0x30u:                                                      /* Master transmit data NACK */
;;;939                u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;940                u8Err = 1u;
;;;941                break;
;;;942            case 0x28u:
;;;943                if(u8Addr)
;;;944                {
;;;945                    I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFFu));       /* Write Lo byte address of register */
;;;946                    u8Addr = 0u;
;;;947                }
;;;948                else if((u32txLen < 1u) && (u8Addr == 0u))
;;;949                {
;;;950                    I2C_SET_DATA(i2c, data);
;;;951                    u32txLen++;
;;;952                }
;;;953                else
;;;954                {
;;;955                    u8Ctrl = I2C_CTL_STO_SI;                              /* Clear SI and send STOP */
;;;956                    u8Xfering = 0u;
;;;957                }
;;;958                break;
;;;959            case 0x38u:                                                      /* Arbitration Lost */
;;;960            default:                                                        /* Unknow status */
;;;961                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);                   /* Clear SI and send STOP */
000038  6804              LDR      r4,[r0,#0]
00003a  f024043c          BIC      r4,r4,#0x3c
00003e  f0440418          ORR      r4,r4,#0x18
000042  6004              STR      r4,[r0,#0]
;;;962                u8Ctrl = I2C_CTL_SI;
000044  2508              MOVS     r5,#8
;;;963                u8Err = 1u;
;;;964                break;
000046  e008              B        |L37.90|
                  |L37.72|
000048  064c              LSLS     r4,r1,#25             ;931
00004a  0e24              LSRS     r4,r4,#24             ;931
00004c  6084              STR      r4,[r0,#8]            ;931
00004e  2508              MOVS     r5,#8                 ;932
000050  e016              B        |L37.128|
                  |L37.82|
000052  0a14              LSRS     r4,r2,#8              ;935
000054  6084              STR      r4,[r0,#8]            ;935
000056  e013              B        |L37.128|
                  |L37.88|
000058  2518              MOVS     r5,#0x18              ;939
                  |L37.90|
00005a  2601              MOVS     r6,#1                 ;940
00005c  e010              B        |L37.128|
                  |L37.94|
00005e  f1be0f00          CMP      lr,#0                 ;943
000062  d004              BEQ      |L37.110|
000064  b2d4              UXTB     r4,r2                 ;945
000066  6084              STR      r4,[r0,#8]            ;945
000068  f04f0e00          MOV      lr,#0                 ;946
00006c  e008              B        |L37.128|
                  |L37.110|
00006e  f1bc0f00          CMP      r12,#0                ;948
000072  d002              BEQ      |L37.122|
000074  2518              MOVS     r5,#0x18              ;955
000076  2700              MOVS     r7,#0                 ;956
000078  e002              B        |L37.128|
                  |L37.122|
00007a  6083              STR      r3,[r0,#8]            ;950
00007c  f04f0c01          MOV      r12,#1                ;951
                  |L37.128|
;;;965            }
;;;966            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                   /* Write controlbit to I2C_CTL register */
000080  6804              LDR      r4,[r0,#0]
000082  f024043c          BIC      r4,r4,#0x3c
000086  432c              ORRS     r4,r4,r5
000088  6004              STR      r4,[r0,#0]
00008a  b10f              CBZ      r7,|L37.144|
00008c  2e00              CMP      r6,#0                 ;925
00008e  d0c3              BEQ      |L37.24|
                  |L37.144|
;;;967        }
;;;968        return (u8Err | u8Xfering);                                             /* return (Success)/(Fail) status */
000090  ea460007          ORR      r0,r6,r7
;;;969    }
000094  bdf0              POP      {r4-r7,pc}
;;;970    
                          ENDP


                          AREA ||i.I2C_WriteMultiBytes||, CODE, READONLY, ALIGN=1

                  I2C_WriteMultiBytes PROC
;;;734    
;;;735    uint32_t I2C_WriteMultiBytes(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t data[], uint32_t u32wLen)
000000  b5f0              PUSH     {r4-r7,lr}
;;;736    {
;;;737        uint8_t u8Xfering = 1u, u8Err = 0u, u8Ctrl = 0u;
000002  2700              MOVS     r7,#0
;;;738        uint32_t u32txLen = 0u;
;;;739    
;;;740        I2C_START(i2c);                                              /* Send START */
000004  6804              LDR      r4,[r0,#0]
000006  f04f0c01          MOV      r12,#1                ;737
00000a  463d              MOV      r5,r7                 ;737
00000c  463e              MOV      r6,r7                 ;738
00000e  f0240408          BIC      r4,r4,#8
000012  f0440420          ORR      r4,r4,#0x20
000016  6004              STR      r4,[r0,#0]
                  |L38.24|
;;;741        while(u8Xfering && (u8Err == 0u))
;;;742        {
;;;743            I2C_WAIT_READY(i2c) {}
000018  6804              LDR      r4,[r0,#0]
00001a  0724              LSLS     r4,r4,#28
00001c  d5fc              BPL      |L38.24|
;;;744            switch(I2C_GET_STATUS(i2c))
00001e  68c4              LDR      r4,[r0,#0xc]
000020  2c20              CMP      r4,#0x20
000022  d020              BEQ      |L38.102|
000024  dc04              BGT      |L38.48|
000026  2c08              CMP      r4,#8
000028  d00e              BEQ      |L38.72|
00002a  2c18              CMP      r4,#0x18
00002c  d104              BNE      |L38.56|
00002e  e010              B        |L38.82|
                  |L38.48|
000030  2c28              CMP      r4,#0x28
000032  d00e              BEQ      |L38.82|
000034  2c30              CMP      r4,#0x30
000036  d016              BEQ      |L38.102|
                  |L38.56|
;;;745            {
;;;746            case 0x08u:
;;;747                I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1u | 0x00u));    /* Write SLA+W to Register I2CDAT */
;;;748                u8Ctrl = I2C_CTL_SI;                           /* Clear SI */
;;;749                break;
;;;750            case 0x18u:                                           /* Slave Address ACK */
;;;751            case 0x28u:
;;;752                if(u32txLen < u32wLen)
;;;753                {
;;;754                    I2C_SET_DATA(i2c, data[u32txLen++]);                /* Write Data to I2CDAT */
;;;755                }
;;;756                else
;;;757                {
;;;758                    u8Ctrl = I2C_CTL_STO_SI;                   /* Clear SI and send STOP */
;;;759                    u8Xfering = 0u;
;;;760                }
;;;761                break;
;;;762            case 0x20u:                                           /* Slave Address NACK */
;;;763            case 0x30u:                                           /* Master transmit data NACK */
;;;764                u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;765                u8Err = 1u;
;;;766                break;
;;;767            case 0x38u:                                           /* Arbitration Lost */
;;;768            default:                                             /* Unknow status */
;;;769                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
000038  6804              LDR      r4,[r0,#0]
00003a  f024043c          BIC      r4,r4,#0x3c
00003e  f0440418          ORR      r4,r4,#0x18
000042  6004              STR      r4,[r0,#0]
;;;770                u8Ctrl = I2C_CTL_SI;
000044  2508              MOVS     r5,#8
;;;771                u8Err = 1u;
;;;772                break;
000046  e00f              B        |L38.104|
                  |L38.72|
000048  064c              LSLS     r4,r1,#25             ;747
00004a  0e24              LSRS     r4,r4,#24             ;747
00004c  6084              STR      r4,[r0,#8]            ;747
00004e  2508              MOVS     r5,#8                 ;748
000050  e00b              B        |L38.106|
                  |L38.82|
000052  429e              CMP      r6,r3                 ;752
000054  d203              BCS      |L38.94|
000056  5d94              LDRB     r4,[r2,r6]            ;754
000058  6084              STR      r4,[r0,#8]            ;754
00005a  1c76              ADDS     r6,r6,#1              ;754
00005c  e005              B        |L38.106|
                  |L38.94|
00005e  2518              MOVS     r5,#0x18              ;758
000060  f04f0c00          MOV      r12,#0                ;759
000064  e001              B        |L38.106|
                  |L38.102|
000066  2518              MOVS     r5,#0x18              ;764
                  |L38.104|
000068  2701              MOVS     r7,#1                 ;765
                  |L38.106|
;;;773            }
;;;774            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                        /* Write controlbit to I2C_CTL register */
00006a  6804              LDR      r4,[r0,#0]
00006c  f024043c          BIC      r4,r4,#0x3c
000070  432c              ORRS     r4,r4,r5
000072  6004              STR      r4,[r0,#0]
000074  f1bc0f00          CMP      r12,#0                ;741
000078  d001              BEQ      |L38.126|
00007a  2f00              CMP      r7,#0                 ;741
00007c  d0cc              BEQ      |L38.24|
                  |L38.126|
;;;775        }
;;;776        return u32txLen;                                             /* Return bytes length that have been transmitted */
00007e  4630              MOV      r0,r6
;;;777    }
000080  bdf0              POP      {r4-r7,pc}
;;;778    
                          ENDP


                          AREA ||i.I2C_WriteMultiBytesOneReg||, CODE, READONLY, ALIGN=1

                  I2C_WriteMultiBytesOneReg PROC
;;;856    
;;;857    uint32_t I2C_WriteMultiBytesOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, uint8_t data[], uint32_t u32wLen)
000000  b5f0              PUSH     {r4-r7,lr}
;;;858    {
;;;859        uint8_t u8Xfering = 1u, u8Err = 0u, u8Ctrl = 0u;
000002  2700              MOVS     r7,#0
;;;860        uint32_t u32txLen = 0u;
;;;861    
;;;862        I2C_START(i2c);                                              /* Send START */
000004  f8dde014          LDR      lr,[sp,#0x14]
000008  6804              LDR      r4,[r0,#0]
00000a  f04f0c01          MOV      r12,#1                ;859
00000e  463d              MOV      r5,r7                 ;859
000010  463e              MOV      r6,r7                 ;860
000012  f0240408          BIC      r4,r4,#8
000016  f0440420          ORR      r4,r4,#0x20
00001a  6004              STR      r4,[r0,#0]
                  |L39.28|
;;;863        while(u8Xfering && (u8Err == 0u))
;;;864        {
;;;865            I2C_WAIT_READY(i2c) {}
00001c  6804              LDR      r4,[r0,#0]
00001e  0724              LSLS     r4,r4,#28
000020  d5fc              BPL      |L39.28|
;;;866            switch(I2C_GET_STATUS(i2c))
000022  68c4              LDR      r4,[r0,#0xc]
000024  2c20              CMP      r4,#0x20
000026  d018              BEQ      |L39.90|
000028  dc04              BGT      |L39.52|
00002a  2c08              CMP      r4,#8
00002c  d00e              BEQ      |L39.76|
00002e  2c18              CMP      r4,#0x18
000030  d104              BNE      |L39.60|
000032  e010              B        |L39.86|
                  |L39.52|
000034  2c28              CMP      r4,#0x28
000036  d013              BEQ      |L39.96|
000038  2c30              CMP      r4,#0x30
00003a  d00e              BEQ      |L39.90|
                  |L39.60|
;;;867            {
;;;868            case 0x08u:
;;;869                I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1u | 0x00u));    /* Write SLA+W to Register I2CDAT */
;;;870                u8Ctrl = I2C_CTL_SI;
;;;871                break;
;;;872            case 0x18u:                                           /* Slave Address ACK */
;;;873                I2C_SET_DATA(i2c, u8DataAddr);                   /* Write Lo byte address of register */
;;;874                break;
;;;875            case 0x20u:                                           /* Slave Address NACK */
;;;876            case 0x30u:                                           /* Master transmit data NACK */
;;;877                u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;878                u8Err = 1u;
;;;879                break;
;;;880            case 0x28u:
;;;881                if(u32txLen < u32wLen)
;;;882                {
;;;883                    I2C_SET_DATA(i2c, data[u32txLen++]);
;;;884                }
;;;885                else
;;;886                {
;;;887                    u8Ctrl = I2C_CTL_STO_SI;                   /* Clear SI and send STOP */
;;;888                    u8Xfering = 0u;
;;;889                }
;;;890                break;
;;;891            case 0x38u:                                           /* Arbitration Lost */
;;;892            default:                                             /* Unknow status */
;;;893                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);        /* Clear SI and send STOP */
00003c  6804              LDR      r4,[r0,#0]
00003e  f024043c          BIC      r4,r4,#0x3c
000042  f0440418          ORR      r4,r4,#0x18
000046  6004              STR      r4,[r0,#0]
;;;894                u8Ctrl = I2C_CTL_SI;
000048  2508              MOVS     r5,#8
;;;895                u8Err = 1u;
;;;896                break;
00004a  e007              B        |L39.92|
                  |L39.76|
00004c  064c              LSLS     r4,r1,#25             ;869
00004e  0e24              LSRS     r4,r4,#24             ;869
000050  6084              STR      r4,[r0,#8]            ;869
000052  2508              MOVS     r5,#8                 ;870
000054  e00d              B        |L39.114|
                  |L39.86|
000056  6082              STR      r2,[r0,#8]            ;873
000058  e00b              B        |L39.114|
                  |L39.90|
00005a  2518              MOVS     r5,#0x18              ;877
                  |L39.92|
00005c  2701              MOVS     r7,#1                 ;878
00005e  e008              B        |L39.114|
                  |L39.96|
000060  4576              CMP      r6,lr                 ;881
000062  d203              BCS      |L39.108|
000064  5d9c              LDRB     r4,[r3,r6]            ;883
000066  6084              STR      r4,[r0,#8]            ;883
000068  1c76              ADDS     r6,r6,#1              ;883
00006a  e002              B        |L39.114|
                  |L39.108|
00006c  2518              MOVS     r5,#0x18              ;887
00006e  f04f0c00          MOV      r12,#0                ;888
                  |L39.114|
;;;897            }
;;;898            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                        /* Write controlbit to I2C_CTL register */
000072  6804              LDR      r4,[r0,#0]
000074  f024043c          BIC      r4,r4,#0x3c
000078  432c              ORRS     r4,r4,r5
00007a  6004              STR      r4,[r0,#0]
00007c  f1bc0f00          CMP      r12,#0                ;863
000080  d001              BEQ      |L39.134|
000082  2f00              CMP      r7,#0                 ;863
000084  d0ca              BEQ      |L39.28|
                  |L39.134|
;;;899        }
;;;900    
;;;901        return u32txLen;                                             /* Return bytes length that have been transmitted */
000086  4630              MOV      r0,r6
;;;902    }
000088  bdf0              POP      {r4-r7,pc}
;;;903    
                          ENDP


                          AREA ||i.I2C_WriteMultiBytesTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_WriteMultiBytesTwoRegs PROC
;;;986    
;;;987    uint32_t I2C_WriteMultiBytesTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, uint8_t data[], uint32_t u32wLen)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;988    {
;;;989        uint8_t u8Xfering = 1u, u8Err = 0u, u8Addr = 1u, u8Ctrl = 0u;
000004  2700              MOVS     r7,#0
000006  f04f0801          MOV      r8,#1
;;;990        uint32_t u32txLen = 0u;
;;;991    
;;;992        I2C_START(i2c);                                                         /* Send START */
00000a  f8dd901c          LDR      r9,[sp,#0x1c]
00000e  6804              LDR      r4,[r0,#0]
000010  46c4              MOV      r12,r8                ;989
000012  463d              MOV      r5,r7                 ;989
000014  463e              MOV      r6,r7                 ;990
000016  f0240408          BIC      r4,r4,#8
00001a  f0440420          ORR      r4,r4,#0x20
00001e  6004              STR      r4,[r0,#0]
                  |L40.32|
;;;993        while(u8Xfering && (u8Err == 0u))
;;;994        {
;;;995            I2C_WAIT_READY(i2c) {}
000020  6804              LDR      r4,[r0,#0]
000022  0724              LSLS     r4,r4,#28
000024  d5fc              BPL      |L40.32|
;;;996            switch(I2C_GET_STATUS(i2c))
000026  68c4              LDR      r4,[r0,#0xc]
000028  2c20              CMP      r4,#0x20
00002a  d019              BEQ      |L40.96|
00002c  dc04              BGT      |L40.56|
00002e  2c08              CMP      r4,#8
000030  d00e              BEQ      |L40.80|
000032  2c18              CMP      r4,#0x18
000034  d104              BNE      |L40.64|
000036  e010              B        |L40.90|
                  |L40.56|
000038  2c28              CMP      r4,#0x28
00003a  d014              BEQ      |L40.102|
00003c  2c30              CMP      r4,#0x30
00003e  d00f              BEQ      |L40.96|
                  |L40.64|
;;;997            {
;;;998            case 0x08u:
;;;999                I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1u | 0x00u));               /* Write SLA+W to Register I2CDAT */
;;;1000               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1001               break;
;;;1002           case 0x18u:                                                      /* Slave Address ACK */
;;;1003               I2C_SET_DATA(i2c, (uint8_t)((u16DataAddr & 0xFF00u) >> 8u));    /* Write Hi byte address of register */
;;;1004               break;
;;;1005           case 0x20u:                                                      /* Slave Address NACK */
;;;1006           case 0x30u:                                                      /* Master transmit data NACK */
;;;1007               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1008               u8Err = 1u;
;;;1009               break;
;;;1010           case 0x28u:
;;;1011               if(u8Addr)
;;;1012               {
;;;1013                   I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFFu));       /* Write Lo byte address of register */
;;;1014                   u8Addr = 0u;
;;;1015               }
;;;1016               else if((u32txLen < u32wLen) && (u8Addr == 0u))
;;;1017               {
;;;1018                   I2C_SET_DATA(i2c, data[u32txLen++]);                           /* Write data to Register I2CDAT*/
;;;1019               }
;;;1020               else
;;;1021               {
;;;1022                   u8Ctrl = I2C_CTL_STO_SI;                              /* Clear SI and send STOP */
;;;1023                   u8Xfering = 0u;
;;;1024               }
;;;1025               break;
;;;1026           case 0x38u:                                                      /* Arbitration Lost */
;;;1027           default:                                                        /* Unknow status */
;;;1028               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);                   /* Clear SI and send STOP */
000040  6804              LDR      r4,[r0,#0]
000042  f024043c          BIC      r4,r4,#0x3c
000046  f0440418          ORR      r4,r4,#0x18
00004a  6004              STR      r4,[r0,#0]
;;;1029               u8Ctrl = I2C_CTL_SI;
00004c  2508              MOVS     r5,#8
;;;1030               u8Err = 1u;
;;;1031               break;
00004e  e008              B        |L40.98|
                  |L40.80|
000050  064c              LSLS     r4,r1,#25             ;999
000052  0e24              LSRS     r4,r4,#24             ;999
000054  6084              STR      r4,[r0,#8]            ;999
000056  2508              MOVS     r5,#8                 ;1000
000058  e016              B        |L40.136|
                  |L40.90|
00005a  0a14              LSRS     r4,r2,#8              ;1003
00005c  6084              STR      r4,[r0,#8]            ;1003
00005e  e013              B        |L40.136|
                  |L40.96|
000060  2518              MOVS     r5,#0x18              ;1007
                  |L40.98|
000062  2701              MOVS     r7,#1                 ;1008
000064  e010              B        |L40.136|
                  |L40.102|
000066  f1bc0f00          CMP      r12,#0                ;1011
00006a  d004              BEQ      |L40.118|
00006c  b2d4              UXTB     r4,r2                 ;1013
00006e  6084              STR      r4,[r0,#8]            ;1013
000070  f04f0c00          MOV      r12,#0                ;1014
000074  e008              B        |L40.136|
                  |L40.118|
000076  454e              CMP      r6,r9                 ;1016
000078  d203              BCS      |L40.130|
00007a  5d9c              LDRB     r4,[r3,r6]            ;1018
00007c  6084              STR      r4,[r0,#8]            ;1018
00007e  1c76              ADDS     r6,r6,#1              ;1018
000080  e002              B        |L40.136|
                  |L40.130|
000082  2518              MOVS     r5,#0x18              ;1022
000084  f04f0800          MOV      r8,#0                 ;1023
                  |L40.136|
;;;1032           }
;;;1033           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                   /* Write controlbit to I2C_CTL register */
000088  6804              LDR      r4,[r0,#0]
00008a  f024043c          BIC      r4,r4,#0x3c
00008e  432c              ORRS     r4,r4,r5
000090  6004              STR      r4,[r0,#0]
000092  f1b80f00          CMP      r8,#0                 ;993
000096  d001              BEQ      |L40.156|
000098  2f00              CMP      r7,#0                 ;993
00009a  d0c1              BEQ      |L40.32|
                  |L40.156|
;;;1034       }
;;;1035       return u32txLen;                                                        /* Return bytes length that have been transmitted */
00009c  4630              MOV      r0,r6
;;;1036   }
00009e  e8bd83f0          POP      {r4-r9,pc}
;;;1037   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_I2C_Open____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_i2c_c_I2C_Open____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_I2C_Open____REVSH|
#line 402
|__asm___5_i2c_c_I2C_Open____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_I2C_Open____RRX|
#line 587
|__asm___5_i2c_c_I2C_Open____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
