; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\timer.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\timer.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -I..\..\Template -I..\Kalman_Filter -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\timer.crf ..\..\..\Library\StdDriver\src\timer.c]
                          THUMB

                          AREA ||i.TIMER_Close||, CODE, READONLY, ALIGN=1

                  TIMER_Close PROC
;;;72       */
;;;73     void TIMER_Close(TIMER_T *timer)
000000  2100              MOVS     r1,#0
;;;74     {
;;;75         timer->CTL = 0UL;
000002  6001              STR      r1,[r0,#0]
;;;76         timer->EXTCTL = 0UL;
000004  6141              STR      r1,[r0,#0x14]
;;;77     }
000006  4770              BX       lr
;;;78     
                          ENDP


                          AREA ||i.TIMER_Delay||, CODE, READONLY, ALIGN=2

                  TIMER_Delay PROC
;;;90       */
;;;91     void TIMER_Delay(TIMER_T *timer, uint32_t u32Usec)
000000  b570              PUSH     {r4-r6,lr}
;;;92     {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;93         uint32_t u32Clk = TIMER_GetModuleClock(timer);
000006  f7fffffe          BL       TIMER_GetModuleClock
;;;94         uint32_t u32Prescale = 0UL, delay = (SystemCoreClock / u32Clk) + 1UL;
00000a  491b              LDR      r1,|L2.120|
00000c  2200              MOVS     r2,#0
00000e  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
;;;95         uint32_t u32Cmpr, u32NsecPerTick;
;;;96     
;;;97         /* Clear current timer configuration */
;;;98         timer->CTL = 0UL;
000010  602a              STR      r2,[r5,#0]
000012  fbb1f1f0          UDIV     r1,r1,r0              ;94
;;;99         timer->EXTCTL = 0UL;
000016  616a              STR      r2,[r5,#0x14]
;;;100    
;;;101        if(u32Clk <= 1000000UL)   /* min delay is 1000 us if timer clock source is <= 1 MHz */
000018  4b18              LDR      r3,|L2.124|
00001a  1c49              ADDS     r1,r1,#1
00001c  4298              CMP      r0,r3
00001e  d805              BHI      |L2.44|
;;;102        {
;;;103            if(u32Usec < 1000UL)
000020  f44f767a          MOV      r6,#0x3e8
000024  42b4              CMP      r4,r6
000026  d205              BCS      |L2.52|
;;;104            {
;;;105                u32Usec = 1000UL;
000028  4634              MOV      r4,r6
00002a  e006              B        |L2.58|
                  |L2.44|
;;;106            }
;;;107            if(u32Usec > 1000000UL)
;;;108            {
;;;109                u32Usec = 1000000UL;
;;;110            }
;;;111        }
;;;112        else
;;;113        {
;;;114            if(u32Usec < 100UL)
00002c  2c64              CMP      r4,#0x64
00002e  d201              BCS      |L2.52|
;;;115            {
;;;116                u32Usec = 100UL;
000030  2464              MOVS     r4,#0x64
000032  e002              B        |L2.58|
                  |L2.52|
;;;117            }
;;;118            if(u32Usec > 1000000UL)
000034  429c              CMP      r4,r3
000036  d900              BLS      |L2.58|
;;;119            {
;;;120                u32Usec = 1000000UL;
000038  461c              MOV      r4,r3
                  |L2.58|
;;;121            }
;;;122        }
;;;123    
;;;124        if(u32Clk <= 1000000UL)
00003a  4298              CMP      r0,r3
00003c  d808              BHI      |L2.80|
;;;125        {
;;;126            u32Prescale = 0UL;
;;;127            u32NsecPerTick = 1000000000UL / u32Clk;
00003e  4b10              LDR      r3,|L2.128|
000040  fbb3f0f0          UDIV     r0,r3,r0
;;;128            u32Cmpr = (u32Usec * 1000UL) / u32NsecPerTick;
000044  f44f737a          MOV      r3,#0x3e8
000048  435c              MULS     r4,r3,r4
00004a  fbb4f0f0          UDIV     r0,r4,r0
00004e  e007              B        |L2.96|
                  |L2.80|
;;;129        }
;;;130        else
;;;131        {
;;;132            u32Cmpr = u32Usec * (u32Clk / 1000000UL);
000050  fbb0f0f3          UDIV     r0,r0,r3
000054  4360              MULS     r0,r4,r0
;;;133            u32Prescale = (u32Cmpr >> 24);  /* for 24 bits CMPDAT */
000056  0e02              LSRS     r2,r0,#24
;;;134            if (u32Prescale > 0UL)
000058  d002              BEQ      |L2.96|
;;;135                u32Cmpr = u32Cmpr / (u32Prescale + 1UL);
00005a  1c53              ADDS     r3,r2,#1
00005c  fbb0f0f3          UDIV     r0,r0,r3
                  |L2.96|
;;;136        }
;;;137    
;;;138        timer->CMP = u32Cmpr;
000060  6068              STR      r0,[r5,#4]
;;;139        timer->CTL = TIMER_CTL_CNTEN_Msk | TIMER_ONESHOT_MODE | u32Prescale;
000062  f0424080          ORR      r0,r2,#0x40000000
000066  6028              STR      r0,[r5,#0]
;;;140    
;;;141        /* When system clock is faster than timer clock, it is possible timer active bit cannot set in time while we check it.
;;;142           And the while loop below return immediately, so put a tiny delay here allowing timer start counting and raise active flag. */
;;;143        for(; delay > 0UL; delay--)
000068  b111              CBZ      r1,|L2.112|
                  |L2.106|
;;;144        {
;;;145            __NOP();
00006a  bf00              NOP      
00006c  1e49              SUBS     r1,r1,#1
00006e  d1fc              BNE      |L2.106|
                  |L2.112|
;;;146        }
;;;147    
;;;148        while(timer->CTL & TIMER_CTL_ACTSTS_Msk)
000070  6828              LDR      r0,[r5,#0]
000072  0180              LSLS     r0,r0,#6
000074  d4fc              BMI      |L2.112|
;;;149        {
;;;150            ;
;;;151        }
;;;152    }
000076  bd70              POP      {r4-r6,pc}
;;;153    
                          ENDP

                  |L2.120|
                          DCD      SystemCoreClock
                  |L2.124|
                          DCD      0x000f4240
                  |L2.128|
                          DCD      0x3b9aca00

                          AREA ||i.TIMER_DisableCapture||, CODE, READONLY, ALIGN=1

                  TIMER_DisableCapture PROC
;;;187      */
;;;188    void TIMER_DisableCapture(TIMER_T *timer)
000000  6941              LDR      r1,[r0,#0x14]
;;;189    {
;;;190        timer->EXTCTL &= ~TIMER_EXTCTL_CAPEN_Msk;
000002  f0210108          BIC      r1,r1,#8
000006  6141              STR      r1,[r0,#0x14]
;;;191    }
000008  4770              BX       lr
;;;192    
                          ENDP


                          AREA ||i.TIMER_DisableEventCounter||, CODE, READONLY, ALIGN=1

                  TIMER_DisableEventCounter PROC
;;;221      */
;;;222    void TIMER_DisableEventCounter(TIMER_T *timer)
000000  6801              LDR      r1,[r0,#0]
;;;223    {
;;;224        timer->CTL &= ~TIMER_CTL_EXTCNTEN_Msk;
000002  f0217180          BIC      r1,r1,#0x1000000
000006  6001              STR      r1,[r0,#0]
;;;225    }
000008  4770              BX       lr
;;;226    
                          ENDP


                          AREA ||i.TIMER_DisableFreqCounter||, CODE, READONLY, ALIGN=1

                  TIMER_DisableFreqCounter PROC
;;;312      */
;;;313    void TIMER_DisableFreqCounter(TIMER_T *timer)
000000  6801              LDR      r1,[r0,#0]
;;;314    {
;;;315        timer->CTL &= ~TIMER_CTL_INTRGEN_Msk;
000002  f4212100          BIC      r1,r1,#0x80000
000006  6001              STR      r1,[r0,#0]
;;;316    }
000008  4770              BX       lr
;;;317    
                          ENDP


                          AREA ||i.TIMER_EnableCapture||, CODE, READONLY, ALIGN=1

                  TIMER_EnableCapture PROC
;;;172      */
;;;173    void TIMER_EnableCapture(TIMER_T *timer, uint32_t u32CapMode, uint32_t u32Edge)
000000  b510              PUSH     {r4,lr}
;;;174    {
;;;175        timer->EXTCTL = (timer->EXTCTL & ~(TIMER_EXTCTL_CAPFUNCS_Msk | TIMER_EXTCTL_CAPEDGE_Msk)) |
000002  6943              LDR      r3,[r0,#0x14]
000004  f2470410          MOV      r4,#0x7010
000008  43a3              BICS     r3,r3,r4
00000a  430b              ORRS     r3,r3,r1
00000c  4313              ORRS     r3,r3,r2
00000e  f0430108          ORR      r1,r3,#8
000012  6141              STR      r1,[r0,#0x14]
;;;176                        u32CapMode | u32Edge | TIMER_EXTCTL_CAPEN_Msk;
;;;177    }
000014  bd10              POP      {r4,pc}
;;;178    
                          ENDP


                          AREA ||i.TIMER_EnableEventCounter||, CODE, READONLY, ALIGN=1

                  TIMER_EnableEventCounter PROC
;;;206      */
;;;207    void TIMER_EnableEventCounter(TIMER_T *timer, uint32_t u32Edge)
000000  6942              LDR      r2,[r0,#0x14]
;;;208    {
;;;209        timer->EXTCTL = (timer->EXTCTL & ~TIMER_EXTCTL_CNTPHASE_Msk) | u32Edge;
000002  f0220201          BIC      r2,r2,#1
000006  430a              ORRS     r2,r2,r1
000008  6142              STR      r2,[r0,#0x14]
;;;210        timer->CTL |= TIMER_CTL_EXTCNTEN_Msk;
00000a  6801              LDR      r1,[r0,#0]
00000c  f0417180          ORR      r1,r1,#0x1000000
000010  6001              STR      r1,[r0,#0]
;;;211    }
000012  4770              BX       lr
;;;212    
                          ENDP


                          AREA ||i.TIMER_EnableFreqCounter||, CODE, READONLY, ALIGN=2

                  TIMER_EnableFreqCounter PROC
;;;292      */
;;;293    void TIMER_EnableFreqCounter(TIMER_T *timer,
000000  4908              LDR      r1,|L8.36|
;;;294                                 uint32_t u32DropCount,
;;;295                                 uint32_t u32Timeout,
;;;296                                 uint32_t u32EnableInt)
;;;297    {
;;;298        TIMER_T *t;    /* store the timer base to configure compare value */
;;;299    
;;;300        t = (timer == TIMER0) ? TIMER1 : TIMER3;
000002  4288              CMP      r0,r1
000004  d101              BNE      |L8.10|
000006  4908              LDR      r1,|L8.40|
000008  e000              B        |L8.12|
                  |L8.10|
00000a  4908              LDR      r1,|L8.44|
                  |L8.12|
;;;301    
;;;302        t->CMP = 0xFFFFFFUL;
00000c  f06f427f          MVN      r2,#0xff000000
000010  604a              STR      r2,[r1,#4]
;;;303        t->EXTCTL = u32EnableInt ? TIMER_EXTCTL_CAPIEN_Msk : 0UL;
000012  b10b              CBZ      r3,|L8.24|
000014  2220              MOVS     r2,#0x20
000016  e000              B        |L8.26|
                  |L8.24|
000018  2200              MOVS     r2,#0
                  |L8.26|
00001a  614a              STR      r2,[r1,#0x14]
;;;304        timer->CTL = TIMER_CTL_INTRGEN_Msk | TIMER_CTL_CNTEN_Msk;
00001c  4904              LDR      r1,|L8.48|
00001e  6001              STR      r1,[r0,#0]
;;;305    
;;;306        return;
;;;307    }
000020  4770              BX       lr
;;;308    /**
                          ENDP

000022  0000              DCW      0x0000
                  |L8.36|
                          DCD      0x40050000
                  |L8.40|
                          DCD      0x40050100
                  |L8.44|
                          DCD      0x40051100
                  |L8.48|
                          DCD      0x40080000

                          AREA ||i.TIMER_GetModuleClock||, CODE, READONLY, ALIGN=2

                  TIMER_GetModuleClock PROC
;;;236      */
;;;237    uint32_t TIMER_GetModuleClock(TIMER_T *timer)
000000  b510              PUSH     {r4,lr}
;;;238    {
000002  b088              SUB      sp,sp,#0x20
000004  4604              MOV      r4,r0
;;;239        uint32_t u32Src, u32Clk;
;;;240        const uint32_t au32Clk[] = {__HXT, __LXT, 0UL, 0UL, 0UL, __LIRC, 0UL, __HIRC};
000006  2220              MOVS     r2,#0x20
000008  4917              LDR      r1,|L9.104|
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       __aeabi_memcpy4
;;;241    
;;;242        if(timer == TIMER0)
000010  4a16              LDR      r2,|L9.108|
;;;243        {
;;;244            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR0SEL_Msk) >> CLK_CLKSEL1_TMR0SEL_Pos;
;;;245        }
;;;246        else if(timer == TIMER1)
000012  4b17              LDR      r3,|L9.112|
000014  0390              LSLS     r0,r2,#14             ;244
000016  4294              CMP      r4,r2                 ;242
000018  d104              BNE      |L9.36|
00001a  f8d00214          LDR      r0,[r0,#0x214]        ;244
00001e  f3c02102          UBFX     r1,r0,#8,#3           ;244
000022  e010              B        |L9.70|
                  |L9.36|
000024  429c              CMP      r4,r3
000026  d104              BNE      |L9.50|
;;;247        {
;;;248            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR1SEL_Msk) >> CLK_CLKSEL1_TMR1SEL_Pos;
000028  f8d00214          LDR      r0,[r0,#0x214]
00002c  f3c03102          UBFX     r1,r0,#12,#3
000030  e009              B        |L9.70|
                  |L9.50|
;;;249        }
;;;250        else if(timer == TIMER2)
000032  4910              LDR      r1,|L9.116|
;;;251        {
;;;252            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR2SEL_Msk) >> CLK_CLKSEL1_TMR2SEL_Pos;
;;;253        }
;;;254        else      /* Timer 3 */
;;;255        {
;;;256            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR3SEL_Msk) >> CLK_CLKSEL1_TMR3SEL_Pos;
000034  f8d00214          LDR      r0,[r0,#0x214]
000038  428c              CMP      r4,r1                 ;250
00003a  d102              BNE      |L9.66|
00003c  f3c04102          UBFX     r1,r0,#16,#3          ;252
000040  e001              B        |L9.70|
                  |L9.66|
000042  f3c05102          UBFX     r1,r0,#20,#3
                  |L9.70|
;;;257        }
;;;258    
;;;259        if(u32Src == 2UL)
000046  2902              CMP      r1,#2
000048  d003              BEQ      |L9.82|
;;;260        {
;;;261            if((timer == TIMER0) || (timer == TIMER1))
;;;262            {
;;;263                u32Clk = CLK_GetPCLK0Freq();
;;;264            }
;;;265            else
;;;266            {
;;;267                u32Clk = CLK_GetPCLK1Freq();
;;;268            }
;;;269        }
;;;270        else
;;;271        {
;;;272            u32Clk = au32Clk[u32Src];
00004a  f85d0021          LDR      r0,[sp,r1,LSL #2]
                  |L9.78|
;;;273        }
;;;274    
;;;275        return u32Clk;
;;;276    }
00004e  b008              ADD      sp,sp,#0x20
000050  bd10              POP      {r4,pc}
                  |L9.82|
000052  4294              CMP      r4,r2                 ;261
000054  d001              BEQ      |L9.90|
000056  429c              CMP      r4,r3                 ;261
000058  d102              BNE      |L9.96|
                  |L9.90|
00005a  f7fffffe          BL       CLK_GetPCLK0Freq
00005e  e7f6              B        |L9.78|
                  |L9.96|
000060  f7fffffe          BL       CLK_GetPCLK1Freq
000064  e7f3              B        |L9.78|
;;;277    
                          ENDP

000066  0000              DCW      0x0000
                  |L9.104|
                          DCD      ||.constdata||
                  |L9.108|
                          DCD      0x40050000
                  |L9.112|
                          DCD      0x40050100
                  |L9.116|
                          DCD      0x40051000

                          AREA ||i.TIMER_Open||, CODE, READONLY, ALIGN=1

                  TIMER_Open PROC
;;;39       */
;;;40     uint32_t TIMER_Open(TIMER_T *timer, uint32_t u32Mode, uint32_t u32Freq)
000000  b570              PUSH     {r4-r6,lr}
;;;41     {
000002  4616              MOV      r6,r2
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
;;;42         uint32_t u32Clk = TIMER_GetModuleClock(timer);
000008  f7fffffe          BL       TIMER_GetModuleClock
;;;43         uint32_t u32Cmpr = 0UL, u32Prescale = 0UL;
00000c  2300              MOVS     r3,#0
;;;44     
;;;45         /* Fastest possible timer working freq is (u32Clk / 2). While cmpr = 2, prescaler = 0. */
;;;46         if(u32Freq > (u32Clk / 2UL))
00000e  ebb60f50          CMP      r6,r0,LSR #1
000012  d901              BLS      |L10.24|
;;;47         {
;;;48             u32Cmpr = 2UL;
000014  2202              MOVS     r2,#2
000016  e006              B        |L10.38|
                  |L10.24|
;;;49         }
;;;50         else
;;;51         {
;;;52             u32Cmpr = u32Clk / u32Freq;
000018  fbb0f2f6          UDIV     r2,r0,r6
;;;53             u32Prescale = (u32Cmpr >> 24);  /* for 24 bits CMPDAT */
00001c  0e13              LSRS     r3,r2,#24
;;;54             if (u32Prescale > 0UL)
00001e  d002              BEQ      |L10.38|
;;;55                 u32Cmpr = u32Cmpr / (u32Prescale + 1UL);
000020  1c59              ADDS     r1,r3,#1
000022  fbb2f2f1          UDIV     r2,r2,r1
                  |L10.38|
;;;56         }
;;;57     
;;;58         timer->CTL = u32Mode | u32Prescale;
000026  431d              ORRS     r5,r5,r3
000028  6025              STR      r5,[r4,#0]
;;;59         timer->CMP = u32Cmpr;
00002a  6062              STR      r2,[r4,#4]
00002c  1c5b              ADDS     r3,r3,#1
;;;60     
;;;61         return(u32Clk / (u32Cmpr * (u32Prescale + 1UL)));
00002e  435a              MULS     r2,r3,r2
000030  fbb0f0f2          UDIV     r0,r0,r2
;;;62     }
000034  bd70              POP      {r4-r6,pc}
;;;63     
                          ENDP


                          AREA ||i.TIMER_SetTriggerSource||, CODE, READONLY, ALIGN=1

                  TIMER_SetTriggerSource PROC
;;;326      */
;;;327    void TIMER_SetTriggerSource(TIMER_T *timer, uint32_t u32Src)
000000  69c2              LDR      r2,[r0,#0x1c]
;;;328    {
;;;329        timer->TRGCTL = (timer->TRGCTL & ~TIMER_TRGCTL_TRGSSEL_Msk) | u32Src;
000002  f0220201          BIC      r2,r2,#1
000006  430a              ORRS     r2,r2,r1
000008  61c2              STR      r2,[r0,#0x1c]
;;;330    }
00000a  4770              BX       lr
;;;331    
                          ENDP


                          AREA ||i.TIMER_SetTriggerTarget||, CODE, READONLY, ALIGN=1

                  TIMER_SetTriggerTarget PROC
;;;341      */
;;;342    void TIMER_SetTriggerTarget(TIMER_T *timer, uint32_t u32Mask)
000000  69c2              LDR      r2,[r0,#0x1c]
;;;343    {
;;;344        timer->TRGCTL = (timer->TRGCTL & ~(TIMER_TRGCTL_TRGEPWM_Msk | TIMER_TRGCTL_TRGDAC_Msk | TIMER_TRGCTL_TRGEADC_Msk | TIMER_TRGCTL_TRGPDMA_Msk)) | u32Mask;
000002  f022021e          BIC      r2,r2,#0x1e
000006  430a              ORRS     r2,r2,r1
000008  61c2              STR      r2,[r0,#0x1c]
;;;345    }
00000a  4770              BX       lr
;;;346    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00b71b00
                          DCD      0x00008000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00002710
                          DCD      0x00000000
                          DCD      0x00b71b00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\timer.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_timer_c_5bec749a____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___7_timer_c_5bec749a____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_timer_c_5bec749a____REVSH|
#line 402
|__asm___7_timer_c_5bec749a____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___7_timer_c_5bec749a____RRX|
#line 587
|__asm___7_timer_c_5bec749a____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
